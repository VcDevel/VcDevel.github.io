<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.11.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Vc: SIMD Array</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
  $(function() { init_search(); });
/* @license-end */
</script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="logo_small.png"/></td>
  <td id="projectalign">
   <div id="projectname">Vc<span id="projectnumber">&#160;1.4.5</span>
   </div>
   <div id="projectbrief">SIMD Vector Classes for C++</div>
  </td>
    <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <span id="MSearchSelect"                onmouseover="return searchBox.OnSearchSelectShow()"                onmouseout="return searchBox.OnSearchSelectHide()">&#160;</span>
          <input type="text" id="MSearchField" value="" placeholder="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.11.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('group__SimdArray.html',''); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle"><div class="title">SIMD Array</div></div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>This set of class templates and associated functions and operators enables data-parallel algorithms and data structures requiring a user-defined number of elements (fixed at compile time, in contrast to <code>std::valarray</code> where the number of elements is only determined at run time). The main motivation for a user-defined number of elements is the need for type conversion and thus a guaranteed equal number of elements in data-parallel vectors for e.g. <code>float</code> and <code>int</code>. A typical pattern looks like this: </p><div class="fragment"><div class="line"><span class="keyword">using </span>floatv = <a class="code hl_typedef" href="group__Vectors.html#ga5cf7c5a0dadbbbbcb9b69c5e42ee0528">Vc::float_v</a>;</div>
<div class="line"><span class="keyword">using </span>doublev = <a class="code hl_class" href="classVc_1_1SimdArray.html">Vc::SimdArray</a>&lt;double, floatv::size()&gt;;</div>
<div class="line"><span class="keyword">using </span>intv = <a class="code hl_class" href="classVc_1_1SimdArray.html">Vc::SimdArray</a>&lt;int, floatv::size()&gt;;</div>
<div class="line"><span class="keyword">using </span>uintv = <a class="code hl_class" href="classVc_1_1SimdArray.html">Vc::SimdArray</a>&lt;<span class="keywordtype">unsigned</span> int, floatv::size()&gt;;</div>
<div class="ttc" id="aclassVc_1_1SimdArray_html"><div class="ttname"><a href="classVc_1_1SimdArray.html">Vc::SimdArray</a></div><div class="ttdoc">Data-parallel arithmetic type with user-defined number of elements.</div><div class="ttdef"><b>Definition</b> <a href="simdarray_8h_source.html#l00616">simdarray.h:617</a></div></div>
<div class="ttc" id="agroup__Vectors_html_ga5cf7c5a0dadbbbbcb9b69c5e42ee0528"><div class="ttname"><a href="group__Vectors.html#ga5cf7c5a0dadbbbbcb9b69c5e42ee0528">Vc::float_v</a></div><div class="ttdeci">Vector&lt; float &gt; float_v</div><div class="ttdoc">vector of single precision</div><div class="ttdef"><b>Definition</b> <a href="vector_8h_source.html#l00054">vector.h:54</a></div></div>
</div><!-- fragment --><p>The second motivation for a user-defined number of elements is that many vertical vectorizations require a fixed number of elements (i.e. number known at development time and not chosen at compile time). The implementation can then choose how to support this number most efficiently with the available hardware resources. Consider, for example, a need for processing 12 values in parallel. On x86 with AVX, the implementation could build such a type from one AVX and one SSE register.</p>
<p>In contrast to <code>std::array</code> the types behave like the <a class="el" href="classVc_1_1Vector.html" title="The main vector class for expressing data parallelism.">Vc::Vector</a> types, implementing the same operators and functions. The semantics with regard to implicit conversions differ slightly: The <a class="el" href="classVc_1_1Vector.html" title="The main vector class for expressing data parallelism.">Vc::Vector</a> conversion rules are safer with regard to source compatibility. The <a class="el" href="classVc_1_1SimdArray.html" title="Data-parallel arithmetic type with user-defined number of elements.">Vc::SimdArray</a> conversion rules are less strict and could potentially lead to portability issues. Therefore, it is best to stick to the pattern of type aliases shown above. </p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVc_1_1SimdArray.html">SimdArray&lt; T, N, V, Wt &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Data-parallel arithmetic type with user-defined number of elements.  <a href="classVc_1_1SimdArray.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVc_1_1SimdMaskArray.html">SimdMaskArray&lt; T, N, V, Wt &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Data-parallel mask type with user-defined number of boolean elements.  <a href="classVc_1_1SimdMaskArray.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="var-members" name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:gaac286912729d28478c8c9a1ac97a92ac" id="r_gaac286912729d28478c8c9a1ac97a92ac"><td class="memItemLeft" align="right" valign="top">static constexpr std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gaac286912729d28478c8c9a1ac97a92ac">MemoryAlignment</a></td></tr>
<tr class="memdesc:gaac286912729d28478c8c9a1ac97a92ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specifies the alignment requirement for aligned load and store calls for objects of this vector type.     <br /></td></tr>
<tr class="separator:gaac286912729d28478c8c9a1ac97a92ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad550c4cd366024e9b37c4a7c7c9b96ff" id="r_gad550c4cd366024e9b37c4a7c7c9b96ff"><td class="memItemLeft" align="right" valign="top">static constexpr std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gad550c4cd366024e9b37c4a7c7c9b96ff">Size</a> = <a class="el" href="classVc_1_1SimdMaskArray.html#a5e99fb015bfbc024a4b785135b34dee7">size</a>()</td></tr>
<tr class="memdesc:gad550c4cd366024e9b37c4a7c7c9b96ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of boolean components ( \(\mathcal{W}_\mathtt{T}\) ) in a mask of this type.           <br /></td></tr>
<tr class="separator:gad550c4cd366024e9b37c4a7c7c9b96ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaac286912729d28478c8c9a1ac97a92ac" id="r_gaac286912729d28478c8c9a1ac97a92ac"><td class="memItemLeft" align="right" valign="top">static constexpr std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gaac286912729d28478c8c9a1ac97a92ac">MemoryAlignment</a></td></tr>
<tr class="memdesc:gaac286912729d28478c8c9a1ac97a92ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specifies the alignment requirement for aligned load and store calls for objects of this mask type.     <br /></td></tr>
<tr class="separator:gaac286912729d28478c8c9a1ac97a92ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Arithmetic and Bitwise Operators</h2></td></tr>
<tr><td class="ititle" colspan="2"><p>Applies the operator component-wise and concurrently on <code>lhs</code> and <code>rhs</code> and returns a new <a class="el" href="classVc_1_1SimdArray.html" title="Data-parallel arithmetic type with user-defined number of elements.">SimdArray</a> object containing the result values.</p>
<p>This operator only participates in overload resolution if: </p><ul>
<li>At least one of the template parameters <code>L</code> or <code>R</code> is a <a class="el" href="classVc_1_1SimdArray.html" title="Data-parallel arithmetic type with user-defined number of elements.">SimdArray</a> type. </li>
<li>Either <code>L</code> or <code>R</code> is a fundamental arithmetic type but not an integral type larger than <code>int</code> <br  />
 or <br  />
 <code>L</code> or <code>R</code> is a <a class="el" href="classVc_1_1Vector.html" title="The main vector class for expressing data parallelism.">Vc::Vector</a> type with equal number of elements (<a class="el" href="classVc_1_1Vector.html#a1b5d7e2e663d7997796fd9f72b8af75a" title="Returns the number of scalar components (  ) in a vector of this type.">Vector::size()</a> == <a class="el" href="classVc_1_1SimdArray.html#a5e99fb015bfbc024a4b785135b34dee7" title="Returns N, the number of scalar components in an object of this type.">SimdArray::size()</a>).</li>
</ul>
<p>The return type of the operator is a <a class="el" href="classVc_1_1SimdArray.html" title="Data-parallel arithmetic type with user-defined number of elements.">SimdArray</a> type using the more precise EntryType of <code>L</code> or <code>R</code> and the same number of elements as the <a class="el" href="classVc_1_1SimdArray.html" title="Data-parallel arithmetic type with user-defined number of elements.">SimdArray</a> argument(s). </p>
</td></tr>
<tr class="memitem:ga80b968160a571d3b623d975e0ae534ad" id="r_ga80b968160a571d3b623d975e0ae534ad"><td class="memTemplParams" colspan="2"><a id="ga80b968160a571d3b623d975e0ae534ad" name="ga80b968160a571d3b623d975e0ae534ad"></a>
template&lt;typename L , typename R &gt; </td></tr>
<tr class="memitem:ga80b968160a571d3b623d975e0ae534ad"><td class="memTemplItemLeft" align="right" valign="top">result_vector_type&lt; L, R &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator+</b> (L &amp;&amp;lhs, R &amp;&amp;rhs)</td></tr>
<tr class="memdesc:ga80b968160a571d3b623d975e0ae534ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies + component-wise and concurrently. <br  />
 <br /></td></tr>
<tr class="separator:ga80b968160a571d3b623d975e0ae534ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6285d807d3c5f9de8f2c0253bdfc43b0" id="r_ga6285d807d3c5f9de8f2c0253bdfc43b0"><td class="memTemplParams" colspan="2"><a id="ga6285d807d3c5f9de8f2c0253bdfc43b0" name="ga6285d807d3c5f9de8f2c0253bdfc43b0"></a>
template&lt;typename L , typename R &gt; </td></tr>
<tr class="memitem:ga6285d807d3c5f9de8f2c0253bdfc43b0"><td class="memTemplItemLeft" align="right" valign="top">result_vector_type&lt; L, R &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator-</b> (L &amp;&amp;lhs, R &amp;&amp;rhs)</td></tr>
<tr class="memdesc:ga6285d807d3c5f9de8f2c0253bdfc43b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies - component-wise and concurrently. <br  />
 <br /></td></tr>
<tr class="separator:ga6285d807d3c5f9de8f2c0253bdfc43b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga77fd8e8ad57334f44ef418e47a744c5a" id="r_ga77fd8e8ad57334f44ef418e47a744c5a"><td class="memTemplParams" colspan="2"><a id="ga77fd8e8ad57334f44ef418e47a744c5a" name="ga77fd8e8ad57334f44ef418e47a744c5a"></a>
template&lt;typename L , typename R &gt; </td></tr>
<tr class="memitem:ga77fd8e8ad57334f44ef418e47a744c5a"><td class="memTemplItemLeft" align="right" valign="top">result_vector_type&lt; L, R &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator*</b> (L &amp;&amp;lhs, R &amp;&amp;rhs)</td></tr>
<tr class="memdesc:ga77fd8e8ad57334f44ef418e47a744c5a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies * component-wise and concurrently. <br  />
 <br /></td></tr>
<tr class="separator:ga77fd8e8ad57334f44ef418e47a744c5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4ed64945c6ce6249d2da3bd0167a70bf" id="r_ga4ed64945c6ce6249d2da3bd0167a70bf"><td class="memTemplParams" colspan="2"><a id="ga4ed64945c6ce6249d2da3bd0167a70bf" name="ga4ed64945c6ce6249d2da3bd0167a70bf"></a>
template&lt;typename L , typename R &gt; </td></tr>
<tr class="memitem:ga4ed64945c6ce6249d2da3bd0167a70bf"><td class="memTemplItemLeft" align="right" valign="top">result_vector_type&lt; L, R &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator/</b> (L &amp;&amp;lhs, R &amp;&amp;rhs)</td></tr>
<tr class="memdesc:ga4ed64945c6ce6249d2da3bd0167a70bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies / component-wise and concurrently. <br  />
 <br /></td></tr>
<tr class="separator:ga4ed64945c6ce6249d2da3bd0167a70bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacc40395260df985dd651c548ecb71fce" id="r_gacc40395260df985dd651c548ecb71fce"><td class="memTemplParams" colspan="2"><a id="gacc40395260df985dd651c548ecb71fce" name="gacc40395260df985dd651c548ecb71fce"></a>
template&lt;typename L , typename R &gt; </td></tr>
<tr class="memitem:gacc40395260df985dd651c548ecb71fce"><td class="memTemplItemLeft" align="right" valign="top">result_vector_type&lt; L, R &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator%</b> (L &amp;&amp;lhs, R &amp;&amp;rhs)</td></tr>
<tr class="memdesc:gacc40395260df985dd651c548ecb71fce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies % component-wise and concurrently. <br  />
 <br /></td></tr>
<tr class="separator:gacc40395260df985dd651c548ecb71fce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7573fd09a39db6c6e6a250cd5a19e590" id="r_ga7573fd09a39db6c6e6a250cd5a19e590"><td class="memTemplParams" colspan="2"><a id="ga7573fd09a39db6c6e6a250cd5a19e590" name="ga7573fd09a39db6c6e6a250cd5a19e590"></a>
template&lt;typename L , typename R &gt; </td></tr>
<tr class="memitem:ga7573fd09a39db6c6e6a250cd5a19e590"><td class="memTemplItemLeft" align="right" valign="top">result_vector_type&lt; L, R &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator|</b> (L &amp;&amp;lhs, R &amp;&amp;rhs)</td></tr>
<tr class="memdesc:ga7573fd09a39db6c6e6a250cd5a19e590"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies | component-wise and concurrently. <br  />
 <br /></td></tr>
<tr class="separator:ga7573fd09a39db6c6e6a250cd5a19e590"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadf855a2bfef6e84c14040e33ce94ea46" id="r_gadf855a2bfef6e84c14040e33ce94ea46"><td class="memTemplParams" colspan="2"><a id="gadf855a2bfef6e84c14040e33ce94ea46" name="gadf855a2bfef6e84c14040e33ce94ea46"></a>
template&lt;typename L , typename R &gt; </td></tr>
<tr class="memitem:gadf855a2bfef6e84c14040e33ce94ea46"><td class="memTemplItemLeft" align="right" valign="top">result_vector_type&lt; L, R &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&amp;</b> (L &amp;&amp;lhs, R &amp;&amp;rhs)</td></tr>
<tr class="memdesc:gadf855a2bfef6e84c14040e33ce94ea46"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies &amp; component-wise and concurrently. <br  />
 <br /></td></tr>
<tr class="separator:gadf855a2bfef6e84c14040e33ce94ea46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf548f2963027b17a46bcf450b71a22c0" id="r_gaf548f2963027b17a46bcf450b71a22c0"><td class="memTemplParams" colspan="2"><a id="gaf548f2963027b17a46bcf450b71a22c0" name="gaf548f2963027b17a46bcf450b71a22c0"></a>
template&lt;typename L , typename R &gt; </td></tr>
<tr class="memitem:gaf548f2963027b17a46bcf450b71a22c0"><td class="memTemplItemLeft" align="right" valign="top">result_vector_type&lt; L, R &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator^</b> (L &amp;&amp;lhs, R &amp;&amp;rhs)</td></tr>
<tr class="memdesc:gaf548f2963027b17a46bcf450b71a22c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies ^ component-wise and concurrently. <br  />
 <br /></td></tr>
<tr class="separator:gaf548f2963027b17a46bcf450b71a22c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Compare Operators</h2></td></tr>
<tr><td class="ititle" colspan="2"><p>Applies the operator component-wise and concurrently on <code>lhs</code> and <code>rhs</code> and returns a new <a class="el" href="classVc_1_1SimdMaskArray.html" title="Data-parallel mask type with user-defined number of boolean elements.">SimdMaskArray</a> object containing the result values.</p>
<p>This operator only participates in overload resolution if (same rules as above): </p><ul>
<li>At least one of the template parameters <code>L</code> or <code>R</code> is a <a class="el" href="classVc_1_1SimdArray.html" title="Data-parallel arithmetic type with user-defined number of elements.">SimdArray</a> type. </li>
<li>Either <code>L</code> or <code>R</code> is a fundamental arithmetic type but not an integral type larger than <code>int</code> <br  />
 or <br  />
 <code>L</code> or <code>R</code> is a <a class="el" href="classVc_1_1Vector.html" title="The main vector class for expressing data parallelism.">Vc::Vector</a> type with equal number of elements (<a class="el" href="classVc_1_1Vector.html#a1b5d7e2e663d7997796fd9f72b8af75a" title="Returns the number of scalar components (  ) in a vector of this type.">Vector::size()</a> == <a class="el" href="classVc_1_1SimdArray.html#a5e99fb015bfbc024a4b785135b34dee7" title="Returns N, the number of scalar components in an object of this type.">SimdArray::size()</a>).</li>
</ul>
<p>The return type of the operator is a <a class="el" href="classVc_1_1SimdMaskArray.html" title="Data-parallel mask type with user-defined number of boolean elements.">SimdMaskArray</a> type using the more precise EntryType of <code>L</code> or <code>R</code> and the same number of elements as the <a class="el" href="classVc_1_1SimdArray.html" title="Data-parallel arithmetic type with user-defined number of elements.">SimdArray</a> argument(s). </p>
</td></tr>
<tr class="memitem:gafc47c0cdf2eafb9335b55353fe529854" id="r_gafc47c0cdf2eafb9335b55353fe529854"><td class="memTemplParams" colspan="2"><a id="gafc47c0cdf2eafb9335b55353fe529854" name="gafc47c0cdf2eafb9335b55353fe529854"></a>
template&lt;typename L , typename R &gt; </td></tr>
<tr class="memitem:gafc47c0cdf2eafb9335b55353fe529854"><td class="memTemplItemLeft" align="right" valign="top">result_vector_type&lt; L, R &gt;::mask_type&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator==</b> (L &amp;&amp;lhs, R &amp;&amp;rhs)</td></tr>
<tr class="memdesc:gafc47c0cdf2eafb9335b55353fe529854"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies == component-wise and concurrently. <br  />
 <br /></td></tr>
<tr class="separator:gafc47c0cdf2eafb9335b55353fe529854"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae682ac4f5a88d97c32e7a44e955172da" id="r_gae682ac4f5a88d97c32e7a44e955172da"><td class="memTemplParams" colspan="2"><a id="gae682ac4f5a88d97c32e7a44e955172da" name="gae682ac4f5a88d97c32e7a44e955172da"></a>
template&lt;typename L , typename R &gt; </td></tr>
<tr class="memitem:gae682ac4f5a88d97c32e7a44e955172da"><td class="memTemplItemLeft" align="right" valign="top">result_vector_type&lt; L, R &gt;::mask_type&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator!=</b> (L &amp;&amp;lhs, R &amp;&amp;rhs)</td></tr>
<tr class="memdesc:gae682ac4f5a88d97c32e7a44e955172da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies != component-wise and concurrently. <br  />
 <br /></td></tr>
<tr class="separator:gae682ac4f5a88d97c32e7a44e955172da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga99162763213932a50a0a4edb1003d49e" id="r_ga99162763213932a50a0a4edb1003d49e"><td class="memTemplParams" colspan="2"><a id="ga99162763213932a50a0a4edb1003d49e" name="ga99162763213932a50a0a4edb1003d49e"></a>
template&lt;typename L , typename R &gt; </td></tr>
<tr class="memitem:ga99162763213932a50a0a4edb1003d49e"><td class="memTemplItemLeft" align="right" valign="top">result_vector_type&lt; L, R &gt;::mask_type&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;=</b> (L &amp;&amp;lhs, R &amp;&amp;rhs)</td></tr>
<tr class="memdesc:ga99162763213932a50a0a4edb1003d49e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies &lt;= component-wise and concurrently. <br  />
 <br /></td></tr>
<tr class="separator:ga99162763213932a50a0a4edb1003d49e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga46470081be873074c4c58b53bfed4ce1" id="r_ga46470081be873074c4c58b53bfed4ce1"><td class="memTemplParams" colspan="2"><a id="ga46470081be873074c4c58b53bfed4ce1" name="ga46470081be873074c4c58b53bfed4ce1"></a>
template&lt;typename L , typename R &gt; </td></tr>
<tr class="memitem:ga46470081be873074c4c58b53bfed4ce1"><td class="memTemplItemLeft" align="right" valign="top">result_vector_type&lt; L, R &gt;::mask_type&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&gt;=</b> (L &amp;&amp;lhs, R &amp;&amp;rhs)</td></tr>
<tr class="memdesc:ga46470081be873074c4c58b53bfed4ce1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies &gt;= component-wise and concurrently. <br  />
 <br /></td></tr>
<tr class="separator:ga46470081be873074c4c58b53bfed4ce1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga489fa9274b7127370c1f14740ecc420b" id="r_ga489fa9274b7127370c1f14740ecc420b"><td class="memTemplParams" colspan="2"><a id="ga489fa9274b7127370c1f14740ecc420b" name="ga489fa9274b7127370c1f14740ecc420b"></a>
template&lt;typename L , typename R &gt; </td></tr>
<tr class="memitem:ga489fa9274b7127370c1f14740ecc420b"><td class="memTemplItemLeft" align="right" valign="top">result_vector_type&lt; L, R &gt;::mask_type&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;</b> (L &amp;&amp;lhs, R &amp;&amp;rhs)</td></tr>
<tr class="memdesc:ga489fa9274b7127370c1f14740ecc420b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies &lt; component-wise and concurrently. <br  />
 <br /></td></tr>
<tr class="separator:ga489fa9274b7127370c1f14740ecc420b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa9afb59ea3d267bbd773650016dcf1dd" id="r_gaa9afb59ea3d267bbd773650016dcf1dd"><td class="memTemplParams" colspan="2"><a id="gaa9afb59ea3d267bbd773650016dcf1dd" name="gaa9afb59ea3d267bbd773650016dcf1dd"></a>
template&lt;typename L , typename R &gt; </td></tr>
<tr class="memitem:gaa9afb59ea3d267bbd773650016dcf1dd"><td class="memTemplItemLeft" align="right" valign="top">result_vector_type&lt; L, R &gt;::mask_type&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&gt;</b> (L &amp;&amp;lhs, R &amp;&amp;rhs)</td></tr>
<tr class="memdesc:gaa9afb59ea3d267bbd773650016dcf1dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies &gt; component-wise and concurrently. <br  />
 <br /></td></tr>
<tr class="separator:gaa9afb59ea3d267bbd773650016dcf1dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Math functions</h2></td></tr>
<tr><td class="ititle" colspan="2"><p>These functions evaluate the </p>
</td></tr>
<tr class="memitem:gaca60c415008bf8fa7584b96d63273bc9" id="r_gaca60c415008bf8fa7584b96d63273bc9"><td class="memTemplParams" colspan="2"><a id="gaca60c415008bf8fa7584b96d63273bc9" name="gaca60c415008bf8fa7584b96d63273bc9"></a>
template&lt;typename T , std::size_t N, typename V , std::size_t M&gt; </td></tr>
<tr class="memitem:gaca60c415008bf8fa7584b96d63273bc9"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classVc_1_1Vector.html">fixed_size_simd</a>&lt; T, N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>abs</b> (const <a class="el" href="classVc_1_1SimdArray.html">SimdArray</a>&lt; T, N, V, M &gt; &amp;x)</td></tr>
<tr class="memdesc:gaca60c415008bf8fa7584b96d63273bc9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the std::abs function component-wise and concurrently. <br /></td></tr>
<tr class="separator:gaca60c415008bf8fa7584b96d63273bc9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8d20c72a003514c3dc9bb46a07b77479" id="r_ga8d20c72a003514c3dc9bb46a07b77479"><td class="memTemplParams" colspan="2"><a id="ga8d20c72a003514c3dc9bb46a07b77479" name="ga8d20c72a003514c3dc9bb46a07b77479"></a>
template&lt;typename T , std::size_t N, typename V , std::size_t M&gt; </td></tr>
<tr class="memitem:ga8d20c72a003514c3dc9bb46a07b77479"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classVc_1_1Vector.html">fixed_size_simd</a>&lt; T, N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>asin</b> (const <a class="el" href="classVc_1_1SimdArray.html">SimdArray</a>&lt; T, N, V, M &gt; &amp;x)</td></tr>
<tr class="memdesc:ga8d20c72a003514c3dc9bb46a07b77479"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the std::asin function component-wise and concurrently. <br /></td></tr>
<tr class="separator:ga8d20c72a003514c3dc9bb46a07b77479"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6a4d1542a5f997ce28e470f64d89783b" id="r_ga6a4d1542a5f997ce28e470f64d89783b"><td class="memTemplParams" colspan="2"><a id="ga6a4d1542a5f997ce28e470f64d89783b" name="ga6a4d1542a5f997ce28e470f64d89783b"></a>
template&lt;typename T , std::size_t N, typename V , std::size_t M&gt; </td></tr>
<tr class="memitem:ga6a4d1542a5f997ce28e470f64d89783b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classVc_1_1Vector.html">fixed_size_simd</a>&lt; T, N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>atan</b> (const <a class="el" href="classVc_1_1SimdArray.html">SimdArray</a>&lt; T, N, V, M &gt; &amp;x)</td></tr>
<tr class="memdesc:ga6a4d1542a5f997ce28e470f64d89783b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the std::atan function component-wise and concurrently. <br /></td></tr>
<tr class="separator:ga6a4d1542a5f997ce28e470f64d89783b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0ac6d145a987be25120dc4dfbd909a05" id="r_ga0ac6d145a987be25120dc4dfbd909a05"><td class="memTemplParams" colspan="2"><a id="ga0ac6d145a987be25120dc4dfbd909a05" name="ga0ac6d145a987be25120dc4dfbd909a05"></a>
template&lt;typename T , std::size_t N, typename V , std::size_t M&gt; </td></tr>
<tr class="memitem:ga0ac6d145a987be25120dc4dfbd909a05"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classVc_1_1Vector.html">fixed_size_simd</a>&lt; T, N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>atan2</b> (const <a class="el" href="classVc_1_1SimdArray.html">SimdArray</a>&lt; T, N, V, M &gt; &amp;x, const <a class="el" href="classVc_1_1SimdArray.html">SimdArray</a>&lt; T, N, V, M &gt; &amp;y)</td></tr>
<tr class="memdesc:ga0ac6d145a987be25120dc4dfbd909a05"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the std::atan2 function component-wise and concurrently. <br /></td></tr>
<tr class="separator:ga0ac6d145a987be25120dc4dfbd909a05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga232616ce5323c40c7f6edf5e3bc9a187" id="r_ga232616ce5323c40c7f6edf5e3bc9a187"><td class="memTemplParams" colspan="2"><a id="ga232616ce5323c40c7f6edf5e3bc9a187" name="ga232616ce5323c40c7f6edf5e3bc9a187"></a>
template&lt;typename T , std::size_t N, typename V , std::size_t M&gt; </td></tr>
<tr class="memitem:ga232616ce5323c40c7f6edf5e3bc9a187"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classVc_1_1Vector.html">fixed_size_simd</a>&lt; T, N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ceil</b> (const <a class="el" href="classVc_1_1SimdArray.html">SimdArray</a>&lt; T, N, V, M &gt; &amp;x)</td></tr>
<tr class="memdesc:ga232616ce5323c40c7f6edf5e3bc9a187"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the std::ceil function component-wise and concurrently. <br /></td></tr>
<tr class="separator:ga232616ce5323c40c7f6edf5e3bc9a187"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga62b791fecb11fa3190ebbee40ed5e4d4" id="r_ga62b791fecb11fa3190ebbee40ed5e4d4"><td class="memTemplParams" colspan="2"><a id="ga62b791fecb11fa3190ebbee40ed5e4d4" name="ga62b791fecb11fa3190ebbee40ed5e4d4"></a>
template&lt;typename T , std::size_t N, typename V , std::size_t M&gt; </td></tr>
<tr class="memitem:ga62b791fecb11fa3190ebbee40ed5e4d4"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classVc_1_1Vector.html">fixed_size_simd</a>&lt; T, N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>copysign</b> (const <a class="el" href="classVc_1_1SimdArray.html">SimdArray</a>&lt; T, N, V, M &gt; &amp;x, const <a class="el" href="classVc_1_1SimdArray.html">SimdArray</a>&lt; T, N, V, M &gt; &amp;y)</td></tr>
<tr class="memdesc:ga62b791fecb11fa3190ebbee40ed5e4d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the std::copysign function component-wise and concurrently. <br /></td></tr>
<tr class="separator:ga62b791fecb11fa3190ebbee40ed5e4d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga69b999a4bbde0b766930400dab181b3c" id="r_ga69b999a4bbde0b766930400dab181b3c"><td class="memTemplParams" colspan="2"><a id="ga69b999a4bbde0b766930400dab181b3c" name="ga69b999a4bbde0b766930400dab181b3c"></a>
template&lt;typename T , std::size_t N, typename V , std::size_t M&gt; </td></tr>
<tr class="memitem:ga69b999a4bbde0b766930400dab181b3c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classVc_1_1Vector.html">fixed_size_simd</a>&lt; T, N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>cos</b> (const <a class="el" href="classVc_1_1SimdArray.html">SimdArray</a>&lt; T, N, V, M &gt; &amp;x)</td></tr>
<tr class="memdesc:ga69b999a4bbde0b766930400dab181b3c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the std::cos function component-wise and concurrently. <br /></td></tr>
<tr class="separator:ga69b999a4bbde0b766930400dab181b3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga10fdc8103aef52c55d562c3470dc9613" id="r_ga10fdc8103aef52c55d562c3470dc9613"><td class="memTemplParams" colspan="2"><a id="ga10fdc8103aef52c55d562c3470dc9613" name="ga10fdc8103aef52c55d562c3470dc9613"></a>
template&lt;typename T , std::size_t N, typename V , std::size_t M&gt; </td></tr>
<tr class="memitem:ga10fdc8103aef52c55d562c3470dc9613"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classVc_1_1Vector.html">fixed_size_simd</a>&lt; T, N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>exp</b> (const <a class="el" href="classVc_1_1SimdArray.html">SimdArray</a>&lt; T, N, V, M &gt; &amp;x)</td></tr>
<tr class="memdesc:ga10fdc8103aef52c55d562c3470dc9613"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the std::exp function component-wise and concurrently. <br /></td></tr>
<tr class="separator:ga10fdc8103aef52c55d562c3470dc9613"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafd60ed43c87e39c56d77a6372446cb7c" id="r_gafd60ed43c87e39c56d77a6372446cb7c"><td class="memTemplParams" colspan="2"><a id="gafd60ed43c87e39c56d77a6372446cb7c" name="gafd60ed43c87e39c56d77a6372446cb7c"></a>
template&lt;typename T , std::size_t N, typename V , std::size_t M&gt; </td></tr>
<tr class="memitem:gafd60ed43c87e39c56d77a6372446cb7c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classVc_1_1Vector.html">fixed_size_simd</a>&lt; T, N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>exponent</b> (const <a class="el" href="classVc_1_1SimdArray.html">SimdArray</a>&lt; T, N, V, M &gt; &amp;x)</td></tr>
<tr class="memdesc:gafd60ed43c87e39c56d77a6372446cb7c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the std::exponent function component-wise and concurrently. <br /></td></tr>
<tr class="separator:gafd60ed43c87e39c56d77a6372446cb7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga87d15fc96c6fe5a36df45ec7a0af46a6" id="r_ga87d15fc96c6fe5a36df45ec7a0af46a6"><td class="memTemplParams" colspan="2"><a id="ga87d15fc96c6fe5a36df45ec7a0af46a6" name="ga87d15fc96c6fe5a36df45ec7a0af46a6"></a>
template&lt;typename T , std::size_t N, typename V , std::size_t M&gt; </td></tr>
<tr class="memitem:ga87d15fc96c6fe5a36df45ec7a0af46a6"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classVc_1_1Vector.html">fixed_size_simd</a>&lt; T, N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>floor</b> (const <a class="el" href="classVc_1_1SimdArray.html">SimdArray</a>&lt; T, N, V, M &gt; &amp;x)</td></tr>
<tr class="memdesc:ga87d15fc96c6fe5a36df45ec7a0af46a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the std::floor function component-wise and concurrently. <br /></td></tr>
<tr class="separator:ga87d15fc96c6fe5a36df45ec7a0af46a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga55df0d76ce69e713bb167c5f33aa4ecb" id="r_ga55df0d76ce69e713bb167c5f33aa4ecb"><td class="memTemplParams" colspan="2"><a id="ga55df0d76ce69e713bb167c5f33aa4ecb" name="ga55df0d76ce69e713bb167c5f33aa4ecb"></a>
template&lt;typename T , std::size_t N&gt; </td></tr>
<tr class="memitem:ga55df0d76ce69e713bb167c5f33aa4ecb"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classVc_1_1SimdArray.html">SimdArray</a>&lt; T, N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>fma</b> (const <a class="el" href="classVc_1_1SimdArray.html">SimdArray</a>&lt; T, N &gt; &amp;a, const <a class="el" href="classVc_1_1SimdArray.html">SimdArray</a>&lt; T, N &gt; &amp;b, const <a class="el" href="classVc_1_1SimdArray.html">SimdArray</a>&lt; T, N &gt; &amp;c)</td></tr>
<tr class="memdesc:ga55df0d76ce69e713bb167c5f33aa4ecb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the std::fma function component-wise and concurrently. <br /></td></tr>
<tr class="separator:ga55df0d76ce69e713bb167c5f33aa4ecb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadd36270b7d578c98faf6d5bb84effec5" id="r_gadd36270b7d578c98faf6d5bb84effec5"><td class="memTemplParams" colspan="2"><a id="gadd36270b7d578c98faf6d5bb84effec5" name="gadd36270b7d578c98faf6d5bb84effec5"></a>
template&lt;typename T , std::size_t N, typename V , std::size_t M&gt; </td></tr>
<tr class="memitem:gadd36270b7d578c98faf6d5bb84effec5"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classVc_1_1Mask.html">fixed_size_simd_mask</a>&lt; T, N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>isfinite</b> (const <a class="el" href="classVc_1_1SimdArray.html">SimdArray</a>&lt; T, N, V, M &gt; &amp;x)</td></tr>
<tr class="memdesc:gadd36270b7d578c98faf6d5bb84effec5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the std::isfinite function component-wise and concurrently. <br /></td></tr>
<tr class="separator:gadd36270b7d578c98faf6d5bb84effec5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3382e6db83580758f941712598d4b0bf" id="r_ga3382e6db83580758f941712598d4b0bf"><td class="memTemplParams" colspan="2"><a id="ga3382e6db83580758f941712598d4b0bf" name="ga3382e6db83580758f941712598d4b0bf"></a>
template&lt;typename T , std::size_t N, typename V , std::size_t M&gt; </td></tr>
<tr class="memitem:ga3382e6db83580758f941712598d4b0bf"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classVc_1_1Mask.html">fixed_size_simd_mask</a>&lt; T, N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>isinf</b> (const <a class="el" href="classVc_1_1SimdArray.html">SimdArray</a>&lt; T, N, V, M &gt; &amp;x)</td></tr>
<tr class="memdesc:ga3382e6db83580758f941712598d4b0bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the std::isinf function component-wise and concurrently. <br /></td></tr>
<tr class="separator:ga3382e6db83580758f941712598d4b0bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaae7b193c02d5519390426f667a53f51f" id="r_gaae7b193c02d5519390426f667a53f51f"><td class="memTemplParams" colspan="2"><a id="gaae7b193c02d5519390426f667a53f51f" name="gaae7b193c02d5519390426f667a53f51f"></a>
template&lt;typename T , std::size_t N, typename V , std::size_t M&gt; </td></tr>
<tr class="memitem:gaae7b193c02d5519390426f667a53f51f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classVc_1_1Mask.html">fixed_size_simd_mask</a>&lt; T, N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>isnan</b> (const <a class="el" href="classVc_1_1SimdArray.html">SimdArray</a>&lt; T, N, V, M &gt; &amp;x)</td></tr>
<tr class="memdesc:gaae7b193c02d5519390426f667a53f51f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the std::isnan function component-wise and concurrently. <br /></td></tr>
<tr class="separator:gaae7b193c02d5519390426f667a53f51f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga742ea12afe5302a00bd002f681788b75" id="r_ga742ea12afe5302a00bd002f681788b75"><td class="memTemplParams" colspan="2"><a id="ga742ea12afe5302a00bd002f681788b75" name="ga742ea12afe5302a00bd002f681788b75"></a>
template&lt;typename T , std::size_t N, typename V , std::size_t M&gt; </td></tr>
<tr class="memitem:ga742ea12afe5302a00bd002f681788b75"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classVc_1_1Mask.html">fixed_size_simd_mask</a>&lt; T, N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>isnegative</b> (const <a class="el" href="classVc_1_1SimdArray.html">SimdArray</a>&lt; T, N, V, M &gt; &amp;x)</td></tr>
<tr class="memdesc:ga742ea12afe5302a00bd002f681788b75"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the std::isnegative function component-wise and concurrently. <br /></td></tr>
<tr class="separator:ga742ea12afe5302a00bd002f681788b75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacf1ec0827117429126da573dc28ede39" id="r_gacf1ec0827117429126da573dc28ede39"><td class="memTemplParams" colspan="2"><a id="gacf1ec0827117429126da573dc28ede39" name="gacf1ec0827117429126da573dc28ede39"></a>
template&lt;typename T , std::size_t N&gt; </td></tr>
<tr class="memitem:gacf1ec0827117429126da573dc28ede39"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classVc_1_1SimdArray.html">SimdArray</a>&lt; T, N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>frexp</b> (const <a class="el" href="classVc_1_1SimdArray.html">SimdArray</a>&lt; T, N &gt; &amp;x, <a class="el" href="classVc_1_1SimdArray.html">SimdArray</a>&lt; int, N &gt; *e)</td></tr>
<tr class="memdesc:gacf1ec0827117429126da573dc28ede39"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the std::frexp function component-wise and concurrently. <br /></td></tr>
<tr class="separator:gacf1ec0827117429126da573dc28ede39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafd5008f63774d4d2a28b60c7094b5a9f" id="r_gafd5008f63774d4d2a28b60c7094b5a9f"><td class="memTemplParams" colspan="2"><a id="gafd5008f63774d4d2a28b60c7094b5a9f" name="gafd5008f63774d4d2a28b60c7094b5a9f"></a>
template&lt;typename T , std::size_t N&gt; </td></tr>
<tr class="memitem:gafd5008f63774d4d2a28b60c7094b5a9f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classVc_1_1SimdArray.html">SimdArray</a>&lt; T, N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ldexp</b> (const <a class="el" href="classVc_1_1SimdArray.html">SimdArray</a>&lt; T, N &gt; &amp;x, const <a class="el" href="classVc_1_1SimdArray.html">SimdArray</a>&lt; int, N &gt; &amp;e)</td></tr>
<tr class="memdesc:gafd5008f63774d4d2a28b60c7094b5a9f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the std::ldexp function component-wise and concurrently. <br /></td></tr>
<tr class="separator:gafd5008f63774d4d2a28b60c7094b5a9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga50ca5d42dc4bfd9125c82d9489785fb3" id="r_ga50ca5d42dc4bfd9125c82d9489785fb3"><td class="memTemplParams" colspan="2"><a id="ga50ca5d42dc4bfd9125c82d9489785fb3" name="ga50ca5d42dc4bfd9125c82d9489785fb3"></a>
template&lt;typename T , std::size_t N, typename V , std::size_t M&gt; </td></tr>
<tr class="memitem:ga50ca5d42dc4bfd9125c82d9489785fb3"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classVc_1_1Vector.html">fixed_size_simd</a>&lt; T, N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>log</b> (const <a class="el" href="classVc_1_1SimdArray.html">SimdArray</a>&lt; T, N, V, M &gt; &amp;x)</td></tr>
<tr class="memdesc:ga50ca5d42dc4bfd9125c82d9489785fb3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the std::log function component-wise and concurrently. <br /></td></tr>
<tr class="separator:ga50ca5d42dc4bfd9125c82d9489785fb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6a8e40c7956fd0cf5c5d5a81dc462ed6" id="r_ga6a8e40c7956fd0cf5c5d5a81dc462ed6"><td class="memTemplParams" colspan="2"><a id="ga6a8e40c7956fd0cf5c5d5a81dc462ed6" name="ga6a8e40c7956fd0cf5c5d5a81dc462ed6"></a>
template&lt;typename T , std::size_t N, typename V , std::size_t M&gt; </td></tr>
<tr class="memitem:ga6a8e40c7956fd0cf5c5d5a81dc462ed6"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classVc_1_1Vector.html">fixed_size_simd</a>&lt; T, N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>log10</b> (const <a class="el" href="classVc_1_1SimdArray.html">SimdArray</a>&lt; T, N, V, M &gt; &amp;x)</td></tr>
<tr class="memdesc:ga6a8e40c7956fd0cf5c5d5a81dc462ed6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the std::log10 function component-wise and concurrently. <br /></td></tr>
<tr class="separator:ga6a8e40c7956fd0cf5c5d5a81dc462ed6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa399f72ba9d55f3b265f87e3b5dbfccf" id="r_gaa399f72ba9d55f3b265f87e3b5dbfccf"><td class="memTemplParams" colspan="2"><a id="gaa399f72ba9d55f3b265f87e3b5dbfccf" name="gaa399f72ba9d55f3b265f87e3b5dbfccf"></a>
template&lt;typename T , std::size_t N, typename V , std::size_t M&gt; </td></tr>
<tr class="memitem:gaa399f72ba9d55f3b265f87e3b5dbfccf"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classVc_1_1Vector.html">fixed_size_simd</a>&lt; T, N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>log2</b> (const <a class="el" href="classVc_1_1SimdArray.html">SimdArray</a>&lt; T, N, V, M &gt; &amp;x)</td></tr>
<tr class="memdesc:gaa399f72ba9d55f3b265f87e3b5dbfccf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the std::log2 function component-wise and concurrently. <br /></td></tr>
<tr class="separator:gaa399f72ba9d55f3b265f87e3b5dbfccf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga36ee147be9812d939978395e96ca9653" id="r_ga36ee147be9812d939978395e96ca9653"><td class="memTemplParams" colspan="2"><a id="ga36ee147be9812d939978395e96ca9653" name="ga36ee147be9812d939978395e96ca9653"></a>
template&lt;typename T , std::size_t N, typename V , std::size_t M&gt; </td></tr>
<tr class="memitem:ga36ee147be9812d939978395e96ca9653"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classVc_1_1Vector.html">fixed_size_simd</a>&lt; T, N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>reciprocal</b> (const <a class="el" href="classVc_1_1SimdArray.html">SimdArray</a>&lt; T, N, V, M &gt; &amp;x)</td></tr>
<tr class="memdesc:ga36ee147be9812d939978395e96ca9653"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the std::reciprocal function component-wise and concurrently. <br /></td></tr>
<tr class="separator:ga36ee147be9812d939978395e96ca9653"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae2d0e4660b71feddde552a2974db3896" id="r_gae2d0e4660b71feddde552a2974db3896"><td class="memTemplParams" colspan="2"><a id="gae2d0e4660b71feddde552a2974db3896" name="gae2d0e4660b71feddde552a2974db3896"></a>
template&lt;typename T , std::size_t N, typename V , std::size_t M&gt; </td></tr>
<tr class="memitem:gae2d0e4660b71feddde552a2974db3896"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classVc_1_1Vector.html">fixed_size_simd</a>&lt; T, N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>round</b> (const <a class="el" href="classVc_1_1SimdArray.html">SimdArray</a>&lt; T, N, V, M &gt; &amp;x)</td></tr>
<tr class="memdesc:gae2d0e4660b71feddde552a2974db3896"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the std::round function component-wise and concurrently. <br /></td></tr>
<tr class="separator:gae2d0e4660b71feddde552a2974db3896"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaea57cafc480c6afed73429b1c0f7d8f9" id="r_gaea57cafc480c6afed73429b1c0f7d8f9"><td class="memTemplParams" colspan="2"><a id="gaea57cafc480c6afed73429b1c0f7d8f9" name="gaea57cafc480c6afed73429b1c0f7d8f9"></a>
template&lt;typename T , std::size_t N, typename V , std::size_t M&gt; </td></tr>
<tr class="memitem:gaea57cafc480c6afed73429b1c0f7d8f9"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classVc_1_1Vector.html">fixed_size_simd</a>&lt; T, N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>rsqrt</b> (const <a class="el" href="classVc_1_1SimdArray.html">SimdArray</a>&lt; T, N, V, M &gt; &amp;x)</td></tr>
<tr class="memdesc:gaea57cafc480c6afed73429b1c0f7d8f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the std::rsqrt function component-wise and concurrently. <br /></td></tr>
<tr class="separator:gaea57cafc480c6afed73429b1c0f7d8f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga47ded4a72c2f1452d789c528e7b094dc" id="r_ga47ded4a72c2f1452d789c528e7b094dc"><td class="memTemplParams" colspan="2"><a id="ga47ded4a72c2f1452d789c528e7b094dc" name="ga47ded4a72c2f1452d789c528e7b094dc"></a>
template&lt;typename T , std::size_t N, typename V , std::size_t M&gt; </td></tr>
<tr class="memitem:ga47ded4a72c2f1452d789c528e7b094dc"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classVc_1_1Vector.html">fixed_size_simd</a>&lt; T, N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>sin</b> (const <a class="el" href="classVc_1_1SimdArray.html">SimdArray</a>&lt; T, N, V, M &gt; &amp;x)</td></tr>
<tr class="memdesc:ga47ded4a72c2f1452d789c528e7b094dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the std::sin function component-wise and concurrently. <br /></td></tr>
<tr class="separator:ga47ded4a72c2f1452d789c528e7b094dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga966c8787de0b75905d6a0bcac439cd38" id="r_ga966c8787de0b75905d6a0bcac439cd38"><td class="memTemplParams" colspan="2"><a id="ga966c8787de0b75905d6a0bcac439cd38" name="ga966c8787de0b75905d6a0bcac439cd38"></a>
template&lt;typename T , std::size_t N&gt; </td></tr>
<tr class="memitem:ga966c8787de0b75905d6a0bcac439cd38"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>sincos</b> (const <a class="el" href="classVc_1_1SimdArray.html">SimdArray</a>&lt; T, N &gt; &amp;x, <a class="el" href="classVc_1_1SimdArray.html">SimdArray</a>&lt; T, N &gt; *<a class="el" href="#ga47ded4a72c2f1452d789c528e7b094dc">sin</a>, <a class="el" href="classVc_1_1SimdArray.html">SimdArray</a>&lt; T, N &gt; *<a class="el" href="#ga69b999a4bbde0b766930400dab181b3c">cos</a>)</td></tr>
<tr class="memdesc:ga966c8787de0b75905d6a0bcac439cd38"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines sine and cosine concurrently and component-wise on <code>x</code>. <br /></td></tr>
<tr class="separator:ga966c8787de0b75905d6a0bcac439cd38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7a6c5f5edc8022f95100272604ca7674" id="r_ga7a6c5f5edc8022f95100272604ca7674"><td class="memTemplParams" colspan="2"><a id="ga7a6c5f5edc8022f95100272604ca7674" name="ga7a6c5f5edc8022f95100272604ca7674"></a>
template&lt;typename T , std::size_t N, typename V , std::size_t M&gt; </td></tr>
<tr class="memitem:ga7a6c5f5edc8022f95100272604ca7674"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classVc_1_1Vector.html">fixed_size_simd</a>&lt; T, N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>sqrt</b> (const <a class="el" href="classVc_1_1SimdArray.html">SimdArray</a>&lt; T, N, V, M &gt; &amp;x)</td></tr>
<tr class="memdesc:ga7a6c5f5edc8022f95100272604ca7674"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the std::sqrt function component-wise and concurrently. <br /></td></tr>
<tr class="separator:ga7a6c5f5edc8022f95100272604ca7674"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga12d14666e1baee24304e4770f0276b14" id="r_ga12d14666e1baee24304e4770f0276b14"><td class="memTemplParams" colspan="2"><a id="ga12d14666e1baee24304e4770f0276b14" name="ga12d14666e1baee24304e4770f0276b14"></a>
template&lt;typename T , std::size_t N, typename V , std::size_t M&gt; </td></tr>
<tr class="memitem:ga12d14666e1baee24304e4770f0276b14"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classVc_1_1Vector.html">fixed_size_simd</a>&lt; T, N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>trunc</b> (const <a class="el" href="classVc_1_1SimdArray.html">SimdArray</a>&lt; T, N, V, M &gt; &amp;x)</td></tr>
<tr class="memdesc:ga12d14666e1baee24304e4770f0276b14"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the std::trunc function component-wise and concurrently. <br /></td></tr>
<tr class="separator:ga12d14666e1baee24304e4770f0276b14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2aab75e4afa35c3331deb8639e2b0000" id="r_ga2aab75e4afa35c3331deb8639e2b0000"><td class="memTemplParams" colspan="2"><a id="ga2aab75e4afa35c3331deb8639e2b0000" name="ga2aab75e4afa35c3331deb8639e2b0000"></a>
template&lt;typename T , std::size_t N, typename V , std::size_t M&gt; </td></tr>
<tr class="memitem:ga2aab75e4afa35c3331deb8639e2b0000"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classVc_1_1Vector.html">fixed_size_simd</a>&lt; T, N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>min</b> (const <a class="el" href="classVc_1_1SimdArray.html">SimdArray</a>&lt; T, N, V, M &gt; &amp;x, const <a class="el" href="classVc_1_1SimdArray.html">SimdArray</a>&lt; T, N, V, M &gt; &amp;y)</td></tr>
<tr class="memdesc:ga2aab75e4afa35c3331deb8639e2b0000"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the std::min function component-wise and concurrently. <br /></td></tr>
<tr class="separator:ga2aab75e4afa35c3331deb8639e2b0000"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga253756bfaa995b548006eca952694c3a" id="r_ga253756bfaa995b548006eca952694c3a"><td class="memTemplParams" colspan="2"><a id="ga253756bfaa995b548006eca952694c3a" name="ga253756bfaa995b548006eca952694c3a"></a>
template&lt;typename T , std::size_t N, typename V , std::size_t M&gt; </td></tr>
<tr class="memitem:ga253756bfaa995b548006eca952694c3a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classVc_1_1Vector.html">fixed_size_simd</a>&lt; T, N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>max</b> (const <a class="el" href="classVc_1_1SimdArray.html">SimdArray</a>&lt; T, N, V, M &gt; &amp;x, const <a class="el" href="classVc_1_1SimdArray.html">SimdArray</a>&lt; T, N, V, M &gt; &amp;y)</td></tr>
<tr class="memdesc:ga253756bfaa995b548006eca952694c3a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the std::max function component-wise and concurrently. <br /></td></tr>
<tr class="separator:ga253756bfaa995b548006eca952694c3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Deprecated Members</h2></td></tr>
<tr class="memitem:gaebad73a8e5f857946cc78fbeb83251eb" id="r_gaebad73a8e5f857946cc78fbeb83251eb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classVc_1_1Vector.html">fixed_size_simd</a>&lt; T, N &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gaebad73a8e5f857946cc78fbeb83251eb">exponent</a> () const</td></tr>
<tr class="memdesc:gaebad73a8e5f857946cc78fbeb83251eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the exponents of the floating-point values in the vector.     <br /></td></tr>
<tr class="separator:gaebad73a8e5f857946cc78fbeb83251eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga00a3bc44083d6e538e07480fd62e8706" id="r_ga00a3bc44083d6e538e07480fd62e8706"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classVc_1_1SimdArray.html#a2fd4547d07b041a214d9e5002ef0e7c2">MaskType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga00a3bc44083d6e538e07480fd62e8706">isNegative</a> () const</td></tr>
<tr class="memdesc:ga00a3bc44083d6e538e07480fd62e8706"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether a value is negative.     <br /></td></tr>
<tr class="separator:ga00a3bc44083d6e538e07480fd62e8706"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga281617828f1ac9ef5b25eeddf2e881ec" id="r_ga281617828f1ac9ef5b25eeddf2e881ec"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classVc_1_1Vector.html">fixed_size_simd</a>&lt; T, N &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga281617828f1ac9ef5b25eeddf2e881ec">copySign</a> (const <a class="el" href="classVc_1_1SimdArray.html">SimdArray</a> &amp;x) const</td></tr>
<tr class="memdesc:ga281617828f1ac9ef5b25eeddf2e881ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies the signs of the components of <code>reference</code> to the components of the current vector, returning the result.     <br /></td></tr>
<tr class="separator:ga281617828f1ac9ef5b25eeddf2e881ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad550c4cd366024e9b37c4a7c7c9b96ff" id="r_gad550c4cd366024e9b37c4a7c7c9b96ff"><td class="memItemLeft" align="right" valign="top">static constexpr std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gad550c4cd366024e9b37c4a7c7c9b96ff">Size</a> = <a class="el" href="classVc_1_1SimdArray.html#a5e99fb015bfbc024a4b785135b34dee7">size</a>()</td></tr>
<tr class="memdesc:gad550c4cd366024e9b37c4a7c7c9b96ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>N</code>, the number of scalar components in an object of this type.     <br /></td></tr>
<tr class="separator:gad550c4cd366024e9b37c4a7c7c9b96ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Function Documentation</h2>
<a id="gaebad73a8e5f857946cc78fbeb83251eb" name="gaebad73a8e5f857946cc78fbeb83251eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaebad73a8e5f857946cc78fbeb83251eb">&#9670;&#160;</a></span>exponent()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , size_t N, typename V , size_t Wt&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVc_1_1Vector.html">fixed_size_simd</a>&lt; T, N &gt; exponent </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the exponents of the floating-point values in the vector.    </p>
<dl class="section return"><dt>Returns</dt><dd>A new vector object of the same type containing the exponents.</dd></dl>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000022">Deprecated</a></b></dt><dd>use <a class="el" href="#gafd60ed43c87e39c56d77a6372446cb7c" title="Applies the std::exponent function component-wise and concurrently.">Vc::exponent</a> instead. </dd></dl>

<p class="definition">Definition at line <a class="el" href="simdarray_8h_source.html#l01432">1432</a> of file <a class="el" href="simdarray_8h_source.html">simdarray.h</a>.</p>

</div>
</div>
<a id="ga00a3bc44083d6e538e07480fd62e8706" name="ga00a3bc44083d6e538e07480fd62e8706"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga00a3bc44083d6e538e07480fd62e8706">&#9670;&#160;</a></span>isNegative()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , size_t N, typename V , size_t Wt&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVc_1_1SimdArray.html#a2fd4547d07b041a214d9e5002ef0e7c2">MaskType</a> isNegative </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns whether a value is negative.    </p>
<dl class="section return"><dt>Returns</dt><dd>A new mask object indicating the sign of each vector element.</dd></dl>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000023">Deprecated</a></b></dt><dd>use <a class="el" href="#ga742ea12afe5302a00bd002f681788b75" title="Applies the std::isnegative function component-wise and concurrently.">Vc::isnegative</a> instead. </dd></dl>

<p class="definition">Definition at line <a class="el" href="simdarray_8h_source.html#l01438">1438</a> of file <a class="el" href="simdarray_8h_source.html">simdarray.h</a>.</p>

</div>
</div>
<a id="ga281617828f1ac9ef5b25eeddf2e881ec" name="ga281617828f1ac9ef5b25eeddf2e881ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga281617828f1ac9ef5b25eeddf2e881ec">&#9670;&#160;</a></span>copySign()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , size_t N, typename V , size_t Wt&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVc_1_1Vector.html">fixed_size_simd</a>&lt; T, N &gt; copySign </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classVc_1_1SimdArray.html">SimdArray</a>&lt; T, N, V, Wt &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>x</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies the signs of the components of <code>reference</code> to the components of the current vector, returning the result.    </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">reference</td><td>A vector object that determines the sign of the the result. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A new vector with sign taken from <code>reference</code> and absolute value taken from the current vector object.</dd></dl>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000027">Deprecated</a></b></dt><dd>Use <a class="el" href="#ga62b791fecb11fa3190ebbee40ed5e4d4" title="Applies the std::copysign function component-wise and concurrently.">Vc::copysign</a> instead. </dd></dl>

<p class="definition">Definition at line <a class="el" href="simdarray_8h_source.html#l01445">1445</a> of file <a class="el" href="simdarray_8h_source.html">simdarray.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="gad550c4cd366024e9b37c4a7c7c9b96ff" name="gad550c4cd366024e9b37c4a7c7c9b96ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad550c4cd366024e9b37c4a7c7c9b96ff">&#9670;&#160;</a></span>Size <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , std::size_t N, typename V , std::size_t M&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t Size = <a class="el" href="classVc_1_1SimdArray.html#a5e99fb015bfbc024a4b785135b34dee7">size</a>()</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns <code>N</code>, the number of scalar components in an object of this type.    </p>
<p>The size of the <a class="el" href="classVc_1_1SimdArray.html" title="Data-parallel arithmetic type with user-defined number of elements.">SimdArray</a>, i.e. the number of scalar elements in the vector. In contrast to <a class="el" href="classVc_1_1Vector.html#a1b5d7e2e663d7997796fd9f72b8af75a" title="Returns the number of scalar components (  ) in a vector of this type.">Vector::size()</a> you have control over this value via the <code>N</code> template parameter of the <a class="el" href="classVc_1_1SimdArray.html" title="Data-parallel arithmetic type with user-defined number of elements.">SimdArray</a> class template.</p>
<dl class="section return"><dt>Returns</dt><dd>The number of scalar values stored and manipulated concurrently by objects of this type.    </dd></dl>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000021">Deprecated</a></b></dt><dd>Use <a class="el" href="classVc_1_1SimdArray.html#a5e99fb015bfbc024a4b785135b34dee7" title="Returns N, the number of scalar components in an object of this type.">size()</a> instead. </dd></dl>

<p class="definition">Definition at line <a class="el" href="simdarray_8h_source.html#l01428">1428</a> of file <a class="el" href="simdarray_8h_source.html">simdarray.h</a>.</p>

</div>
</div>
<a id="gaac286912729d28478c8c9a1ac97a92ac" name="gaac286912729d28478c8c9a1ac97a92ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaac286912729d28478c8c9a1ac97a92ac">&#9670;&#160;</a></span>MemoryAlignment <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , std::size_t N, typename V , std::size_t M&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t MemoryAlignment</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div>
<div class="line">        storage_type0::MemoryAlignment &gt; storage_type1::MemoryAlignment</div>
<div class="line">            ? storage_type0::MemoryAlignment</div>
<div class="line">            : storage_type1::MemoryAlignment</div>
</div><!-- fragment -->
<p>Specifies the alignment requirement for aligned load and store calls for objects of this vector type.    </p>

<p class="definition">Definition at line <a class="el" href="simdarray_8h_source.html#l00692">692</a> of file <a class="el" href="simdarray_8h_source.html">simdarray.h</a>.</p>

</div>
</div>
<a id="gad550c4cd366024e9b37c4a7c7c9b96ff" name="gad550c4cd366024e9b37c4a7c7c9b96ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad550c4cd366024e9b37c4a7c7c9b96ff">&#9670;&#160;</a></span>Size <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , std::size_t N, typename V , std::size_t M&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t Size = <a class="el" href="classVc_1_1SimdMaskArray.html#a5e99fb015bfbc024a4b785135b34dee7">size</a>()</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of boolean components ( \(\mathcal{W}_\mathtt{T}\) ) in a mask of this type.          </p>
<p>The size of the mask. I.e. the number of boolean entries in the mask. Do not make any assumptions about the size of masks.</p>
<p>In addition, you can easily use if clauses that compare sizes. The compiler can statically evaluate and fully optimize dead code away (very much like #ifdef, but with syntax checking).</p>
<dl class="section return"><dt>Returns</dt><dd>The number of components (i.e. \(\mathcal{W}_\mathtt{T}\) ) objects of this mask type store and manipulate.       </dd></dl>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000014">Deprecated</a></b></dt><dd>Use <a class="el" href="classVc_1_1Mask.html#a1b5d7e2e663d7997796fd9f72b8af75a" title="Returns the number of boolean components (  ) in a mask of this type.">Vc::Mask::size</a> instead. </dd></dl>

<p class="definition">Definition at line <a class="el" href="simdmaskarray_8h_source.html#l00346">346</a> of file <a class="el" href="simdmaskarray_8h_source.html">simdmaskarray.h</a>.</p>

</div>
</div>
<a id="gaac286912729d28478c8c9a1ac97a92ac" name="gaac286912729d28478c8c9a1ac97a92ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaac286912729d28478c8c9a1ac97a92ac">&#9670;&#160;</a></span>MemoryAlignment <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , std::size_t N, typename V , std::size_t M&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t MemoryAlignment</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div>
<div class="line">        <a class="code hl_variable" href="classVc_1_1Mask.html#a9d80568e435be601eb87ade3966eda21">storage_type0::MemoryAlignment</a> &gt; <a class="code hl_variable" href="classVc_1_1Mask.html#a9d80568e435be601eb87ade3966eda21">storage_type1::MemoryAlignment</a></div>
<div class="line">            ? <a class="code hl_variable" href="classVc_1_1Mask.html#a9d80568e435be601eb87ade3966eda21">storage_type0::MemoryAlignment</a></div>
<div class="line">            : <a class="code hl_variable" href="classVc_1_1Mask.html#a9d80568e435be601eb87ade3966eda21">storage_type1::MemoryAlignment</a></div>
<div class="ttc" id="aclassVc_1_1Mask_html_a9d80568e435be601eb87ade3966eda21"><div class="ttname"><a href="classVc_1_1Mask.html#a9d80568e435be601eb87ade3966eda21">Vc::Mask::MemoryAlignment</a></div><div class="ttdeci">static constexpr size_t MemoryAlignment</div><div class="ttdoc">Specifies the alignment requirement for aligned load and store calls for objects of this mask type.</div><div class="ttdef"><b>Definition</b> <a href="mask_8h_source.html#l00066">mask.h:66</a></div></div>
</div><!-- fragment -->
<p>Specifies the alignment requirement for aligned load and store calls for objects of this mask type.    </p>

<p class="definition">Definition at line <a class="el" href="simdmaskarray_8h_source.html#l00348">348</a> of file <a class="el" href="simdmaskarray_8h_source.html">simdmaskarray.h</a>.</p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.11.0 </li>
  </ul>
</div>
</body>
</html>
