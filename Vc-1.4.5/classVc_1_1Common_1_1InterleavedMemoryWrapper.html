<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.11.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Vc: InterleavedMemoryWrapper&lt; S, V &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
  $(function() { init_search(); });
/* @license-end */
</script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="logo_small.png"/></td>
  <td id="projectalign">
   <div id="projectname">Vc<span id="projectnumber">&#160;1.4.5</span>
   </div>
   <div id="projectbrief">SIMD Vector Classes for C++</div>
  </td>
    <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <span id="MSearchSelect"                onmouseover="return searchBox.OnSearchSelectShow()"                onmouseout="return searchBox.OnSearchSelectHide()">&#160;</span>
          <input type="text" id="MSearchField" value="" placeholder="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.11.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('classVc_1_1Common_1_1InterleavedMemoryWrapper.html',''); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classVc_1_1Common_1_1InterleavedMemoryWrapper-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">InterleavedMemoryWrapper&lt; S, V &gt; Class Template Reference<div class="ingroups"><a class="el" href="group__Containers.html">Containers</a></div></div></div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;typename S, typename V&gt;<br />
class Vc::Common::InterleavedMemoryWrapper&lt; S, V &gt;</div><p>Wraps a pointer to memory with convenience functions to access it via vectors. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">S</td><td>The type of the struct. </td></tr>
    <tr><td class="paramname">V</td><td>The type of the vector to be returned when read. This should reflect the type of the members inside the struct.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd>operator[] </dd></dl>

<p class="definition">Definition at line <a class="el" href="interleavedmemory_8h_source.html#l00177">177</a> of file <a class="el" href="interleavedmemory_8h_source.html">interleavedmemory.h</a>.</p>
</div>
<p><code>#include &lt;<a class="el" href="interleavedmemory_8h_source.html">Vc/Memory</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:af580870bdff6bbb416396d37a59449bd" id="r_af580870bdff6bbb416396d37a59449bd"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af580870bdff6bbb416396d37a59449bd">InterleavedMemoryWrapper</a> (S *s)</td></tr>
<tr class="memdesc:af580870bdff6bbb416396d37a59449bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs the wrapper object.  <br /></td></tr>
<tr class="separator:af580870bdff6bbb416396d37a59449bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf553556da31408fc12e4188626f3780" id="r_acf553556da31408fc12e4188626f3780"><td class="memTemplParams" colspan="2">template&lt;typename IT &gt; </td></tr>
<tr class="memitem:acf553556da31408fc12e4188626f3780"><td class="memTemplItemLeft" align="right" valign="top">enable_if&lt;!std::is_convertible&lt; IT, size_t &gt;::value &amp;&amp;std::is_convertible&lt; IT, IndexType &gt;::value &amp;&amp;!std::is_const&lt; S &gt;::value, Access &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#acf553556da31408fc12e4188626f3780">operator[]</a> (IT indexes)</td></tr>
<tr class="separator:acf553556da31408fc12e4188626f3780"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a729968312197c4190842952835d8b1c2" id="r_a729968312197c4190842952835d8b1c2"><td class="memItemLeft" align="right" valign="top"><a id="a729968312197c4190842952835d8b1c2" name="a729968312197c4190842952835d8b1c2"></a>
ReadAccess&#160;</td><td class="memItemRight" valign="bottom"><b>operator[]</b> (IndexType indexes) const</td></tr>
<tr class="memdesc:a729968312197c4190842952835d8b1c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">const overload (gathers only) of the above function <br /></td></tr>
<tr class="separator:a729968312197c4190842952835d8b1c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d46116bd002d30ec56fcca9eacd39fa" id="r_a3d46116bd002d30ec56fcca9eacd39fa"><td class="memItemLeft" align="right" valign="top"><a id="a3d46116bd002d30ec56fcca9eacd39fa" name="a3d46116bd002d30ec56fcca9eacd39fa"></a>
ReadAccess&#160;</td><td class="memItemRight" valign="bottom"><b>gather</b> (IndexType indexes) const</td></tr>
<tr class="memdesc:a3d46116bd002d30ec56fcca9eacd39fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">alias of the above function <br /></td></tr>
<tr class="separator:a3d46116bd002d30ec56fcca9eacd39fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ca9842299fc31cc66db06cd1964591b" id="r_a5ca9842299fc31cc66db06cd1964591b"><td class="memItemLeft" align="right" valign="top">ReadSuccessiveEntries&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5ca9842299fc31cc66db06cd1964591b">operator[]</a> (size_t first) const</td></tr>
<tr class="memdesc:a5ca9842299fc31cc66db06cd1964591b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interleaved access.  <br /></td></tr>
<tr class="separator:a5ca9842299fc31cc66db06cd1964591b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="af580870bdff6bbb416396d37a59449bd" name="af580870bdff6bbb416396d37a59449bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af580870bdff6bbb416396d37a59449bd">&#9670;&#160;</a></span>InterleavedMemoryWrapper()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename S , typename V &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVc_1_1Common_1_1InterleavedMemoryWrapper.html">InterleavedMemoryWrapper</a> </td>
          <td>(</td>
          <td class="paramtype">S *</td>          <td class="paramname"><span class="paramname"><em>s</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs the wrapper object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>A pointer to a C-array. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="interleavedmemory_8h_source.html#l00207">207</a> of file <a class="el" href="interleavedmemory_8h_source.html">interleavedmemory.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="acf553556da31408fc12e4188626f3780" name="acf553556da31408fc12e4188626f3780"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf553556da31408fc12e4188626f3780">&#9670;&#160;</a></span>operator[]() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename S , typename V &gt; </div>
<div class="memtemplate">
template&lt;typename IT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enable_if&lt;!std::is_convertible&lt; IT, size_t &gt;::value &amp;&amp; std::is_convertible&lt; IT, IndexType &gt;::value &amp;&amp; !std::is_const&lt; S &gt;::value, Access &gt; operator[] </td>
          <td>(</td>
          <td class="paramtype">IT</td>          <td class="paramname"><span class="paramname"><em>indexes</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">   Interleaved scatter/gather access.

   Assuming you have a struct of floats and a vector of \p indexes into the array, this function
   can be used to access the struct entries as vectors using the minimal number of store or load
   instructions.

   \param indexes Vector of indexes that determine the gather locations.

   \return A special (magic) object that executes the loads and deinterleave on assignment to a
   vector tuple.

   Example:
   \code
   struct Foo {
     float x, y, z;
   };

   void fillWithBar(Foo *_data, uint_v indexes)
   {
     Vc::InterleavedMemoryWrapper&lt;Foo, float_v&gt; data(_data);
     const float_v x = bar(1);
     const float_v y = bar(2);
     const float_v z = bar(3);
     data[indexes] = (x, y, z);
     // it's also possible to just store a subset at the front of the struct:
     data[indexes] = (x, y);
     // if you want to store a single entry, use scatter:
     z.scatter(_data, &amp;Foo::x, indexes);
   }

   float_v normalizeStuff(Foo *_data, uint_v indexes)
   {
     Vc::InterleavedMemoryWrapper&lt;Foo, float_v&gt; data(_data);
     float_v x, y, z;
     (x, y, z) = data[indexes];
     // it is also possible to just load a subset from the front of the struct:
     // (x, y) = data[indexes];
     return Vc::sqrt(x * x + y * y + z * z);
   }
   \endcode

   You may think of the gather operation (or scatter as the inverse) like this:
</pre> <pre class="fragment">             Memory: {x0 y0 z0 x1 y1 z1 x2 y2 z2 x3 y3 z3 x4 y4 z4 x5 y5 z5 x6 y6 z6 x7 y7 z7 x8 y8 z8}
            indexes: [5, 0, 1, 7]
Result in (x, y, z): ({x5 x0 x1 x7}, {y5 y0 y1 y7}, {z5 z0 z1 z7})
</pre> <pre class="fragment">   \warning If \p indexes contains non-unique entries on scatter, the result is undefined. If
   \c NDEBUG is not defined the implementation will assert that the \p indexes entries are unique.
</pre> 
<p class="definition">Definition at line <a class="el" href="interleavedmemory_8h_source.html#l00269">269</a> of file <a class="el" href="interleavedmemory_8h_source.html">interleavedmemory.h</a>.</p>

</div>
</div>
<a id="a5ca9842299fc31cc66db06cd1964591b" name="a5ca9842299fc31cc66db06cd1964591b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ca9842299fc31cc66db06cd1964591b">&#9670;&#160;</a></span>operator[]() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename S , typename V &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ReadSuccessiveEntries operator[] </td>
          <td>(</td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>first</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Interleaved access. </p>
<p>This function is an optimization of the function above, for cases where the index vector contains consecutive values. It will load <code>V::Size</code> consecutive entries from memory and deinterleave them into <a class="el" href="namespaceVc.html" title="Vector Classes Namespace.">Vc</a> vectors.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>The first of <code>V::Size</code> indizes to be accessed.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A special (magic) object that executes the loads and deinterleave on assignment to a vector tuple.</dd></dl>
<p>Example: </p><div class="fragment"><div class="line"><span class="keyword">struct </span>Foo {</div>
<div class="line">  <span class="keywordtype">float</span> x, y, z;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> foo(Foo *_data)</div>
<div class="line">{</div>
<div class="line">  <a class="code hl_class" href="classVc_1_1Common_1_1InterleavedMemoryWrapper.html">Vc::InterleavedMemoryWrapper&lt;Foo, float_v&gt;</a> data(_data);</div>
<div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; 32U; i += <a class="code hl_variable" href="classVc_1_1Vector.html#a879ad9933a419e4e04c8a59cc19a34fe">float_v::Size</a>) {</div>
<div class="line">    <a class="code hl_class" href="classVc_1_1Vector.html">float_v</a> x, y, z;</div>
<div class="line">    (x, y, z) = data[i];</div>
<div class="line">    <span class="comment">// now:</span></div>
<div class="line">    <span class="comment">// x = { _data[i].x, _data[i + 1].x, _data[i + 2].x, ... }</span></div>
<div class="line">    <span class="comment">// y = { _data[i].y, _data[i + 1].y, _data[i + 2].y, ... }</span></div>
<div class="line">    <span class="comment">// z = { _data[i].z, _data[i + 1].z, _data[i + 2].z, ... }</span></div>
<div class="line">    ...</div>
<div class="line">  }</div>
<div class="line">}</div>
<div class="ttc" id="aclassVc_1_1Common_1_1InterleavedMemoryWrapper_html"><div class="ttname"><a href="classVc_1_1Common_1_1InterleavedMemoryWrapper.html">Vc::Common::InterleavedMemoryWrapper</a></div><div class="ttdoc">Wraps a pointer to memory with convenience functions to access it via vectors.</div><div class="ttdef"><b>Definition</b> <a href="interleavedmemory_8h_source.html#l00177">interleavedmemory.h:178</a></div></div>
<div class="ttc" id="aclassVc_1_1Vector_html"><div class="ttname"><a href="classVc_1_1Vector.html">Vc::Vector</a></div><div class="ttdoc">The main vector class for expressing data parallelism.</div><div class="ttdef"><b>Definition</b> <a href="common_2vector_8h_source.html#l00125">vector.h:126</a></div></div>
<div class="ttc" id="aclassVc_1_1Vector_html_a879ad9933a419e4e04c8a59cc19a34fe"><div class="ttname"><a href="classVc_1_1Vector.html#a879ad9933a419e4e04c8a59cc19a34fe">Vc::Vector::Size</a></div><div class="ttdeci">static constexpr size_t Size</div><div class="ttdoc">Returns the number of scalar components (  ) in a vector of this type.</div><div class="ttdef"><b>Definition</b> <a href="common_2vector_8h_source.html#l00772">vector.h:772</a></div></div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="interleavedmemory_8h_source.html#l00316">316</a> of file <a class="el" href="interleavedmemory_8h_source.html">interleavedmemory.h</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>/home/axel/build/Vc/Vc/Vc/common/<a class="el" href="interleavedmemory_8h_source.html">interleavedmemory.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespaceVc.html">Vc</a></li><li class="navelem"><b>Common</b></li><li class="navelem"><a class="el" href="classVc_1_1Common_1_1InterleavedMemoryWrapper.html">InterleavedMemoryWrapper</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.11.0 </li>
  </ul>
</div>
</body>
</html>
