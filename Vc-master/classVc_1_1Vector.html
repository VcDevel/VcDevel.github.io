<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.10"/>
<title>Vc: Vector&lt; T, Abi &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() {
    if ($('.searchresults').length > 0) { searchBox.DOMSearchField().focus(); }
  });
</script>
<link rel="search" href="search_opensearch.php?v=opensearch.xml" type="application/opensearchdescription+xml" title="Vc"/>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo_small.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Vc
   &#160;<span id="projectnumber">1.3.2-dev</span>
   </div>
   <div id="projectbrief">SIMD Vector Classes for C++</div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
          <div class="left">
            <form id="FSearchBox" action="search.php" method="get">
              <img id="MSearchSelect" src="search/mag.png" alt=""/>
              <input type="text" id="MSearchField" name="query" value="Search" size="20" accesskey="S" 
                     onfocus="searchBox.OnSearchFieldFocus(true)" 
                     onblur="searchBox.OnSearchFieldFocus(false)"/>
            </form>
          </div><div class="right"></div>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.10 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('classVc_1_1Vector.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="classVc_1_1Vector-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">Vector&lt; T, Abi &gt; Class Template Reference<div class="ingroups"><a class="el" href="group__Vectors.html">Vectors</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename T, typename Abi = VectorAbi::Best&lt;T&gt;&gt;<br />
class Vc::Vector&lt; T, Abi &gt;</h3>

<p>The main vector class for expressing data parallelism. </p>
<p>are specializations of this class. For most cases there are no API differences for the specializations. Make use of Vector&lt;T&gt; for generic programming, otherwise you might prefer to use the <code>*_v</code> aliases.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__Vectors.html#ga5cf7c5a0dadbbbbcb9b69c5e42ee0528" title="vector of single precision ">Vc::float_v</a>, <a class="el" href="group__Vectors.html#ga0c29c10a0054260ee326ff12938243fa" title="vector of double precision ">Vc::double_v</a>, <a class="el" href="group__Vectors.html#gaff6f527c244d2e97ae290d2325de8ec0" title="vector of signed integers ">Vc::int_v</a>, <a class="el" href="group__Vectors.html#gab04f66a2e5672fe27f27e9fbff5afcbc" title="vector of unsigned integers ">Vc::uint_v</a>, <a class="el" href="group__Vectors.html#ga357ea2ba8644fc80c7e7cf13069e6ed0" title="vector of signed short integers ">Vc::short_v</a>, <a class="el" href="group__Vectors.html#ga06b026f838dc9e1a7b8d76a89a852503" title="vector of unsigned short integers ">Vc::ushort_v</a> </dd>
<dd>
<a class="el" href="classVc_1_1Mask.html" title="The main SIMD mask class. ">Mask</a> </dd></dl>

<p>Definition at line <a class="el" href="types_8h_source.html#l00044">44</a> of file <a class="el" href="types_8h_source.html">types.h</a>.</p>
</div>
<p><code>#include &lt;<a class="el" href="types_8h_source.html">Vc/vector.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:abe9aa1f35fa46be781ae9e81d374a72b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abe9aa1f35fa46be781ae9e81d374a72b"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVc_1_1Vector.html#abe9aa1f35fa46be781ae9e81d374a72b">abi</a> = Abi</td></tr>
<tr class="memdesc:abe9aa1f35fa46be781ae9e81d374a72b"><td class="mdescLeft">&#160;</td><td class="mdescRight">The ABI tag type of the current template instantiation. <br /></td></tr>
<tr class="separator:abe9aa1f35fa46be781ae9e81d374a72b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9cb6038cbd15cb0bdc596f5383c2b21"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae9cb6038cbd15cb0bdc596f5383c2b21"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVc_1_1Vector.html#ae9cb6038cbd15cb0bdc596f5383c2b21">EntryType</a> = typename VectorTraits&lt; T, Abi &gt;::<a class="el" href="classVc_1_1Vector.html#ae9cb6038cbd15cb0bdc596f5383c2b21">EntryType</a></td></tr>
<tr class="memdesc:ae9cb6038cbd15cb0bdc596f5383c2b21"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type of the entries in the vector. <br /></td></tr>
<tr class="separator:ae9cb6038cbd15cb0bdc596f5383c2b21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af58a233cf0cdf62369686dd5798bd589"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVc_1_1Vector.html#af58a233cf0cdf62369686dd5798bd589">value_type</a> = <a class="el" href="classVc_1_1Vector.html#ae9cb6038cbd15cb0bdc596f5383c2b21">EntryType</a></td></tr>
<tr class="memdesc:af58a233cf0cdf62369686dd5798bd589"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type of the entries in the vector.  <a href="#af58a233cf0cdf62369686dd5798bd589">More...</a><br /></td></tr>
<tr class="separator:af58a233cf0cdf62369686dd5798bd589"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87ee111bfca7f15829e802bdf47c3b0e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a87ee111bfca7f15829e802bdf47c3b0e"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVc_1_1Vector.html#a87ee111bfca7f15829e802bdf47c3b0e">MaskType</a> = <a class="el" href="classVc_1_1Mask.html">Vc::Mask</a>&lt; T, Abi &gt;</td></tr>
<tr class="memdesc:a87ee111bfca7f15829e802bdf47c3b0e"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type of the mask used for masked operations and returned from comparisons. <br /></td></tr>
<tr class="separator:a87ee111bfca7f15829e802bdf47c3b0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abffe464ff20f5933e5a50b699555fa5f"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVc_1_1Vector.html#abffe464ff20f5933e5a50b699555fa5f">mask_type</a> = <a class="el" href="classVc_1_1Vector.html#a87ee111bfca7f15829e802bdf47c3b0e">MaskType</a></td></tr>
<tr class="memdesc:abffe464ff20f5933e5a50b699555fa5f"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type of the mask used for masked operations and returned from comparisons.  <a href="#abffe464ff20f5933e5a50b699555fa5f">More...</a><br /></td></tr>
<tr class="separator:abffe464ff20f5933e5a50b699555fa5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a435ebd80eab40f6a9a311106fb234b82"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a435ebd80eab40f6a9a311106fb234b82"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVc_1_1Vector.html#a435ebd80eab40f6a9a311106fb234b82">IndexType</a> = <a class="el" href="classVc_1_1SimdArray.html">Vc::SimdArray</a>&lt; int, VectorTraits&lt; T, Abi &gt;::<a class="el" href="classVc_1_1Vector.html#a1b5d7e2e663d7997796fd9f72b8af75a">size</a>()&gt;</td></tr>
<tr class="memdesc:a435ebd80eab40f6a9a311106fb234b82"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type of the vector used for indexes in gather and scatter operations. <br /></td></tr>
<tr class="separator:a435ebd80eab40f6a9a311106fb234b82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2eaac791c05f06627d44f9438059b1ab"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVc_1_1Vector.html#a2eaac791c05f06627d44f9438059b1ab">index_type</a> = <a class="el" href="classVc_1_1Vector.html#a435ebd80eab40f6a9a311106fb234b82">IndexType</a></td></tr>
<tr class="memdesc:a2eaac791c05f06627d44f9438059b1ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type of the vector used for indexes in gather and scatter operations.  <a href="#a2eaac791c05f06627d44f9438059b1ab">More...</a><br /></td></tr>
<tr class="separator:a2eaac791c05f06627d44f9438059b1ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a47affd1a10b589811fc4828c1a2e0c6d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a47affd1a10b589811fc4828c1a2e0c6d"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVc_1_1Vector.html#a47affd1a10b589811fc4828c1a2e0c6d">setZero</a> ()</td></tr>
<tr class="memdesc:a47affd1a10b589811fc4828c1a2e0c6d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set all entries to zero. <br /></td></tr>
<tr class="separator:a47affd1a10b589811fc4828c1a2e0c6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a804d5492c78c2e5f9ca92f1d02c78c1b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVc_1_1Vector.html#a804d5492c78c2e5f9ca92f1d02c78c1b">setZero</a> (<a class="el" href="classVc_1_1Vector.html#a87ee111bfca7f15829e802bdf47c3b0e">MaskType</a> mask)</td></tr>
<tr class="memdesc:a804d5492c78c2e5f9ca92f1d02c78c1b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set all entries to zero where the mask is set.  <a href="#a804d5492c78c2e5f9ca92f1d02c78c1b">More...</a><br /></td></tr>
<tr class="separator:a804d5492c78c2e5f9ca92f1d02c78c1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10b3726d4ad99374f9448860fa5229d5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVc_1_1Vector.html#a10b3726d4ad99374f9448860fa5229d5">setZeroInverted</a> (<a class="el" href="classVc_1_1Vector.html#a87ee111bfca7f15829e802bdf47c3b0e">MaskType</a> mask)</td></tr>
<tr class="memdesc:a10b3726d4ad99374f9448860fa5229d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set all entries to zero where the mask is not set.  <a href="#a10b3726d4ad99374f9448860fa5229d5">More...</a><br /></td></tr>
<tr class="separator:a10b3726d4ad99374f9448860fa5229d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3fb1503849734e51c08adaff319c5e60"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3fb1503849734e51c08adaff319c5e60"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVc_1_1Vector.html#a3fb1503849734e51c08adaff319c5e60">setQnan</a> ()</td></tr>
<tr class="memdesc:a3fb1503849734e51c08adaff319c5e60"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set all entries to the bit representation of a QNaN. <br /></td></tr>
<tr class="separator:a3fb1503849734e51c08adaff319c5e60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b97acf03cd2b4e96eeed94c6bf6a3fa"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVc_1_1Vector.html#a3b97acf03cd2b4e96eeed94c6bf6a3fa">setQnan</a> (<a class="el" href="classVc_1_1Vector.html#a87ee111bfca7f15829e802bdf47c3b0e">MaskType</a> mask)</td></tr>
<tr class="memdesc:a3b97acf03cd2b4e96eeed94c6bf6a3fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set all entries to the bit representation of a QNaN where the mask is set.  <a href="#a3b97acf03cd2b4e96eeed94c6bf6a3fa">More...</a><br /></td></tr>
<tr class="separator:a3b97acf03cd2b4e96eeed94c6bf6a3fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6197f3a5d43c38efd55819af6d9404ca"><td class="memItemLeft" align="right" valign="top">Common::WriteMaskedVector&lt; <a class="el" href="classVc_1_1Vector.html">Vector</a>, <a class="el" href="classVc_1_1Vector.html#a87ee111bfca7f15829e802bdf47c3b0e">MaskType</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVc_1_1Vector.html#a6197f3a5d43c38efd55819af6d9404ca">operator()</a> (<a class="el" href="classVc_1_1Vector.html#a87ee111bfca7f15829e802bdf47c3b0e">MaskType</a> mask)</td></tr>
<tr class="memdesc:a6197f3a5d43c38efd55819af6d9404ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writemask the vector before an assignment.  <a href="#a6197f3a5d43c38efd55819af6d9404ca">More...</a><br /></td></tr>
<tr class="separator:a6197f3a5d43c38efd55819af6d9404ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81df1f97caedbdaa2dc75b78a98a3033"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classVc_1_1Vector.html">Vector</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVc_1_1Vector.html#a81df1f97caedbdaa2dc75b78a98a3033">sorted</a> () const </td></tr>
<tr class="memdesc:a81df1f97caedbdaa2dc75b78a98a3033"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a sorted copy of the vector.  <a href="#a81df1f97caedbdaa2dc75b78a98a3033">More...</a><br /></td></tr>
<tr class="separator:a81df1f97caedbdaa2dc75b78a98a3033"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Compile-Time Constant Initialization</div></td></tr>
<tr class="memitem:aba83f7828d95b601500471996fc8c3c0"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVc_1_1Vector.html#aba83f7828d95b601500471996fc8c3c0">Vector</a> ()=default</td></tr>
<tr class="memdesc:aba83f7828d95b601500471996fc8c3c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a zero-initialized vector object.  <a href="#aba83f7828d95b601500471996fc8c3c0">More...</a><br /></td></tr>
<tr class="separator:aba83f7828d95b601500471996fc8c3c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b959c60986675489b915cd33ffa1a65"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVc_1_1Vector.html#a4b959c60986675489b915cd33ffa1a65">Vector</a> (VectorSpecialInitializerZero)</td></tr>
<tr class="memdesc:a4b959c60986675489b915cd33ffa1a65"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a vector with the entries initialized to zero.  <a href="#a4b959c60986675489b915cd33ffa1a65">More...</a><br /></td></tr>
<tr class="separator:a4b959c60986675489b915cd33ffa1a65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6faca3e9ae02f4e213bad11cb860e20"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVc_1_1Vector.html#ac6faca3e9ae02f4e213bad11cb860e20">Vector</a> (VectorSpecialInitializerOne)</td></tr>
<tr class="memdesc:ac6faca3e9ae02f4e213bad11cb860e20"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a vector with the entries initialized to one.  <a href="#ac6faca3e9ae02f4e213bad11cb860e20">More...</a><br /></td></tr>
<tr class="separator:ac6faca3e9ae02f4e213bad11cb860e20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c5bdbbb09e1851bcb9b35b286c76753"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVc_1_1Vector.html#a9c5bdbbb09e1851bcb9b35b286c76753">Vector</a> (VectorSpecialInitializerIndexesFromZero)</td></tr>
<tr class="memdesc:a9c5bdbbb09e1851bcb9b35b286c76753"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a vector with the entries initialized to 0, 1, 2, 3, 4, 5, ...  <a href="#a9c5bdbbb09e1851bcb9b35b286c76753">More...</a><br /></td></tr>
<tr class="separator:a9c5bdbbb09e1851bcb9b35b286c76753"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Conversion/Broadcast Constructors</div></td></tr>
<tr class="memitem:ab03f19704c60f0c56cfbf52ec3ee1b73"><td class="memTemplParams" colspan="2"><a class="anchor" id="ab03f19704c60f0c56cfbf52ec3ee1b73"></a>
template&lt;typename U &gt; </td></tr>
<tr class="memitem:ab03f19704c60f0c56cfbf52ec3ee1b73"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classVc_1_1Vector.html#ab03f19704c60f0c56cfbf52ec3ee1b73">Vector</a> (<a class="el" href="classVc_1_1Vector.html">Vector</a>&lt; U, <a class="el" href="classVc_1_1Vector.html#abe9aa1f35fa46be781ae9e81d374a72b">abi</a> &gt; x, enable_if&lt; Traits::is_implicit_cast_allowed&lt; U, T &gt;::value &gt;=nullarg)</td></tr>
<tr class="memdesc:ab03f19704c60f0c56cfbf52ec3ee1b73"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implict conversion from compatible Vector&lt;U, Abi&gt; types. <br /></td></tr>
<tr class="separator:ab03f19704c60f0c56cfbf52ec3ee1b73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e363c9b2d525293cfb1656e1498e796"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVc_1_1Vector.html#a7e363c9b2d525293cfb1656e1498e796">Vector</a> (<a class="el" href="classVc_1_1Vector.html#ae9cb6038cbd15cb0bdc596f5383c2b21">EntryType</a> a)</td></tr>
<tr class="memdesc:a7e363c9b2d525293cfb1656e1498e796"><td class="mdescLeft">&#160;</td><td class="mdescRight">Broadcast Constructor.  <a href="#a7e363c9b2d525293cfb1656e1498e796">More...</a><br /></td></tr>
<tr class="separator:a7e363c9b2d525293cfb1656e1498e796"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7394b442797518f5d84ddb78e64744a4"><td class="memTemplParams" colspan="2"><a class="anchor" id="a7394b442797518f5d84ddb78e64744a4"></a>
template&lt;typename U &gt; </td></tr>
<tr class="memitem:a7394b442797518f5d84ddb78e64744a4"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><b>Vector</b> (U a, enable_if&lt; std::is_same&lt; U, int &gt;::value &amp;&amp;!std::is_same&lt; U, <a class="el" href="classVc_1_1Vector.html#ae9cb6038cbd15cb0bdc596f5383c2b21">EntryType</a> &gt;::value &gt;=nullarg)</td></tr>
<tr class="separator:a7394b442797518f5d84ddb78e64744a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Loads &amp; Stores</div></td></tr>
<tr class="memitem:aa5788937fe94e616e4587fff8343de53"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVc_1_1Vector.html#aa5788937fe94e616e4587fff8343de53">Vector</a> (const <a class="el" href="classVc_1_1Vector.html#ae9cb6038cbd15cb0bdc596f5383c2b21">EntryType</a> *mem)</td></tr>
<tr class="memdesc:aa5788937fe94e616e4587fff8343de53"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a vector from loading its entries from the array at <code>mem</code>.  <a href="#aa5788937fe94e616e4587fff8343de53">More...</a><br /></td></tr>
<tr class="separator:aa5788937fe94e616e4587fff8343de53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1c0a25236112f0bdf66d4bafd50d308"><td class="memTemplParams" colspan="2">template&lt;typename Flags , typename  = enable_if&lt;Traits::is_load_store_flag&lt;Flags&gt;::value&gt;&gt; </td></tr>
<tr class="memitem:ae1c0a25236112f0bdf66d4bafd50d308"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classVc_1_1Vector.html#ae1c0a25236112f0bdf66d4bafd50d308">Vector</a> (const <a class="el" href="classVc_1_1Vector.html#ae9cb6038cbd15cb0bdc596f5383c2b21">EntryType</a> *mem, Flags flags)</td></tr>
<tr class="memdesc:ae1c0a25236112f0bdf66d4bafd50d308"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a vector from loading its entries from the array at <code>mem</code>.  <a href="#ae1c0a25236112f0bdf66d4bafd50d308">More...</a><br /></td></tr>
<tr class="separator:ae1c0a25236112f0bdf66d4bafd50d308"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5f67b5c40bad345287018ef140405b7"><td class="memTemplParams" colspan="2"><a class="anchor" id="ab5f67b5c40bad345287018ef140405b7"></a>
template&lt;typename U , typename Flags  = DefaultLoadTag, typename  = enable_if&lt;              (!std::is_integral&lt;U&gt;::value || !std::is_integral&lt;EntryType&gt;::value ||               sizeof(EntryType) &gt;= sizeof(U)&gt; </td></tr>
<tr class="memitem:ab5f67b5c40bad345287018ef140405b7"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><b>Vector</b> (const U *x, Flags flags=Flags())</td></tr>
<tr class="separator:ab5f67b5c40bad345287018ef140405b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae40a8b2e28c176cecd1c859666cfcc6c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVc_1_1Vector.html#ae40a8b2e28c176cecd1c859666cfcc6c">load</a> (const <a class="el" href="classVc_1_1Vector.html#ae9cb6038cbd15cb0bdc596f5383c2b21">EntryType</a> *mem)</td></tr>
<tr class="memdesc:ae40a8b2e28c176cecd1c859666cfcc6c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load the vector entries from <code>mem</code>, overwriting the previous values.  <a href="#ae40a8b2e28c176cecd1c859666cfcc6c">More...</a><br /></td></tr>
<tr class="separator:ae40a8b2e28c176cecd1c859666cfcc6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7696ba25b9a87a220ee33c0ccdd2949b"><td class="memTemplParams" colspan="2">template&lt;typename Flags &gt; </td></tr>
<tr class="memitem:a7696ba25b9a87a220ee33c0ccdd2949b"><td class="memTemplItemLeft" align="right" valign="top">enable_if&lt; Traits::is_load_store_flag&lt; Flags &gt;::value, void &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classVc_1_1Vector.html#a7696ba25b9a87a220ee33c0ccdd2949b">load</a> (const <a class="el" href="classVc_1_1Vector.html#ae9cb6038cbd15cb0bdc596f5383c2b21">EntryType</a> *mem, Flags flags)</td></tr>
<tr class="memdesc:a7696ba25b9a87a220ee33c0ccdd2949b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load the vector entries from <code>mem</code>, overwriting the previous values.  <a href="#a7696ba25b9a87a220ee33c0ccdd2949b">More...</a><br /></td></tr>
<tr class="separator:a7696ba25b9a87a220ee33c0ccdd2949b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c1c88615d80cb09be5184b5f281d4b1"><td class="memTemplParams" colspan="2"><a class="anchor" id="a1c1c88615d80cb09be5184b5f281d4b1"></a>
template&lt;typename U , typename Flags  = DefaultLoadTag&gt; </td></tr>
<tr class="memitem:a1c1c88615d80cb09be5184b5f281d4b1"><td class="memTemplItemLeft" align="right" valign="top">load_concept&lt; U, Flags &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><b>load</b> (const U *mem, Flags=Flags()) 1</td></tr>
<tr class="separator:a1c1c88615d80cb09be5184b5f281d4b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a877b3f1854117429aca9b4a84561cdbb"><td class="memTemplParams" colspan="2">template&lt;typename U , typename Flags  = DefaultStoreTag, typename  = enable_if&lt;std::is_arithmetic&lt;U&gt;::value &amp;&amp;Traits::is_load_store_flag&lt;Flags&gt;::value&gt;&gt; </td></tr>
<tr class="memitem:a877b3f1854117429aca9b4a84561cdbb"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classVc_1_1Vector.html#a877b3f1854117429aca9b4a84561cdbb">store</a> (U *mem, Flags flags=Flags()) const 1</td></tr>
<tr class="memdesc:a877b3f1854117429aca9b4a84561cdbb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Store the vector data to <code>mem</code>.  <a href="#a877b3f1854117429aca9b4a84561cdbb">More...</a><br /></td></tr>
<tr class="separator:a877b3f1854117429aca9b4a84561cdbb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3f17d28735a2e98b003aa6ee0ac6745"><td class="memTemplParams" colspan="2">template&lt;typename U , typename Flags  = DefaultStoreTag, typename  = enable_if&lt;std::is_arithmetic&lt;U&gt;::value &amp;&amp;Traits::is_load_store_flag&lt;Flags&gt;::value&gt;&gt; </td></tr>
<tr class="memitem:ab3f17d28735a2e98b003aa6ee0ac6745"><td class="memTemplItemLeft" align="right" valign="top">void Vc_VDECL&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classVc_1_1Vector.html#ab3f17d28735a2e98b003aa6ee0ac6745">store</a> (U *mem, <a class="el" href="classVc_1_1Vector.html#a87ee111bfca7f15829e802bdf47c3b0e">MaskType</a> mask, Flags flags=Flags()) const 1</td></tr>
<tr class="memdesc:ab3f17d28735a2e98b003aa6ee0ac6745"><td class="mdescLeft">&#160;</td><td class="mdescRight">Store the vector data to <code>mem</code> where <code>mask</code> is set.  <a href="#ab3f17d28735a2e98b003aa6ee0ac6745">More...</a><br /></td></tr>
<tr class="separator:ab3f17d28735a2e98b003aa6ee0ac6745"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb06bb20c7689d9a92c119b7351c6441"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="acb06bb20c7689d9a92c119b7351c6441"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVc_1_1Vector.html#acb06bb20c7689d9a92c119b7351c6441">store</a> (<a class="el" href="classVc_1_1Vector.html#ae9cb6038cbd15cb0bdc596f5383c2b21">EntryType</a> *mem) const </td></tr>
<tr class="memdesc:acb06bb20c7689d9a92c119b7351c6441"><td class="mdescLeft">&#160;</td><td class="mdescRight">The following store overloads support classes that have a cast operator to <code>EntryType *</code>. <br /></td></tr>
<tr class="separator:acb06bb20c7689d9a92c119b7351c6441"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d6b0458a00ee4a1380791faff0f7dce"><td class="memTemplParams" colspan="2"><a class="anchor" id="a9d6b0458a00ee4a1380791faff0f7dce"></a>
template&lt;typename Flags , typename  = enable_if&lt;Traits::is_load_store_flag&lt;Flags&gt;::value&gt;&gt; </td></tr>
<tr class="memitem:a9d6b0458a00ee4a1380791faff0f7dce"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>store</b> (<a class="el" href="classVc_1_1Vector.html#ae9cb6038cbd15cb0bdc596f5383c2b21">EntryType</a> *mem, Flags flags) const </td></tr>
<tr class="separator:a9d6b0458a00ee4a1380791faff0f7dce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d3ba913be3935229c7abefdb98de37e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8d3ba913be3935229c7abefdb98de37e"></a>
void Vc_VDECL&#160;</td><td class="memItemRight" valign="bottom"><b>store</b> (<a class="el" href="classVc_1_1Vector.html#ae9cb6038cbd15cb0bdc596f5383c2b21">EntryType</a> *mem, <a class="el" href="classVc_1_1Vector.html#a87ee111bfca7f15829e802bdf47c3b0e">MaskType</a> mask) const </td></tr>
<tr class="separator:a8d3ba913be3935229c7abefdb98de37e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab189b7574d637fe35ef02da7b061203d"><td class="memTemplParams" colspan="2"><a class="anchor" id="ab189b7574d637fe35ef02da7b061203d"></a>
template&lt;typename Flags , typename  = enable_if&lt;Traits::is_load_store_flag&lt;Flags&gt;::value&gt;&gt; </td></tr>
<tr class="memitem:ab189b7574d637fe35ef02da7b061203d"><td class="memTemplItemLeft" align="right" valign="top">void Vc_VDECL&#160;</td><td class="memTemplItemRight" valign="bottom"><b>store</b> (<a class="el" href="classVc_1_1Vector.html#ae9cb6038cbd15cb0bdc596f5383c2b21">EntryType</a> *mem, <a class="el" href="classVc_1_1Vector.html#a87ee111bfca7f15829e802bdf47c3b0e">MaskType</a> mask, Flags flags) const </td></tr>
<tr class="separator:ab189b7574d637fe35ef02da7b061203d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Gather constructors and member functions</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>Constructs or loads a vector from the objects at <code>mem[indexes[0]]</code>, <code>mem[indexes[1]]</code>, <code>mem[indexes[2]]</code>, ...</p>
<p>All gather functions optionally take a mask as last argument. In that case only the entries that are selected in the mask are accessed in memory and copied to the vector. This enables invalid indexes in the <code>indexes</code> vector if those are masked off in <code>mask</code>.</p>
<p>Gathers from structured data (AoS: arrays of struct) are possible via a special subscript operator of the container (array). You can use Vc::array and <a class="el" href="group__Utilities.html#gac1ffd8b29c356abdbb821a7854c53b07">Vc::vector</a> as drop-in replacements for <code>std::array</code> and <code>std::vector</code>. These container classes contain the necessary subscript operator overload. Example: </p><div class="fragment"><div class="line"><a class="code" href="group__Utilities.html#gac1ffd8b29c356abdbb821a7854c53b07">Vc::vector&lt;float&gt;</a> data(100);</div>
<div class="line">std::iota(data.begin(), data.end(), 0.f);  <span class="comment">// fill with values 0, 1, 2, ...</span></div>
<div class="line"><span class="keyword">auto</span> indexes = <a class="code" href="classVc_1_1SimdArray.html#a804229aa4eea8ed7572b273bba0530cd">float_v::IndexType::IndexesFromZero</a>();</div>
<div class="line"><a class="code" href="group__Vectors.html#ga5cf7c5a0dadbbbbcb9b69c5e42ee0528">float_v</a> gathered = data[indexes];  <span class="comment">// gathered == [0, 1, 2, ...]</span></div>
</div><!-- fragment --><p>Alternatively, you can use Vc::Common::AdaptSubscriptOperator to extend a given container class with the necessary subscript operator. Example: </p><div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> Allocator = std::allocator&lt;T&gt;&gt;</div>
<div class="line"><span class="keyword">using</span> my_vector = Vc::Common::AdaptSubscriptOperator&lt;std::vector&lt;T, Allocator&gt;&gt;;</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mem</td><td>A pointer to memory which contains objects of type <code>MT</code> at the offsets given by <code>indexes</code>. </td></tr>
    <tr><td class="paramname">indexes</td><td>A container/vector of offsets into <code>mem</code>. The type of <code>indexes</code> (<code>IT</code>) may either be a pointer to integers (C-array) or a vector of integers (preferrably IndexType). </td></tr>
    <tr><td class="paramname">mask</td><td>If a mask is given, only the active entries will be copied from memory.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>If you use a masked gather constructor the masked-off entries of the vector are zero-initilized. </dd></dl>
</div></td></tr>
<tr class="memitem:ad7179d4a29a24cb3c12d969ef0d13add"><td class="memTemplParams" colspan="2"><a class="anchor" id="ad7179d4a29a24cb3c12d969ef0d13add"></a>
template&lt;typename MT , typename IT , typename  = enable_if&lt;Traits::has_subscript_operator&lt;IT&gt;::value&gt;&gt; </td></tr>
<tr class="memitem:ad7179d4a29a24cb3c12d969ef0d13add"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classVc_1_1Vector.html#ad7179d4a29a24cb3c12d969ef0d13add">Vector</a> (const MT *mem, const IT &amp;indexes)</td></tr>
<tr class="memdesc:ad7179d4a29a24cb3c12d969ef0d13add"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gather constructor. <br /></td></tr>
<tr class="separator:ad7179d4a29a24cb3c12d969ef0d13add"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25b8265538d4b25410e6a80e3e9578c3"><td class="memTemplParams" colspan="2"><a class="anchor" id="a25b8265538d4b25410e6a80e3e9578c3"></a>
template&lt;typename MT , typename IT , typename  = enable_if&lt;Vc::Traits::has_subscript_operator&lt;IT&gt;::value&gt;&gt; </td></tr>
<tr class="memitem:a25b8265538d4b25410e6a80e3e9578c3"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classVc_1_1Vector.html#a25b8265538d4b25410e6a80e3e9578c3">Vector</a> (const MT *mem, const IT &amp;indexes, <a class="el" href="classVc_1_1Mask.html">MaskArgument</a> mask)</td></tr>
<tr class="memdesc:a25b8265538d4b25410e6a80e3e9578c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Masked gather constructor. <br /></td></tr>
<tr class="separator:a25b8265538d4b25410e6a80e3e9578c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a813cc1dd2aba6d72c0b7dfbda1a898f4"><td class="memTemplParams" colspan="2"><a class="anchor" id="a813cc1dd2aba6d72c0b7dfbda1a898f4"></a>
template&lt;typename MT , typename IT , typename  = enable_if&lt;Vc::Traits::has_subscript_operator&lt;IT&gt;::value&gt;&gt; </td></tr>
<tr class="memitem:a813cc1dd2aba6d72c0b7dfbda1a898f4"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classVc_1_1Vector.html#a813cc1dd2aba6d72c0b7dfbda1a898f4">gather</a> (const MT *mem, const IT &amp;indexes)</td></tr>
<tr class="memdesc:a813cc1dd2aba6d72c0b7dfbda1a898f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gather function. <br /></td></tr>
<tr class="separator:a813cc1dd2aba6d72c0b7dfbda1a898f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbacca4066818dbf627e6a848b927cb7"><td class="memTemplParams" colspan="2"><a class="anchor" id="acbacca4066818dbf627e6a848b927cb7"></a>
template&lt;typename MT , typename IT , typename  = enable_if&lt;Vc::Traits::has_subscript_operator&lt;IT&gt;::value&gt;&gt; </td></tr>
<tr class="memitem:acbacca4066818dbf627e6a848b927cb7"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classVc_1_1Vector.html#acbacca4066818dbf627e6a848b927cb7">gather</a> (const MT *mem, const IT &amp;indexes, <a class="el" href="classVc_1_1Mask.html">MaskArgument</a> mask)</td></tr>
<tr class="memdesc:acbacca4066818dbf627e6a848b927cb7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Masked gather function. <br /></td></tr>
<tr class="separator:acbacca4066818dbf627e6a848b927cb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr><td colspan="2"><div class="groupHeader">Scatter functions</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>Stores a vector to the objects at <code>mem[indexes[0]]</code>, <code>mem[indexes[1]]</code>, <code>mem[indexes[2]]</code>, ...</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mem</td><td>A pointer to memory which contains objects of type <code>MT</code> at the offsets given by <code>indexes</code>. </td></tr>
    <tr><td class="paramname">indexes</td><td></td></tr>
    <tr><td class="paramname">mask</td><td></td></tr>
  </table>
  </dd>
</dl>
</div></td></tr>
<tr class="memitem:af242f4f4405b3437d33ce2e30802c5dc"><td class="memTemplParams" colspan="2"><a class="anchor" id="af242f4f4405b3437d33ce2e30802c5dc"></a>
template&lt;typename MT , typename IT , typename  = enable_if&lt;Vc::Traits::has_subscript_operator&lt;IT&gt;::value&gt;&gt; </td></tr>
<tr class="memitem:af242f4f4405b3437d33ce2e30802c5dc"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classVc_1_1Vector.html#af242f4f4405b3437d33ce2e30802c5dc">scatter</a> (MT *mem, IT &amp;&amp;indexes) const </td></tr>
<tr class="memdesc:af242f4f4405b3437d33ce2e30802c5dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scatter function. <br /></td></tr>
<tr class="separator:af242f4f4405b3437d33ce2e30802c5dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af94152b2dbbdee91bb3ebb434adb34b6"><td class="memTemplParams" colspan="2"><a class="anchor" id="af94152b2dbbdee91bb3ebb434adb34b6"></a>
template&lt;typename MT , typename IT , typename  = enable_if&lt;Vc::Traits::has_subscript_operator&lt;IT&gt;::value&gt;&gt; </td></tr>
<tr class="memitem:af94152b2dbbdee91bb3ebb434adb34b6"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classVc_1_1Vector.html#af94152b2dbbdee91bb3ebb434adb34b6">scatter</a> (MT *mem, IT &amp;&amp;indexes, <a class="el" href="classVc_1_1Mask.html">MaskArgument</a> mask) const </td></tr>
<tr class="memdesc:af94152b2dbbdee91bb3ebb434adb34b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Masked scatter function. <br /></td></tr>
<tr class="separator:af94152b2dbbdee91bb3ebb434adb34b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr><td colspan="2"><div class="groupHeader">Scalar Subscript Operators</div></td></tr>
<tr class="memitem:ad9490a1dfe9ab280829a12edea2a858b"><td class="memItemLeft" align="right" valign="top">reference&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVc_1_1Vector.html#ad9490a1dfe9ab280829a12edea2a858b">operator[]</a> (size_t index) noexcept</td></tr>
<tr class="memdesc:ad9490a1dfe9ab280829a12edea2a858b"><td class="mdescLeft">&#160;</td><td class="mdescRight">This operator can be used to modify scalar entries of the vector.  <a href="#ad9490a1dfe9ab280829a12edea2a858b">More...</a><br /></td></tr>
<tr class="separator:ad9490a1dfe9ab280829a12edea2a858b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61ea5f5cc301d8c25138afa9dfc3f04e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classVc_1_1Vector.html#ae9cb6038cbd15cb0bdc596f5383c2b21">EntryType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVc_1_1Vector.html#a61ea5f5cc301d8c25138afa9dfc3f04e">operator[]</a> (size_t index) const  noexcept</td></tr>
<tr class="memdesc:a61ea5f5cc301d8c25138afa9dfc3f04e"><td class="mdescLeft">&#160;</td><td class="mdescRight">This operator can be used to read scalar entries of the vector.  <a href="#a61ea5f5cc301d8c25138afa9dfc3f04e">More...</a><br /></td></tr>
<tr class="separator:a61ea5f5cc301d8c25138afa9dfc3f04e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Unary Operators</div></td></tr>
<tr class="memitem:af99b135180d40d99d3b707875007f7fb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classVc_1_1Vector.html#a87ee111bfca7f15829e802bdf47c3b0e">MaskType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVc_1_1Vector.html#af99b135180d40d99d3b707875007f7fb">operator!</a> () const </td></tr>
<tr class="memdesc:af99b135180d40d99d3b707875007f7fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine where the vector is null.  <a href="#af99b135180d40d99d3b707875007f7fb">More...</a><br /></td></tr>
<tr class="separator:af99b135180d40d99d3b707875007f7fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af61178bc2c71839e7cb8e98358e453be"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classVc_1_1Vector.html">Vector</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVc_1_1Vector.html#af61178bc2c71839e7cb8e98358e453be">operator~</a> () const </td></tr>
<tr class="memdesc:af61178bc2c71839e7cb8e98358e453be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inverts all bits.  <a href="#af61178bc2c71839e7cb8e98358e453be">More...</a><br /></td></tr>
<tr class="separator:af61178bc2c71839e7cb8e98358e453be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a729f1353c878b3c9ba3887e396f3d0a5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a729f1353c878b3c9ba3887e396f3d0a5"></a>
<a class="el" href="classVc_1_1Vector.html">Vector</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVc_1_1Vector.html#a729f1353c878b3c9ba3887e396f3d0a5">operator-</a> () const </td></tr>
<tr class="memdesc:a729f1353c878b3c9ba3887e396f3d0a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a new vector object with all entries negated. <br /></td></tr>
<tr class="separator:a729f1353c878b3c9ba3887e396f3d0a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a71a4d6af4e922a2e84375e78c68f25"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5a71a4d6af4e922a2e84375e78c68f25"></a>
<a class="el" href="classVc_1_1Vector.html">Vector</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVc_1_1Vector.html#a5a71a4d6af4e922a2e84375e78c68f25">operator+</a> () const </td></tr>
<tr class="memdesc:a5a71a4d6af4e922a2e84375e78c68f25"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a copy of the vector object. <br /></td></tr>
<tr class="separator:a5a71a4d6af4e922a2e84375e78c68f25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Increment and Decrement Operators</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>The increment and decrement operators apply the increment/decrement operation per component.</p>
<p>The semantics are equal to the semantics of the fundamental arithmetics type <code>T</code>.</p>
<dl class="section note"><dt>Note</dt><dd>Over-/Underflow of signed integral types is undefined behavior and may actually break your code. </dd></dl>
</div></td></tr>
<tr class="memitem:a7db03d17a06450a449f8407e556d769b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7db03d17a06450a449f8407e556d769b"></a>
<a class="el" href="classVc_1_1Vector.html">Vector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator++</b> ()</td></tr>
<tr class="separator:a7db03d17a06450a449f8407e556d769b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaaaa52b9a4c62f549da6f28da151f070"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aaaaa52b9a4c62f549da6f28da151f070"></a>
<a class="el" href="classVc_1_1Vector.html">Vector</a>&#160;</td><td class="memItemRight" valign="bottom"><b>operator++</b> (int)</td></tr>
<tr class="separator:aaaaa52b9a4c62f549da6f28da151f070"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a027f78ab0c601734fb1ab5d57d3ac3e8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a027f78ab0c601734fb1ab5d57d3ac3e8"></a>
<a class="el" href="classVc_1_1Vector.html">Vector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator--</b> ()</td></tr>
<tr class="separator:a027f78ab0c601734fb1ab5d57d3ac3e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9be470793142b7361c388162436d3a72"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9be470793142b7361c388162436d3a72"></a>
<a class="el" href="classVc_1_1Vector.html">Vector</a>&#160;</td><td class="memItemRight" valign="bottom"><b>operator--</b> (int)</td></tr>
<tr class="separator:a9be470793142b7361c388162436d3a72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Arithmetic Operations</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>The arithmetic operations are implemented as component-wise application of the operator on the two vector objects.</p>
<p>Example: </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> foo(<a class="code" href="group__Vectors.html#ga5cf7c5a0dadbbbbcb9b69c5e42ee0528">float_v</a> a, <a class="code" href="group__Vectors.html#ga5cf7c5a0dadbbbbcb9b69c5e42ee0528">float_v</a> b) {</div>
<div class="line">  <span class="keyword">const</span> <a class="code" href="group__Vectors.html#ga5cf7c5a0dadbbbbcb9b69c5e42ee0528">float_v</a> <a class="code" href="classVc_1_1Vector.html#a94598aeb22a0d556d904ff4a057b7dee">product</a>    = a * b;</div>
<div class="line">  <span class="keyword">const</span> <a class="code" href="group__Vectors.html#ga5cf7c5a0dadbbbbcb9b69c5e42ee0528">float_v</a> difference = a - b;</div>
<div class="line">  a += b;</div>
<div class="line">  <span class="keyword">auto</span> quotient = a / b;</div>
<div class="line">  <span class="keyword">auto</span> modulo = <span class="keyword">static_cast&lt;</span><a class="code" href="group__Vectors.html#gaff6f527c244d2e97ae290d2325de8ec0">int_v</a><span class="keyword">&gt;</span>(a) % static_cast&lt;int_v&gt;(b);</div>
<div class="line">}</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>The vector to add, subtract, multiply, or divide by. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector object of the same type with the components filled according to a component-wise application of the operator.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>If a signed integral vector operation overflows the result is undefined. (which is in agreement to the behavior of the fundamental signed integral types in C++) </dd></dl>
</div></td></tr>
<tr class="memitem:a1eb5bdd62434000bd8f7e7d65e3ec867"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1eb5bdd62434000bd8f7e7d65e3ec867"></a>
<a class="el" href="classVc_1_1Vector.html">Vector</a>&#160;</td><td class="memItemRight" valign="bottom"><b>operator+</b> (const <a class="el" href="classVc_1_1Vector.html">Vector</a> &amp;x) const </td></tr>
<tr class="separator:a1eb5bdd62434000bd8f7e7d65e3ec867"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59daabb8d573cb5b757058c18069b3c9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a59daabb8d573cb5b757058c18069b3c9"></a>
<a class="el" href="classVc_1_1Vector.html">Vector</a>&#160;</td><td class="memItemRight" valign="bottom"><b>operator-</b> (const <a class="el" href="classVc_1_1Vector.html">Vector</a> &amp;x) const </td></tr>
<tr class="separator:a59daabb8d573cb5b757058c18069b3c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15ab7c835931e90dc0c8090008fc02a9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a15ab7c835931e90dc0c8090008fc02a9"></a>
<a class="el" href="classVc_1_1Vector.html">Vector</a>&#160;</td><td class="memItemRight" valign="bottom"><b>operator*</b> (const <a class="el" href="classVc_1_1Vector.html">Vector</a> &amp;x) const </td></tr>
<tr class="separator:a15ab7c835931e90dc0c8090008fc02a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ebc2d1cc71ce61c92a282b6c8330846"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4ebc2d1cc71ce61c92a282b6c8330846"></a>
<a class="el" href="classVc_1_1Vector.html">Vector</a>&#160;</td><td class="memItemRight" valign="bottom"><b>operator/</b> (const <a class="el" href="classVc_1_1Vector.html">Vector</a> &amp;x) const </td></tr>
<tr class="separator:a4ebc2d1cc71ce61c92a282b6c8330846"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad306e8ade2de814dbe1b4a376f26b587"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad306e8ade2de814dbe1b4a376f26b587"></a>
<a class="el" href="classVc_1_1Vector.html">Vector</a>&#160;</td><td class="memItemRight" valign="bottom"><b>operator%</b> (const <a class="el" href="classVc_1_1Vector.html">Vector</a> &amp;x) const </td></tr>
<tr class="separator:ad306e8ade2de814dbe1b4a376f26b587"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Binary Operations</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>The binary operations are implemented as component-wise application of the operator on the two vector objects.</p>
<p>Example: </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> foo(<a class="code" href="group__Vectors.html#gaff6f527c244d2e97ae290d2325de8ec0">int_v</a> a, <a class="code" href="group__Vectors.html#gaff6f527c244d2e97ae290d2325de8ec0">int_v</a> b) {</div>
<div class="line">  <span class="keyword">const</span> <a class="code" href="group__Vectors.html#gaff6f527c244d2e97ae290d2325de8ec0">int_v</a> combined_bits = a | b;</div>
<div class="line">  <span class="keyword">const</span> <a class="code" href="group__Vectors.html#gaff6f527c244d2e97ae290d2325de8ec0">int_v</a> masked_bits = a &amp; b;</div>
<div class="line">  a ^= b;  <span class="comment">// flipped bits</span></div>
<div class="line">}</div>
</div><!-- fragment --><dl class="section return"><dt>Returns</dt><dd>A vector object of the same type with the components filled according to a component-wise application of the operator. </dd></dl>
</div></td></tr>
<tr class="memitem:a15d27bde0bb97d6d640cbd96ab8bfdcf"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a15d27bde0bb97d6d640cbd96ab8bfdcf"></a>
<a class="el" href="classVc_1_1Vector.html">Vector</a>&#160;</td><td class="memItemRight" valign="bottom"><b>operator|</b> (const <a class="el" href="classVc_1_1Vector.html">Vector</a> &amp;x) const </td></tr>
<tr class="separator:a15d27bde0bb97d6d640cbd96ab8bfdcf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a358ed9f687488566e6b8f3913c08d2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6a358ed9f687488566e6b8f3913c08d2"></a>
<a class="el" href="classVc_1_1Vector.html">Vector</a>&#160;</td><td class="memItemRight" valign="bottom"><b>operator&amp;</b> (const <a class="el" href="classVc_1_1Vector.html">Vector</a> &amp;x) const </td></tr>
<tr class="separator:a6a358ed9f687488566e6b8f3913c08d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d627f4f335e6a336156fb8a2539e5b0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4d627f4f335e6a336156fb8a2539e5b0"></a>
<a class="el" href="classVc_1_1Vector.html">Vector</a>&#160;</td><td class="memItemRight" valign="bottom"><b>operator^</b> (const <a class="el" href="classVc_1_1Vector.html">Vector</a> &amp;x) const </td></tr>
<tr class="separator:a4d627f4f335e6a336156fb8a2539e5b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Shift Operations</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>The shift operations are implemented as component-wise application of the operator on the two vector objects.</p>
<p>Example: </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> foo(<a class="code" href="group__Vectors.html#gaff6f527c244d2e97ae290d2325de8ec0">int_v</a> a, <a class="code" href="group__Vectors.html#gaff6f527c244d2e97ae290d2325de8ec0">int_v</a> b) {</div>
<div class="line">  <span class="keyword">const</span> <a class="code" href="group__Vectors.html#gaff6f527c244d2e97ae290d2325de8ec0">int_v</a> right = a &gt;&gt; b;</div>
<div class="line">  a &lt;&lt;= b;</div>
<div class="line">}</div>
</div><!-- fragment --><dl class="section return"><dt>Returns</dt><dd>A vector object of the same type with the components filled according to a component-wise application of the operator. </dd></dl>
</div></td></tr>
<tr class="memitem:a9202c218340c7b5ae282b990d9368a35"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9202c218340c7b5ae282b990d9368a35"></a>
<a class="el" href="classVc_1_1Vector.html">Vector</a>&#160;</td><td class="memItemRight" valign="bottom"><b>operator&lt;&lt;</b> (const <a class="el" href="classVc_1_1Vector.html">Vector</a> &amp;x) const </td></tr>
<tr class="separator:a9202c218340c7b5ae282b990d9368a35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a881b8e72247a3e54a8330de944f8ed1f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a881b8e72247a3e54a8330de944f8ed1f"></a>
<a class="el" href="classVc_1_1Vector.html">Vector</a>&#160;</td><td class="memItemRight" valign="bottom"><b>operator&gt;&gt;</b> (const <a class="el" href="classVc_1_1Vector.html">Vector</a> &amp;x) const </td></tr>
<tr class="separator:a881b8e72247a3e54a8330de944f8ed1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Comparisons</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>All comparison operators return a mask object.</p>
<p>Example: </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> foo(<span class="keyword">const</span> <a class="code" href="group__Vectors.html#ga5cf7c5a0dadbbbbcb9b69c5e42ee0528">float_v</a> &amp;a, <span class="keyword">const</span> <a class="code" href="group__Vectors.html#ga5cf7c5a0dadbbbbcb9b69c5e42ee0528">float_v</a> &amp;b) {</div>
<div class="line">  <span class="keyword">const</span> <a class="code" href="group__Masks.html#gab9a61667770e6aa34fbf79bd866c6125">float_m</a> mask = a &lt; b;</div>
<div class="line">  ...</div>
<div class="line">}</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>The vector to compare against. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A mask object. Its components contain the boolean results of the component-wise compare operation. </dd></dl>
</div></td></tr>
<tr class="memitem:a3d3126c939e8eb339b12fda4fa105b2a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3d3126c939e8eb339b12fda4fa105b2a"></a>
<a class="el" href="classVc_1_1Vector.html#a87ee111bfca7f15829e802bdf47c3b0e">MaskType</a>&#160;</td><td class="memItemRight" valign="bottom"><b>operator==</b> (const <a class="el" href="classVc_1_1Vector.html">Vector</a> &amp;x) const </td></tr>
<tr class="separator:a3d3126c939e8eb339b12fda4fa105b2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac4599e41399d9d7ee50c8b1af5cd23b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aac4599e41399d9d7ee50c8b1af5cd23b"></a>
<a class="el" href="classVc_1_1Vector.html#a87ee111bfca7f15829e802bdf47c3b0e">MaskType</a>&#160;</td><td class="memItemRight" valign="bottom"><b>operator!=</b> (const <a class="el" href="classVc_1_1Vector.html">Vector</a> &amp;x) const </td></tr>
<tr class="separator:aac4599e41399d9d7ee50c8b1af5cd23b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e7badb11c607f0db1b8e1f95d0567e0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2e7badb11c607f0db1b8e1f95d0567e0"></a>
<a class="el" href="classVc_1_1Vector.html#a87ee111bfca7f15829e802bdf47c3b0e">MaskType</a>&#160;</td><td class="memItemRight" valign="bottom"><b>operator&lt;=</b> (const <a class="el" href="classVc_1_1Vector.html">Vector</a> &amp;x) const </td></tr>
<tr class="separator:a2e7badb11c607f0db1b8e1f95d0567e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac78101f65ed9e0caa260d13c90210d9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aac78101f65ed9e0caa260d13c90210d9"></a>
<a class="el" href="classVc_1_1Vector.html#a87ee111bfca7f15829e802bdf47c3b0e">MaskType</a>&#160;</td><td class="memItemRight" valign="bottom"><b>operator&gt;=</b> (const <a class="el" href="classVc_1_1Vector.html">Vector</a> &amp;x) const </td></tr>
<tr class="separator:aac78101f65ed9e0caa260d13c90210d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89f2a4f3d35411dd42c9ee46044b65e3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a89f2a4f3d35411dd42c9ee46044b65e3"></a>
<a class="el" href="classVc_1_1Vector.html#a87ee111bfca7f15829e802bdf47c3b0e">MaskType</a>&#160;</td><td class="memItemRight" valign="bottom"><b>operator&lt;</b> (const <a class="el" href="classVc_1_1Vector.html">Vector</a> &amp;x) const </td></tr>
<tr class="separator:a89f2a4f3d35411dd42c9ee46044b65e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0e809b4c6ed5fd94714741bcfc65527"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab0e809b4c6ed5fd94714741bcfc65527"></a>
<a class="el" href="classVc_1_1Vector.html#a87ee111bfca7f15829e802bdf47c3b0e">MaskType</a>&#160;</td><td class="memItemRight" valign="bottom"><b>operator&gt;</b> (const <a class="el" href="classVc_1_1Vector.html">Vector</a> &amp;x) const </td></tr>
<tr class="separator:ab0e809b4c6ed5fd94714741bcfc65527"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Horizontal Reduction Operations</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>Horizontal operations can be used to reduce the values of a vector to a scalar value.</p>
<p>Example: </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> foo(<span class="keyword">const</span> <a class="code" href="group__Vectors.html#ga5cf7c5a0dadbbbbcb9b69c5e42ee0528">float_v</a> &amp;v) {</div>
<div class="line">  <span class="keywordtype">float</span> <a class="code" href="classVc_1_1Vector.html#afc24215529ffa644772aeeedf3d543ec">min</a> = v.min(); <span class="comment">// smallest value in v</span></div>
<div class="line">  <span class="keywordtype">float</span> <a class="code" href="classVc_1_1Vector.html#a8aad69a89848f78401fa6ae2dcddc4e4">sum</a> = v.sum(); <span class="comment">// sum of all values in v</span></div>
<div class="line">}</div>
</div><!-- fragment --> </div></td></tr>
<tr class="memitem:afc24215529ffa644772aeeedf3d543ec"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afc24215529ffa644772aeeedf3d543ec"></a>
<a class="el" href="classVc_1_1Vector.html#ae9cb6038cbd15cb0bdc596f5383c2b21">EntryType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVc_1_1Vector.html#afc24215529ffa644772aeeedf3d543ec">min</a> () const </td></tr>
<tr class="memdesc:afc24215529ffa644772aeeedf3d543ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the smallest entry in the vector. <br /></td></tr>
<tr class="separator:afc24215529ffa644772aeeedf3d543ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00f4f4553083e0e6c441e00a7a1ab820"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a00f4f4553083e0e6c441e00a7a1ab820"></a>
<a class="el" href="classVc_1_1Vector.html#ae9cb6038cbd15cb0bdc596f5383c2b21">EntryType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVc_1_1Vector.html#a00f4f4553083e0e6c441e00a7a1ab820">max</a> () const </td></tr>
<tr class="memdesc:a00f4f4553083e0e6c441e00a7a1ab820"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the largest entry in the vector. <br /></td></tr>
<tr class="separator:a00f4f4553083e0e6c441e00a7a1ab820"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94598aeb22a0d556d904ff4a057b7dee"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a94598aeb22a0d556d904ff4a057b7dee"></a>
<a class="el" href="classVc_1_1Vector.html#ae9cb6038cbd15cb0bdc596f5383c2b21">EntryType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVc_1_1Vector.html#a94598aeb22a0d556d904ff4a057b7dee">product</a> () const </td></tr>
<tr class="memdesc:a94598aeb22a0d556d904ff4a057b7dee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the product of all entries in the vector. <br /></td></tr>
<tr class="separator:a94598aeb22a0d556d904ff4a057b7dee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8aad69a89848f78401fa6ae2dcddc4e4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8aad69a89848f78401fa6ae2dcddc4e4"></a>
<a class="el" href="classVc_1_1Vector.html#ae9cb6038cbd15cb0bdc596f5383c2b21">EntryType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVc_1_1Vector.html#a8aad69a89848f78401fa6ae2dcddc4e4">sum</a> () const </td></tr>
<tr class="memdesc:a8aad69a89848f78401fa6ae2dcddc4e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the sum of all entries in the vector. <br /></td></tr>
<tr class="separator:a8aad69a89848f78401fa6ae2dcddc4e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7464d357d472c935dd52b1a28d63ad02"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7464d357d472c935dd52b1a28d63ad02"></a>
<a class="el" href="classVc_1_1Vector.html">Vector</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVc_1_1Vector.html#a7464d357d472c935dd52b1a28d63ad02">partialSum</a> () const </td></tr>
<tr class="memdesc:a7464d357d472c935dd52b1a28d63ad02"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a vector containing the sum of all entries with smaller index. <br /></td></tr>
<tr class="separator:a7464d357d472c935dd52b1a28d63ad02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14252eb2f2dacad128e3b86d22391263"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a14252eb2f2dacad128e3b86d22391263"></a>
<a class="el" href="classVc_1_1Vector.html#ae9cb6038cbd15cb0bdc596f5383c2b21">EntryType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVc_1_1Vector.html#a14252eb2f2dacad128e3b86d22391263">min</a> (<a class="el" href="classVc_1_1Vector.html#a87ee111bfca7f15829e802bdf47c3b0e">MaskType</a> mask) const </td></tr>
<tr class="memdesc:a14252eb2f2dacad128e3b86d22391263"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the smallest entry of the vector components selected by <code>mask</code>. <br /></td></tr>
<tr class="separator:a14252eb2f2dacad128e3b86d22391263"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a213325fd10013bb9448a97592e74281a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a213325fd10013bb9448a97592e74281a"></a>
<a class="el" href="classVc_1_1Vector.html#ae9cb6038cbd15cb0bdc596f5383c2b21">EntryType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVc_1_1Vector.html#a213325fd10013bb9448a97592e74281a">max</a> (<a class="el" href="classVc_1_1Vector.html#a87ee111bfca7f15829e802bdf47c3b0e">MaskType</a> mask) const </td></tr>
<tr class="memdesc:a213325fd10013bb9448a97592e74281a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the largest entry of the vector components selected by <code>mask</code>. <br /></td></tr>
<tr class="separator:a213325fd10013bb9448a97592e74281a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08d80d86c9e546b1ea3a78503cbfef72"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a08d80d86c9e546b1ea3a78503cbfef72"></a>
<a class="el" href="classVc_1_1Vector.html#ae9cb6038cbd15cb0bdc596f5383c2b21">EntryType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVc_1_1Vector.html#a08d80d86c9e546b1ea3a78503cbfef72">product</a> (<a class="el" href="classVc_1_1Vector.html#a87ee111bfca7f15829e802bdf47c3b0e">MaskType</a> mask) const </td></tr>
<tr class="memdesc:a08d80d86c9e546b1ea3a78503cbfef72"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the product of the vector components selected by <code>mask</code>. <br /></td></tr>
<tr class="separator:a08d80d86c9e546b1ea3a78503cbfef72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3dca67887564a02e0af4f4f076d16844"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3dca67887564a02e0af4f4f076d16844"></a>
<a class="el" href="classVc_1_1Vector.html#ae9cb6038cbd15cb0bdc596f5383c2b21">EntryType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVc_1_1Vector.html#a3dca67887564a02e0af4f4f076d16844">sum</a> (<a class="el" href="classVc_1_1Vector.html#a87ee111bfca7f15829e802bdf47c3b0e">MaskType</a> mask) const </td></tr>
<tr class="memdesc:a3dca67887564a02e0af4f4f076d16844"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the sum of the vector components selected by <code>mask</code>. <br /></td></tr>
<tr class="separator:a3dca67887564a02e0af4f4f076d16844"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Shift and Rotate</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>These functions allow to shift or rotate the entries in a vector.</p>
<p>All functions with an <code>amount</code> parameter support positive and negative numbers for the shift/rotate value.</p>
<p>Example: </p><div class="fragment"><div class="line"><span class="keyword">using namespace </span><a class="code" href="namespaceVc.html">Vc</a>;</div>
<div class="line"><a class="code" href="classVc_1_1Vector.html">int_v</a> foo = <a class="code" href="classVc_1_1Vector.html#a493fd531cf26bec9f8b40740ab110eec">int_v::IndexesFromZero</a>() + 1; <span class="comment">// e.g. [1, 2, 3, 4] with SSE</span></div>
<div class="line"><a class="code" href="classVc_1_1Vector.html">int_v</a> x;</div>
<div class="line">x = foo.<a class="code" href="classVc_1_1Vector.html#a30fa8a10db5836f2a079df3960878714">shifted</a>( 1); <span class="comment">// [2, 3, 4, 0]</span></div>
<div class="line">x = foo.<a class="code" href="classVc_1_1Vector.html#a30fa8a10db5836f2a079df3960878714">shifted</a>( 2); <span class="comment">// [3, 4, 0, 0]</span></div>
<div class="line">x = foo.<a class="code" href="classVc_1_1Vector.html#a30fa8a10db5836f2a079df3960878714">shifted</a>( 3); <span class="comment">// [4, 0, 0, 0]</span></div>
<div class="line">x = foo.<a class="code" href="classVc_1_1Vector.html#a30fa8a10db5836f2a079df3960878714">shifted</a>( 4); <span class="comment">// [0, 0, 0, 0]</span></div>
<div class="line">x = foo.<a class="code" href="classVc_1_1Vector.html#a30fa8a10db5836f2a079df3960878714">shifted</a>(-1); <span class="comment">// [0, 1, 2, 3]</span></div>
<div class="line">x = foo.<a class="code" href="classVc_1_1Vector.html#a30fa8a10db5836f2a079df3960878714">shifted</a>(-2); <span class="comment">// [0, 0, 1, 2]</span></div>
<div class="line">x = foo.<a class="code" href="classVc_1_1Vector.html#a30fa8a10db5836f2a079df3960878714">shifted</a>(-3); <span class="comment">// [0, 0, 0, 1]</span></div>
<div class="line">x = foo.<a class="code" href="classVc_1_1Vector.html#a30fa8a10db5836f2a079df3960878714">shifted</a>(-4); <span class="comment">// [0, 0, 0, 0]</span></div>
<div class="line"></div>
<div class="line">x = foo.<a class="code" href="classVc_1_1Vector.html#a271c76e6f02b80195b9d277699efc4b0">rotated</a>( 1); <span class="comment">// [2, 3, 4, 1]</span></div>
<div class="line">x = foo.<a class="code" href="classVc_1_1Vector.html#a271c76e6f02b80195b9d277699efc4b0">rotated</a>( 2); <span class="comment">// [3, 4, 1, 2]</span></div>
<div class="line">x = foo.<a class="code" href="classVc_1_1Vector.html#a271c76e6f02b80195b9d277699efc4b0">rotated</a>( 3); <span class="comment">// [4, 1, 2, 3]</span></div>
<div class="line">x = foo.<a class="code" href="classVc_1_1Vector.html#a271c76e6f02b80195b9d277699efc4b0">rotated</a>( 4); <span class="comment">// [1, 2, 3, 4]</span></div>
<div class="line">x = foo.<a class="code" href="classVc_1_1Vector.html#a271c76e6f02b80195b9d277699efc4b0">rotated</a>(-1); <span class="comment">// [4, 1, 2, 3]</span></div>
<div class="line">x = foo.<a class="code" href="classVc_1_1Vector.html#a271c76e6f02b80195b9d277699efc4b0">rotated</a>(-2); <span class="comment">// [3, 4, 1, 2]</span></div>
<div class="line">x = foo.<a class="code" href="classVc_1_1Vector.html#a271c76e6f02b80195b9d277699efc4b0">rotated</a>(-3); <span class="comment">// [2, 3, 4, 1]</span></div>
<div class="line">x = foo.<a class="code" href="classVc_1_1Vector.html#a271c76e6f02b80195b9d277699efc4b0">rotated</a>(-4); <span class="comment">// [1, 2, 3, 4]</span></div>
</div><!-- fragment --><p>These functions are slightly related to the above swizzles. In any case, they are often useful for communication between SIMD lanes or binary decoding operations.</p>
<dl class="section warning"><dt>Warning</dt><dd>Use of these functions leads to less portable code. Consider the scalar implementation where every vector has only one entry. The shift and rotate functions have no useful task to fulfil there and you will almost certainly not get any useful results. It is recommended to add a static_assert for the assumed minimum vector size. </dd></dl>
</div></td></tr>
<tr class="memitem:a30fa8a10db5836f2a079df3960878714"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a30fa8a10db5836f2a079df3960878714"></a>
<a class="el" href="classVc_1_1Vector.html">Vector</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVc_1_1Vector.html#a30fa8a10db5836f2a079df3960878714">shifted</a> (int amount) const </td></tr>
<tr class="memdesc:a30fa8a10db5836f2a079df3960878714"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shift vector entries to the left by <code>amount</code>; shifting in zeros. <br /></td></tr>
<tr class="separator:a30fa8a10db5836f2a079df3960878714"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01728148f46f24cd5a2bf9784006564c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classVc_1_1Vector.html">Vector</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVc_1_1Vector.html#a01728148f46f24cd5a2bf9784006564c">shifted</a> (int amount, <a class="el" href="classVc_1_1Vector.html">Vector</a> shiftIn) const </td></tr>
<tr class="memdesc:a01728148f46f24cd5a2bf9784006564c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shift vector entries to the left by <code>amount</code>; shifting in values from shiftIn (instead of zeros).  <a href="#a01728148f46f24cd5a2bf9784006564c">More...</a><br /></td></tr>
<tr class="separator:a01728148f46f24cd5a2bf9784006564c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a271c76e6f02b80195b9d277699efc4b0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a271c76e6f02b80195b9d277699efc4b0"></a>
<a class="el" href="classVc_1_1Vector.html">Vector</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVc_1_1Vector.html#a271c76e6f02b80195b9d277699efc4b0">rotated</a> (int amount) const </td></tr>
<tr class="memdesc:a271c76e6f02b80195b9d277699efc4b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rotate vector entries to the left by <code>amount</code>. <br /></td></tr>
<tr class="separator:a271c76e6f02b80195b9d277699efc4b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28d45861102129a56e9692f33e958306"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a28d45861102129a56e9692f33e958306"></a>
<a class="el" href="classVc_1_1Vector.html">Vector</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVc_1_1Vector.html#a28d45861102129a56e9692f33e958306">reversed</a> () const </td></tr>
<tr class="memdesc:a28d45861102129a56e9692f33e958306"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a vector with all components reversed. <br /></td></tr>
<tr class="separator:a28d45861102129a56e9692f33e958306"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Apply/Call/Fill Functions</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>There are still many situations where the code needs to switch from SIMD operations to scalar execution. In this case you can, of course rely on operator[]. But there are also a number of functions that can help with common patterns.</p>
<p>The apply functions expect a function that returns a scalar value, i.e. a function of the form "T f(T)". The call functions do not return a value and thus the function passed does not need a return value. The fill functions are used to serially set the entries of the vector from the return values of a function.</p>
<p>Example: </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> foo(<a class="code" href="group__Vectors.html#ga5cf7c5a0dadbbbbcb9b69c5e42ee0528">float_v</a> v) {</div>
<div class="line">  <a class="code" href="group__Vectors.html#ga5cf7c5a0dadbbbbcb9b69c5e42ee0528">float_v</a> logarithm = v.apply(<a class="code" href="group__Math.html#gafb93877e10dc909fbe54120984ac6694">std::log</a>);</div>
<div class="line">  <a class="code" href="group__Vectors.html#ga5cf7c5a0dadbbbbcb9b69c5e42ee0528">float_v</a> exponential = v.apply(<a class="code" href="group__Math.html#ga081a5ebea56b063894eb735e55370d9f">std::exp</a>);</div>
<div class="line">}</div>
</div><!-- fragment --><p>Of course, you can also use lambdas here: </p><div class="fragment"><div class="line"><a class="code" href="group__Vectors.html#ga5cf7c5a0dadbbbbcb9b69c5e42ee0528">float_v</a> power = v.apply([](<span class="keywordtype">float</span> f) { <span class="keywordflow">return</span> std::pow(f, 0.6f); })</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>A functor: this can either be a function or an object that implements operator(). </td></tr>
  </table>
  </dd>
</dl>
</div></td></tr>
<tr class="memitem:a7bbbd599986b37877a01ddb346d7eb6b"><td class="memTemplParams" colspan="2"><a class="anchor" id="a7bbbd599986b37877a01ddb346d7eb6b"></a>
template&lt;typename F &gt; </td></tr>
<tr class="memitem:a7bbbd599986b37877a01ddb346d7eb6b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classVc_1_1Vector.html#a7bbbd599986b37877a01ddb346d7eb6b">callWithValuesSorted</a> (F &amp;&amp;f)</td></tr>
<tr class="memdesc:a7bbbd599986b37877a01ddb346d7eb6b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Call <code>f</code> sequentially, starting with the minimum up to the maximum value. <br /></td></tr>
<tr class="separator:a7bbbd599986b37877a01ddb346d7eb6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98171ab3369060ee406fabbd63938fe7"><td class="memTemplParams" colspan="2"><a class="anchor" id="a98171ab3369060ee406fabbd63938fe7"></a>
template&lt;typename F &gt; </td></tr>
<tr class="memitem:a98171ab3369060ee406fabbd63938fe7"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classVc_1_1Vector.html#a98171ab3369060ee406fabbd63938fe7">call</a> (F &amp;&amp;f) const </td></tr>
<tr class="memdesc:a98171ab3369060ee406fabbd63938fe7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Call <code>f</code> with the scalar entries of the vector. <br /></td></tr>
<tr class="separator:a98171ab3369060ee406fabbd63938fe7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed75ab92a15991525807ca806659a6f1"><td class="memTemplParams" colspan="2"><a class="anchor" id="aed75ab92a15991525807ca806659a6f1"></a>
template&lt;typename F &gt; </td></tr>
<tr class="memitem:aed75ab92a15991525807ca806659a6f1"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classVc_1_1Vector.html#aed75ab92a15991525807ca806659a6f1">call</a> (F &amp;&amp;f, <a class="el" href="classVc_1_1Vector.html#a87ee111bfca7f15829e802bdf47c3b0e">MaskType</a> mask) const </td></tr>
<tr class="memdesc:aed75ab92a15991525807ca806659a6f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">As above, but skip the entries where <code>mask</code> is not set. <br /></td></tr>
<tr class="separator:aed75ab92a15991525807ca806659a6f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a043f073c5952ebd15503becd64fc5c88"><td class="memTemplParams" colspan="2"><a class="anchor" id="a043f073c5952ebd15503becd64fc5c88"></a>
template&lt;typename F &gt; </td></tr>
<tr class="memitem:a043f073c5952ebd15503becd64fc5c88"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classVc_1_1Vector.html">Vector</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classVc_1_1Vector.html#a043f073c5952ebd15503becd64fc5c88">apply</a> (F &amp;&amp;f) const </td></tr>
<tr class="memdesc:a043f073c5952ebd15503becd64fc5c88"><td class="mdescLeft">&#160;</td><td class="mdescRight">Call <code>f</code> on every entry of the vector and return the results as a new vector. <br /></td></tr>
<tr class="separator:a043f073c5952ebd15503becd64fc5c88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b15bb21e39a5111fac25035a46d1dbc"><td class="memTemplParams" colspan="2"><a class="anchor" id="a3b15bb21e39a5111fac25035a46d1dbc"></a>
template&lt;typename F &gt; </td></tr>
<tr class="memitem:a3b15bb21e39a5111fac25035a46d1dbc"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classVc_1_1Vector.html">Vector</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classVc_1_1Vector.html#a3b15bb21e39a5111fac25035a46d1dbc">apply</a> (F &amp;&amp;f, <a class="el" href="classVc_1_1Vector.html#a87ee111bfca7f15829e802bdf47c3b0e">MaskType</a> mask) const </td></tr>
<tr class="memdesc:a3b15bb21e39a5111fac25035a46d1dbc"><td class="mdescLeft">&#160;</td><td class="mdescRight">As above, but skip the entries where <code>mask</code> is not set. <br /></td></tr>
<tr class="separator:a3b15bb21e39a5111fac25035a46d1dbc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8edc8793d6e89447dd5de0d4327679f0"><td class="memTemplParams" colspan="2"><a class="anchor" id="a8edc8793d6e89447dd5de0d4327679f0"></a>
template&lt;typename IndexT &gt; </td></tr>
<tr class="memitem:a8edc8793d6e89447dd5de0d4327679f0"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classVc_1_1Vector.html#a8edc8793d6e89447dd5de0d4327679f0">fill</a> (<a class="el" href="classVc_1_1Vector.html#ae9cb6038cbd15cb0bdc596f5383c2b21">EntryType</a>(&amp;f)(IndexT))</td></tr>
<tr class="memdesc:a8edc8793d6e89447dd5de0d4327679f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fill the vector with the values [f(0), f(1), f(2), ...]. <br /></td></tr>
<tr class="separator:a8edc8793d6e89447dd5de0d4327679f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33560de8b962a95e9036d47ec195f3ab"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a33560de8b962a95e9036d47ec195f3ab"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVc_1_1Vector.html#a33560de8b962a95e9036d47ec195f3ab">fill</a> (<a class="el" href="classVc_1_1Vector.html#ae9cb6038cbd15cb0bdc596f5383c2b21">EntryType</a>(&amp;f)())</td></tr>
<tr class="memdesc:a33560de8b962a95e9036d47ec195f3ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fill the vector with the values [f(), f(), f(), ...]. <br /></td></tr>
<tr class="separator:a33560de8b962a95e9036d47ec195f3ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr><td colspan="2"><div class="groupHeader">new/delete overloads for correct alignment</div></td></tr>
<tr class="memitem:a205ed048fdf5259c2e8e0cb60ee8f719"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a205ed048fdf5259c2e8e0cb60ee8f719"></a>
void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVc_1_1Vector.html#a205ed048fdf5259c2e8e0cb60ee8f719">operator new</a> (size_t <a class="el" href="classVc_1_1Vector.html#a1b5d7e2e663d7997796fd9f72b8af75a">size</a>)</td></tr>
<tr class="memdesc:a205ed048fdf5259c2e8e0cb60ee8f719"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocates correctly aligned memory. <br /></td></tr>
<tr class="separator:a205ed048fdf5259c2e8e0cb60ee8f719"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a32ddebc54410cf59dec423c0b0791b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0a32ddebc54410cf59dec423c0b0791b"></a>
void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVc_1_1Vector.html#a0a32ddebc54410cf59dec423c0b0791b">operator new</a> (size_t, void *p)</td></tr>
<tr class="memdesc:a0a32ddebc54410cf59dec423c0b0791b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>p</code>. <br /></td></tr>
<tr class="separator:a0a32ddebc54410cf59dec423c0b0791b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63ce4f64887b9307317aee5baae6b18f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a63ce4f64887b9307317aee5baae6b18f"></a>
void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVc_1_1Vector.html#a63ce4f64887b9307317aee5baae6b18f">operator new[]</a> (size_t <a class="el" href="classVc_1_1Vector.html#a1b5d7e2e663d7997796fd9f72b8af75a">size</a>)</td></tr>
<tr class="memdesc:a63ce4f64887b9307317aee5baae6b18f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocates correctly aligned memory. <br /></td></tr>
<tr class="separator:a63ce4f64887b9307317aee5baae6b18f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f5a0f061d65c77264411a2914503659"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7f5a0f061d65c77264411a2914503659"></a>
void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVc_1_1Vector.html#a7f5a0f061d65c77264411a2914503659">operator new[]</a> (size_t, void *p)</td></tr>
<tr class="memdesc:a7f5a0f061d65c77264411a2914503659"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>p</code>. <br /></td></tr>
<tr class="separator:a7f5a0f061d65c77264411a2914503659"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22999735d5b1e1cb645614d22f108611"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a22999735d5b1e1cb645614d22f108611"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVc_1_1Vector.html#a22999735d5b1e1cb645614d22f108611">operator delete</a> (void *ptr, size_t)</td></tr>
<tr class="memdesc:a22999735d5b1e1cb645614d22f108611"><td class="mdescLeft">&#160;</td><td class="mdescRight">Frees aligned memory. <br /></td></tr>
<tr class="separator:a22999735d5b1e1cb645614d22f108611"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41d83e8020f1d841b254be6ebeda92d2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a41d83e8020f1d841b254be6ebeda92d2"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVc_1_1Vector.html#a41d83e8020f1d841b254be6ebeda92d2">operator delete</a> (void *, void *)</td></tr>
<tr class="memdesc:a41d83e8020f1d841b254be6ebeda92d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Does nothing. <br /></td></tr>
<tr class="separator:a41d83e8020f1d841b254be6ebeda92d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abefd12c9bd2fa9cd4a27cdabf64b03f8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abefd12c9bd2fa9cd4a27cdabf64b03f8"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVc_1_1Vector.html#abefd12c9bd2fa9cd4a27cdabf64b03f8">operator delete[]</a> (void *ptr, size_t)</td></tr>
<tr class="memdesc:abefd12c9bd2fa9cd4a27cdabf64b03f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Frees aligned memory. <br /></td></tr>
<tr class="separator:abefd12c9bd2fa9cd4a27cdabf64b03f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afea8decef8f286c8d73c89a1a81d4555"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afea8decef8f286c8d73c89a1a81d4555"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVc_1_1Vector.html#afea8decef8f286c8d73c89a1a81d4555">operator delete[]</a> (void *, void *)</td></tr>
<tr class="memdesc:afea8decef8f286c8d73c89a1a81d4555"><td class="mdescLeft">&#160;</td><td class="mdescRight">Does nothing. <br /></td></tr>
<tr class="separator:afea8decef8f286c8d73c89a1a81d4555"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a1b5d7e2e663d7997796fd9f72b8af75a"><td class="memItemLeft" align="right" valign="top">static constexpr size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVc_1_1Vector.html#a1b5d7e2e663d7997796fd9f72b8af75a">size</a> ()</td></tr>
<tr class="memdesc:a1b5d7e2e663d7997796fd9f72b8af75a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of scalar components ( \(\mathcal{W}_\mathtt{T}\)) in a vector of this type.  <a href="#a1b5d7e2e663d7997796fd9f72b8af75a">More...</a><br /></td></tr>
<tr class="separator:a1b5d7e2e663d7997796fd9f72b8af75a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Generators</div></td></tr>
<tr class="memitem:af9c6cd3201b97b6c86d64a3b25e584d7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af9c6cd3201b97b6c86d64a3b25e584d7"></a>
static <a class="el" href="classVc_1_1Vector.html">Vector</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVc_1_1Vector.html#af9c6cd3201b97b6c86d64a3b25e584d7">Zero</a> ()</td></tr>
<tr class="memdesc:af9c6cd3201b97b6c86d64a3b25e584d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a vector with the entries initialized to zero. <br /></td></tr>
<tr class="separator:af9c6cd3201b97b6c86d64a3b25e584d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b767a2e7fd19f79be9616be32128bea"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4b767a2e7fd19f79be9616be32128bea"></a>
static <a class="el" href="classVc_1_1Vector.html">Vector</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVc_1_1Vector.html#a4b767a2e7fd19f79be9616be32128bea">One</a> ()</td></tr>
<tr class="memdesc:a4b767a2e7fd19f79be9616be32128bea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a vector with the entries initialized to one. <br /></td></tr>
<tr class="separator:a4b767a2e7fd19f79be9616be32128bea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a493fd531cf26bec9f8b40740ab110eec"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a493fd531cf26bec9f8b40740ab110eec"></a>
static <a class="el" href="classVc_1_1Vector.html">Vector</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVc_1_1Vector.html#a493fd531cf26bec9f8b40740ab110eec">IndexesFromZero</a> ()</td></tr>
<tr class="memdesc:a493fd531cf26bec9f8b40740ab110eec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a vector with the entries initialized to 0, 1, 2, 3, 4, 5, ... <br /></td></tr>
<tr class="separator:a493fd531cf26bec9f8b40740ab110eec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa7aece82798960b1144c030e4c8f6cc"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classVc_1_1Vector.html">Vector</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVc_1_1Vector.html#aaa7aece82798960b1144c030e4c8f6cc">Random</a> ()</td></tr>
<tr class="memdesc:aaa7aece82798960b1144c030e4c8f6cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a vector with pseudo-random entries.  <a href="#aaa7aece82798960b1144c030e4c8f6cc">More...</a><br /></td></tr>
<tr class="separator:aaa7aece82798960b1144c030e4c8f6cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa971522e6fe26e874ac131bf57990280"><td class="memTemplParams" colspan="2"><a class="anchor" id="aa971522e6fe26e874ac131bf57990280"></a>
template&lt;typename G &gt; </td></tr>
<tr class="memitem:aa971522e6fe26e874ac131bf57990280"><td class="memTemplItemLeft" align="right" valign="top">static <a class="el" href="classVc_1_1Vector.html">Vector</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classVc_1_1Vector.html#aa971522e6fe26e874ac131bf57990280">generate</a> (G gen)</td></tr>
<tr class="memdesc:aa971522e6fe26e874ac131bf57990280"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate a vector object from return values of <code>gen</code> (static variant of <a class="el" href="classVc_1_1Vector.html#a8edc8793d6e89447dd5de0d4327679f0">fill</a>). <br /></td></tr>
<tr class="separator:aa971522e6fe26e874ac131bf57990280"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:a9d80568e435be601eb87ade3966eda21"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9d80568e435be601eb87ade3966eda21"></a>
static constexpr size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVc_1_1Vector.html#a9d80568e435be601eb87ade3966eda21">MemoryAlignment</a> = VectorTraits&lt;T, Abi&gt;::memoryAlignment()</td></tr>
<tr class="memdesc:a9d80568e435be601eb87ade3966eda21"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specifies the alignment requirement for aligned load and store calls for objects of this vector type. <br /></td></tr>
<tr class="separator:a9d80568e435be601eb87ade3966eda21"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Deprecated Members</h2></td></tr>
<tr class="memitem:a879ad9933a419e4e04c8a59cc19a34fe"><td class="memItemLeft" align="right" valign="top">static constexpr size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVc_1_1Vector.html#a879ad9933a419e4e04c8a59cc19a34fe">Size</a> = VectorTraits&lt;T, Abi&gt;::<a class="el" href="classVc_1_1Vector.html#a1b5d7e2e663d7997796fd9f72b8af75a">size</a>()</td></tr>
<tr class="memdesc:a879ad9933a419e4e04c8a59cc19a34fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of scalar components ( \(\mathcal{W}_\mathtt{T}\)) in a vector of this type.  <a href="#a879ad9933a419e4e04c8a59cc19a34fe">More...</a><br /></td></tr>
<tr class="separator:a879ad9933a419e4e04c8a59cc19a34fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a88240e1c8a09315c17854b8f25c154"><td class="memTemplParams" colspan="2">template&lt;typename S1 , typename IT &gt; </td></tr>
<tr class="memitem:a2a88240e1c8a09315c17854b8f25c154"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classVc_1_1Vector.html#a2a88240e1c8a09315c17854b8f25c154">Vector</a> (const S1 *array, const <a class="el" href="classVc_1_1Vector.html#ae9cb6038cbd15cb0bdc596f5383c2b21">EntryType</a> S1::*member1, IT indexes)</td></tr>
<tr class="separator:a2a88240e1c8a09315c17854b8f25c154"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4cd2e6b205aea4ee25173ee3255589dc"><td class="memTemplParams" colspan="2">template&lt;typename S1 , typename IT &gt; </td></tr>
<tr class="memitem:a4cd2e6b205aea4ee25173ee3255589dc"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classVc_1_1Vector.html#a4cd2e6b205aea4ee25173ee3255589dc">Vector</a> (const S1 *array, const <a class="el" href="classVc_1_1Vector.html#ae9cb6038cbd15cb0bdc596f5383c2b21">EntryType</a> S1::*member1, IT indexes, <a class="el" href="classVc_1_1Mask.html">MaskArgument</a> mask)</td></tr>
<tr class="separator:a4cd2e6b205aea4ee25173ee3255589dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c947d1c43cf018c8820a518ba9b1696"><td class="memTemplParams" colspan="2">template&lt;typename S1 , typename S2 , typename IT &gt; </td></tr>
<tr class="memitem:a6c947d1c43cf018c8820a518ba9b1696"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classVc_1_1Vector.html#a6c947d1c43cf018c8820a518ba9b1696">Vector</a> (const S1 *array, const S2 S1::*member1, const <a class="el" href="classVc_1_1Vector.html#ae9cb6038cbd15cb0bdc596f5383c2b21">EntryType</a> S2::*member2, IT indexes)</td></tr>
<tr class="separator:a6c947d1c43cf018c8820a518ba9b1696"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6fe52ad84347e804492ec3c2107e5955"><td class="memTemplParams" colspan="2">template&lt;typename S1 , typename S2 , typename IT &gt; </td></tr>
<tr class="memitem:a6fe52ad84347e804492ec3c2107e5955"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classVc_1_1Vector.html#a6fe52ad84347e804492ec3c2107e5955">Vector</a> (const S1 *array, const S2 S1::*member1, const <a class="el" href="classVc_1_1Vector.html#ae9cb6038cbd15cb0bdc596f5383c2b21">EntryType</a> S2::*member2, IT indexes, <a class="el" href="classVc_1_1Mask.html">MaskArgument</a> mask)</td></tr>
<tr class="separator:a6fe52ad84347e804492ec3c2107e5955"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c5483ca134f9a288a89b2fa76115c82"><td class="memTemplParams" colspan="2">template&lt;typename S1 , typename IT1 , typename IT2 &gt; </td></tr>
<tr class="memitem:a1c5483ca134f9a288a89b2fa76115c82"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classVc_1_1Vector.html#a1c5483ca134f9a288a89b2fa76115c82">Vector</a> (const S1 *array, const <a class="el" href="classVc_1_1Vector.html#ae9cb6038cbd15cb0bdc596f5383c2b21">EntryType</a> *const S1::*ptrMember1, IT1 outerIndexes, IT2 innerIndexes)</td></tr>
<tr class="separator:a1c5483ca134f9a288a89b2fa76115c82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:addf0bbf9ea1c0395cdd636c5b3964a8c"><td class="memTemplParams" colspan="2">template&lt;typename S1 , typename IT1 , typename IT2 &gt; </td></tr>
<tr class="memitem:addf0bbf9ea1c0395cdd636c5b3964a8c"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classVc_1_1Vector.html#addf0bbf9ea1c0395cdd636c5b3964a8c">Vector</a> (const S1 *array, const <a class="el" href="classVc_1_1Vector.html#ae9cb6038cbd15cb0bdc596f5383c2b21">EntryType</a> *const S1::*ptrMember1, IT1 outerIndexes, IT2 innerIndexes, <a class="el" href="classVc_1_1Mask.html">MaskArgument</a> mask)</td></tr>
<tr class="separator:addf0bbf9ea1c0395cdd636c5b3964a8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74678fe3f7c4925bd19b5674fcac3ec2"><td class="memTemplParams" colspan="2">template&lt;typename S1 , typename IT &gt; </td></tr>
<tr class="memitem:a74678fe3f7c4925bd19b5674fcac3ec2"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classVc_1_1Vector.html#a74678fe3f7c4925bd19b5674fcac3ec2">gather</a> (const S1 *array, const <a class="el" href="classVc_1_1Vector.html#ae9cb6038cbd15cb0bdc596f5383c2b21">EntryType</a> S1::*member1, IT indexes)</td></tr>
<tr class="separator:a74678fe3f7c4925bd19b5674fcac3ec2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41aec2586ff985e863c78803d11d2306"><td class="memTemplParams" colspan="2">template&lt;typename S1 , typename IT &gt; </td></tr>
<tr class="memitem:a41aec2586ff985e863c78803d11d2306"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classVc_1_1Vector.html#a41aec2586ff985e863c78803d11d2306">gather</a> (const S1 *array, const <a class="el" href="classVc_1_1Vector.html#ae9cb6038cbd15cb0bdc596f5383c2b21">EntryType</a> S1::*member1, IT indexes, <a class="el" href="classVc_1_1Mask.html">MaskArgument</a> mask)</td></tr>
<tr class="separator:a41aec2586ff985e863c78803d11d2306"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7e0e744bbf8112abc60707ec35782ac"><td class="memTemplParams" colspan="2">template&lt;typename S1 , typename S2 , typename IT &gt; </td></tr>
<tr class="memitem:ab7e0e744bbf8112abc60707ec35782ac"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classVc_1_1Vector.html#ab7e0e744bbf8112abc60707ec35782ac">gather</a> (const S1 *array, const S2 S1::*member1, const <a class="el" href="classVc_1_1Vector.html#ae9cb6038cbd15cb0bdc596f5383c2b21">EntryType</a> S2::*member2, IT indexes)</td></tr>
<tr class="separator:ab7e0e744bbf8112abc60707ec35782ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a0ce77d4761ff3d4c346f44b02d5168"><td class="memTemplParams" colspan="2">template&lt;typename S1 , typename S2 , typename IT &gt; </td></tr>
<tr class="memitem:a0a0ce77d4761ff3d4c346f44b02d5168"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classVc_1_1Vector.html#a0a0ce77d4761ff3d4c346f44b02d5168">gather</a> (const S1 *array, const S2 S1::*member1, const <a class="el" href="classVc_1_1Vector.html#ae9cb6038cbd15cb0bdc596f5383c2b21">EntryType</a> S2::*member2, IT indexes, <a class="el" href="classVc_1_1Mask.html">MaskArgument</a> mask)</td></tr>
<tr class="separator:a0a0ce77d4761ff3d4c346f44b02d5168"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a851eee82fe0a753a26929a1a6982f84a"><td class="memTemplParams" colspan="2">template&lt;typename S1 , typename IT1 , typename IT2 &gt; </td></tr>
<tr class="memitem:a851eee82fe0a753a26929a1a6982f84a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classVc_1_1Vector.html#a851eee82fe0a753a26929a1a6982f84a">gather</a> (const S1 *array, const <a class="el" href="classVc_1_1Vector.html#ae9cb6038cbd15cb0bdc596f5383c2b21">EntryType</a> *const S1::*ptrMember1, IT1 outerIndexes, IT2 innerIndexes)</td></tr>
<tr class="separator:a851eee82fe0a753a26929a1a6982f84a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af179ee076927fb7ed38661b34e70b5ee"><td class="memTemplParams" colspan="2">template&lt;typename S1 , typename IT1 , typename IT2 &gt; </td></tr>
<tr class="memitem:af179ee076927fb7ed38661b34e70b5ee"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classVc_1_1Vector.html#af179ee076927fb7ed38661b34e70b5ee">gather</a> (const S1 *array, const <a class="el" href="classVc_1_1Vector.html#ae9cb6038cbd15cb0bdc596f5383c2b21">EntryType</a> *const S1::*ptrMember1, IT1 outerIndexes, IT2 innerIndexes, <a class="el" href="classVc_1_1Mask.html">MaskArgument</a> mask)</td></tr>
<tr class="separator:af179ee076927fb7ed38661b34e70b5ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af57dd65795bb03a652b52bdc59152974"><td class="memTemplParams" colspan="2">template&lt;typename S1 , typename IT &gt; </td></tr>
<tr class="memitem:af57dd65795bb03a652b52bdc59152974"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classVc_1_1Vector.html#af57dd65795bb03a652b52bdc59152974">scatter</a> (S1 *array, <a class="el" href="classVc_1_1Vector.html#ae9cb6038cbd15cb0bdc596f5383c2b21">EntryType</a> S1::*member1, IT indexes) const </td></tr>
<tr class="separator:af57dd65795bb03a652b52bdc59152974"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac767f28c920a44d0f732505ec7bb9865"><td class="memTemplParams" colspan="2">template&lt;typename S1 , typename IT &gt; </td></tr>
<tr class="memitem:ac767f28c920a44d0f732505ec7bb9865"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classVc_1_1Vector.html#ac767f28c920a44d0f732505ec7bb9865">scatter</a> (S1 *array, <a class="el" href="classVc_1_1Vector.html#ae9cb6038cbd15cb0bdc596f5383c2b21">EntryType</a> S1::*member1, IT indexes, <a class="el" href="classVc_1_1Mask.html">MaskArgument</a> mask) const </td></tr>
<tr class="separator:ac767f28c920a44d0f732505ec7bb9865"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90951e0b3ea5b221cd6a71734d5ce93d"><td class="memTemplParams" colspan="2">template&lt;typename S1 , typename S2 , typename IT &gt; </td></tr>
<tr class="memitem:a90951e0b3ea5b221cd6a71734d5ce93d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classVc_1_1Vector.html#a90951e0b3ea5b221cd6a71734d5ce93d">scatter</a> (S1 *array, S2 S1::*member1, <a class="el" href="classVc_1_1Vector.html#ae9cb6038cbd15cb0bdc596f5383c2b21">EntryType</a> S2::*member2, IT indexes) const </td></tr>
<tr class="separator:a90951e0b3ea5b221cd6a71734d5ce93d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a299631364e9c623ac9597f31801bd927"><td class="memTemplParams" colspan="2">template&lt;typename S1 , typename S2 , typename IT &gt; </td></tr>
<tr class="memitem:a299631364e9c623ac9597f31801bd927"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classVc_1_1Vector.html#a299631364e9c623ac9597f31801bd927">scatter</a> (S1 *array, S2 S1::*member1, <a class="el" href="classVc_1_1Vector.html#ae9cb6038cbd15cb0bdc596f5383c2b21">EntryType</a> S2::*member2, IT indexes, <a class="el" href="classVc_1_1Mask.html">MaskArgument</a> mask) const </td></tr>
<tr class="separator:a299631364e9c623ac9597f31801bd927"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a811c74efda5768b9decec85dce246173"><td class="memTemplParams" colspan="2">template&lt;typename S1 , typename IT1 , typename IT2 &gt; </td></tr>
<tr class="memitem:a811c74efda5768b9decec85dce246173"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classVc_1_1Vector.html#a811c74efda5768b9decec85dce246173">scatter</a> (S1 *array, <a class="el" href="classVc_1_1Vector.html#ae9cb6038cbd15cb0bdc596f5383c2b21">EntryType</a> *S1::*ptrMember1, IT1 outerIndexes, IT2 innerIndexes) const </td></tr>
<tr class="separator:a811c74efda5768b9decec85dce246173"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab145b30f47b57e36d08592e2ab454d6f"><td class="memTemplParams" colspan="2">template&lt;typename S1 , typename IT1 , typename IT2 &gt; </td></tr>
<tr class="memitem:ab145b30f47b57e36d08592e2ab454d6f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classVc_1_1Vector.html#ab145b30f47b57e36d08592e2ab454d6f">scatter</a> (S1 *array, <a class="el" href="classVc_1_1Vector.html#ae9cb6038cbd15cb0bdc596f5383c2b21">EntryType</a> *S1::*ptrMember1, IT1 outerIndexes, IT2 innerIndexes, <a class="el" href="classVc_1_1Mask.html">MaskArgument</a> mask) const </td></tr>
<tr class="separator:ab145b30f47b57e36d08592e2ab454d6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc65cca01d680f8e70f8dd626fd07953"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classVc_1_1Vector.html">Vector</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVc_1_1Vector.html#afc65cca01d680f8e70f8dd626fd07953">exponent</a> () const </td></tr>
<tr class="memdesc:afc65cca01d680f8e70f8dd626fd07953"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the exponents of the floating-point values in the vector.  <a href="#afc65cca01d680f8e70f8dd626fd07953">More...</a><br /></td></tr>
<tr class="separator:afc65cca01d680f8e70f8dd626fd07953"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae69d39745f8c88369041a693f6e5d0b7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classVc_1_1Vector.html#a87ee111bfca7f15829e802bdf47c3b0e">MaskType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVc_1_1Vector.html#ae69d39745f8c88369041a693f6e5d0b7">isNegative</a> () const </td></tr>
<tr class="memdesc:ae69d39745f8c88369041a693f6e5d0b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether a value is negative.  <a href="#ae69d39745f8c88369041a693f6e5d0b7">More...</a><br /></td></tr>
<tr class="separator:ae69d39745f8c88369041a693f6e5d0b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7d590c16931b1f6b0a834c6d3f6ca36"><td class="memTemplParams" colspan="2">template&lt;typename V2 &gt; </td></tr>
<tr class="memitem:af7d590c16931b1f6b0a834c6d3f6ca36"><td class="memTemplItemLeft" align="right" valign="top">V2&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classVc_1_1Vector.html#af7d590c16931b1f6b0a834c6d3f6ca36">staticCast</a> () const </td></tr>
<tr class="memdesc:af7d590c16931b1f6b0a834c6d3f6ca36"><td class="mdescLeft">&#160;</td><td class="mdescRight">Casts the current object to <code>V2</code>.  <a href="#af7d590c16931b1f6b0a834c6d3f6ca36">More...</a><br /></td></tr>
<tr class="separator:af7d590c16931b1f6b0a834c6d3f6ca36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15c83c63439def0bc06102c4885ac03f"><td class="memTemplParams" colspan="2">template&lt;typename V2 &gt; </td></tr>
<tr class="memitem:a15c83c63439def0bc06102c4885ac03f"><td class="memTemplItemLeft" align="right" valign="top">V2&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classVc_1_1Vector.html#a15c83c63439def0bc06102c4885ac03f">reinterpretCast</a> () const </td></tr>
<tr class="memdesc:a15c83c63439def0bc06102c4885ac03f"><td class="mdescLeft">&#160;</td><td class="mdescRight">reinterpret_cast the vector components to construct a vector of type <code>V2</code>.  <a href="#a15c83c63439def0bc06102c4885ac03f">More...</a><br /></td></tr>
<tr class="separator:a15c83c63439def0bc06102c4885ac03f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2cf4cf04978c7d21c69a671412dcd181"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classVc_1_1Vector.html">Vector</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVc_1_1Vector.html#a2cf4cf04978c7d21c69a671412dcd181">copySign</a> (<a class="el" href="classVc_1_1Vector.html">Vector</a> reference) const </td></tr>
<tr class="memdesc:a2cf4cf04978c7d21c69a671412dcd181"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies the signs of the components of <code>reference</code> to the components of the current vector, returning the result.  <a href="#a2cf4cf04978c7d21c69a671412dcd181">More...</a><br /></td></tr>
<tr class="separator:a2cf4cf04978c7d21c69a671412dcd181"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Member Typedef Documentation</h2>
<a class="anchor" id="af58a233cf0cdf62369686dd5798bd589"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classVc_1_1Vector.html#af58a233cf0cdf62369686dd5798bd589">value_type</a> =  <a class="el" href="classVc_1_1Vector.html#ae9cb6038cbd15cb0bdc596f5383c2b21">EntryType</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The type of the entries in the vector. </p>

<p>Definition at line <a class="el" href="common_2vector_8h_source.html#l00152">152</a> of file <a class="el" href="common_2vector_8h_source.html">vector.h</a>.</p>

</div>
</div>
<a class="anchor" id="abffe464ff20f5933e5a50b699555fa5f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classVc_1_1Vector.html#abffe464ff20f5933e5a50b699555fa5f">mask_type</a> =  <a class="el" href="classVc_1_1Vector.html#a87ee111bfca7f15829e802bdf47c3b0e">MaskType</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The type of the mask used for masked operations and returned from comparisons. </p>

<p>Definition at line <a class="el" href="common_2vector_8h_source.html#l00167">167</a> of file <a class="el" href="common_2vector_8h_source.html">vector.h</a>.</p>

</div>
</div>
<a class="anchor" id="a2eaac791c05f06627d44f9438059b1ab"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classVc_1_1Vector.html#a2eaac791c05f06627d44f9438059b1ab">index_type</a> =  <a class="el" href="classVc_1_1Vector.html#a435ebd80eab40f6a9a311106fb234b82">IndexType</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The type of the vector used for indexes in gather and scatter operations. </p>

<p>Definition at line <a class="el" href="common_2vector_8h_source.html#l00175">175</a> of file <a class="el" href="common_2vector_8h_source.html">vector.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="aba83f7828d95b601500471996fc8c3c0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVc_1_1Vector.html">Vector</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct a zero-initialized vector object. </p>
<p>This constructor follows the behavior of the underlying arithmetic type <code>T</code> in that the expression <code>T()</code> zero-initializes the object. On the other hand the variable <code>x</code> in <code>T x;</code> is uninitialized. Since, for class types, both expressions call the default constructor <code><a class="el" href="classVc_1_1Vector.html" title="The main vector class for expressing data parallelism. ">Vector</a>&lt;T&gt; x</code> must zero-initialize <code>x</code> as well. </p>

</div>
</div>
<a class="anchor" id="a4b959c60986675489b915cd33ffa1a65"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVc_1_1Vector.html">Vector</a> </td>
          <td>(</td>
          <td class="paramtype">VectorSpecialInitializerZero&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct a vector with the entries initialized to zero. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__Utilities.html#gad24df8f04b4b68f7e992aeb8b449cdf2" title="The special object Vc::Zero can be used to construct Vector and Mask objects initialized to zero/fals...">Vc::Zero</a>, <a class="el" href="classVc_1_1Vector.html#af9c6cd3201b97b6c86d64a3b25e584d7" title="Returns a vector with the entries initialized to zero. ">Zero()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ac6faca3e9ae02f4e213bad11cb860e20"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVc_1_1Vector.html">Vector</a> </td>
          <td>(</td>
          <td class="paramtype">VectorSpecialInitializerOne&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct a vector with the entries initialized to one. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__Utilities.html#ga7dc0e380f66c4c791b7bf95df154b3c6" title="The special object Vc::One can be used to construct Vector and Mask objects initialized to one/true...">Vc::One</a>, <a class="el" href="classVc_1_1Vector.html#a4b767a2e7fd19f79be9616be32128bea" title="Returns a vector with the entries initialized to one. ">One()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a9c5bdbbb09e1851bcb9b35b286c76753"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVc_1_1Vector.html">Vector</a> </td>
          <td>(</td>
          <td class="paramtype">VectorSpecialInitializerIndexesFromZero&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct a vector with the entries initialized to 0, 1, 2, 3, 4, 5, ... </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__Utilities.html#ga2fc610927782c03b1049f2898b2e5821" title="The special object Vc::IndexesFromZero can be used to construct Vector objects initialized to values ...">Vc::IndexesFromZero</a>, <a class="el" href="classVc_1_1Vector.html#a493fd531cf26bec9f8b40740ab110eec" title="Returns a vector with the entries initialized to 0, 1, 2, 3, 4, 5, ... ">IndexesFromZero()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a7e363c9b2d525293cfb1656e1498e796"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVc_1_1Vector.html">Vector</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classVc_1_1Vector.html#ae9cb6038cbd15cb0bdc596f5383c2b21">EntryType</a>&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Broadcast Constructor. </p>
<p>Constructs a vector with all entries of the vector filled with the given value.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>The scalar value to broadcast to all entries of the constructed vector. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa5788937fe94e616e4587fff8343de53"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVc_1_1Vector.html">Vector</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classVc_1_1Vector.html#ae9cb6038cbd15cb0bdc596f5383c2b21">EntryType</a> *&#160;</td>
          <td class="paramname"><em>mem</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct a vector from loading its entries from the array at <code>mem</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mem</td><td>A pointer to data. The pointer must not be aligned on a MemoryAlignment boundary unless you add the <a class="el" href="group__Utilities.html#ga9e53bd74b9a47cb8f16bf12018c3670e" title="Use this object for a flags parameter to request aligned loads and stores. ">Vc::Aligned</a> flag as a second argument. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="common_2vector_8h_source.html#l00037">37</a> of file <a class="el" href="common_2vector_8h_source.html">vector.h</a>.</p>

</div>
</div>
<a class="anchor" id="ae1c0a25236112f0bdf66d4bafd50d308"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVc_1_1Vector.html">Vector</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classVc_1_1Vector.html#ae9cb6038cbd15cb0bdc596f5383c2b21">EntryType</a> *&#160;</td>
          <td class="paramname"><em>mem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Flags&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct a vector from loading its entries from the array at <code>mem</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mem</td><td>A pointer to data. If <code>flags</code> contains the <a class="el" href="group__Utilities.html#ga9e53bd74b9a47cb8f16bf12018c3670e" title="Use this object for a flags parameter to request aligned loads and stores. ">Vc::Aligned</a> flag, the pointer must be aligned on a MemoryAlignment boundary. </td></tr>
    <tr><td class="paramname">flags</td><td>A (combination of) flag object(s), such as <a class="el" href="group__Utilities.html#ga9e53bd74b9a47cb8f16bf12018c3670e" title="Use this object for a flags parameter to request aligned loads and stores. ">Vc::Aligned</a>, <a class="el" href="group__Utilities.html#gadc83bcfec8f15d1d02fb53baa3f38185" title="Use this object for a flags parameter to request streaming loads and stores. ">Vc::Streaming</a>, <a class="el" href="group__Utilities.html#ga91774bc3f3fc00d22deff300919d811c" title="Use this object for a flags parameter to request unaligned loads and stores. ">Vc::Unaligned</a>, and/or <a class="el" href="group__Utilities.html#ga3bed7ba639e9ef78c79421c801b43e59" title="Use this object for a flags parameter to request default software prefetches to be emitted...">Vc::PrefetchDefault</a>. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="common_2vector_8h_source.html#l00050">50</a> of file <a class="el" href="common_2vector_8h_source.html">vector.h</a>.</p>

</div>
</div>
<a class="anchor" id="a2a88240e1c8a09315c17854b8f25c154"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVc_1_1Vector.html">Vector</a> </td>
          <td>(</td>
          <td class="paramtype">const S1 *&#160;</td>
          <td class="paramname"><em>array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classVc_1_1Vector.html#ae9cb6038cbd15cb0bdc596f5383c2b21">EntryType</a> S1::*&#160;</td>
          <td class="paramname"><em>member1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IT&#160;</td>
          <td class="paramname"><em>indexes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000058">Deprecated:</a></b></dt><dd>Use Vc::array or <a class="el" href="group__Utilities.html#gac1ffd8b29c356abdbb821a7854c53b07" title="An adapted std::vector container with an additional subscript operator which implements gather and sc...">Vc::vector</a> subscripting instead.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">array</td><td>A pointer into memory (without alignment restrictions). </td></tr>
    <tr><td class="paramname">member1</td><td>If <code>array</code> points to a struct, <code>member1</code> determines the member in the struct to be read. Thus the offsets in <code>indexes</code> are relative to the <code>array</code> and not to the size of the gathered type (i.e. array[i].*member1 is accessed instead of (&amp;(array-&gt;*member1))[i]) </td></tr>
    <tr><td class="paramname">indexes</td><td>Determines the offsets into <code>array</code> where the values are gathered from/scattered to. The type of indexes can either be an integer vector or a type that supports operator[] access. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="common_2vector_8h_source.html#l00236">236</a> of file <a class="el" href="common_2vector_8h_source.html">vector.h</a>.</p>

</div>
</div>
<a class="anchor" id="a4cd2e6b205aea4ee25173ee3255589dc"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVc_1_1Vector.html">Vector</a> </td>
          <td>(</td>
          <td class="paramtype">const S1 *&#160;</td>
          <td class="paramname"><em>array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classVc_1_1Vector.html#ae9cb6038cbd15cb0bdc596f5383c2b21">EntryType</a> S1::*&#160;</td>
          <td class="paramname"><em>member1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IT&#160;</td>
          <td class="paramname"><em>indexes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classVc_1_1Mask.html">MaskArgument</a>&#160;</td>
          <td class="paramname"><em>mask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000059">Deprecated:</a></b></dt><dd>Use Vc::array or <a class="el" href="group__Utilities.html#gac1ffd8b29c356abdbb821a7854c53b07" title="An adapted std::vector container with an additional subscript operator which implements gather and sc...">Vc::vector</a> subscripting instead.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">array</td><td>A pointer into memory (without alignment restrictions). </td></tr>
    <tr><td class="paramname">member1</td><td>If <code>array</code> points to a struct, <code>member1</code> determines the member in the struct to be read. Thus the offsets in <code>indexes</code> are relative to the <code>array</code> and not to the size of the gathered type (i.e. array[i].*member1 is accessed instead of (&amp;(array-&gt;*member1))[i]) </td></tr>
    <tr><td class="paramname">indexes</td><td>Determines the offsets into <code>array</code> where the values are gathered from/scattered to. The type of indexes can either be an integer vector or a type that supports operator[] access. </td></tr>
    <tr><td class="paramname">mask</td><td>If a mask is given only the active entries will be gathered/scattered. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="common_2vector_8h_source.html#l00260">260</a> of file <a class="el" href="common_2vector_8h_source.html">vector.h</a>.</p>

</div>
</div>
<a class="anchor" id="a6c947d1c43cf018c8820a518ba9b1696"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVc_1_1Vector.html">Vector</a> </td>
          <td>(</td>
          <td class="paramtype">const S1 *&#160;</td>
          <td class="paramname"><em>array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const S2 S1::*&#160;</td>
          <td class="paramname"><em>member1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classVc_1_1Vector.html#ae9cb6038cbd15cb0bdc596f5383c2b21">EntryType</a> S2::*&#160;</td>
          <td class="paramname"><em>member2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IT&#160;</td>
          <td class="paramname"><em>indexes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000060">Deprecated:</a></b></dt><dd>Use Vc::array or <a class="el" href="group__Utilities.html#gac1ffd8b29c356abdbb821a7854c53b07" title="An adapted std::vector container with an additional subscript operator which implements gather and sc...">Vc::vector</a> subscripting instead.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">array</td><td>A pointer into memory (without alignment restrictions). </td></tr>
    <tr><td class="paramname">member1</td><td>If <code>array</code> points to a struct, <code>member1</code> determines the member in the struct to be read. Thus the offsets in <code>indexes</code> are relative to the <code>array</code> and not to the size of the gathered type (i.e. array[i].*member1 is accessed instead of (&amp;(array-&gt;*member1))[i]) </td></tr>
    <tr><td class="paramname">member2</td><td>If <code>member1</code> is a struct then <code>member2</code> selects the member to be read from that struct (i.e. array[i].*member1.*member2 is read). </td></tr>
    <tr><td class="paramname">indexes</td><td>Determines the offsets into <code>array</code> where the values are gathered from/scattered to. The type of indexes can either be an integer vector or a type that supports operator[] access. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="common_2vector_8h_source.html#l00286">286</a> of file <a class="el" href="common_2vector_8h_source.html">vector.h</a>.</p>

</div>
</div>
<a class="anchor" id="a6fe52ad84347e804492ec3c2107e5955"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVc_1_1Vector.html">Vector</a> </td>
          <td>(</td>
          <td class="paramtype">const S1 *&#160;</td>
          <td class="paramname"><em>array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const S2 S1::*&#160;</td>
          <td class="paramname"><em>member1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classVc_1_1Vector.html#ae9cb6038cbd15cb0bdc596f5383c2b21">EntryType</a> S2::*&#160;</td>
          <td class="paramname"><em>member2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IT&#160;</td>
          <td class="paramname"><em>indexes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classVc_1_1Mask.html">MaskArgument</a>&#160;</td>
          <td class="paramname"><em>mask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000061">Deprecated:</a></b></dt><dd>Use Vc::array or <a class="el" href="group__Utilities.html#gac1ffd8b29c356abdbb821a7854c53b07" title="An adapted std::vector container with an additional subscript operator which implements gather and sc...">Vc::vector</a> subscripting instead.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">array</td><td>A pointer into memory (without alignment restrictions). </td></tr>
    <tr><td class="paramname">member1</td><td>If <code>array</code> points to a struct, <code>member1</code> determines the member in the struct to be read. Thus the offsets in <code>indexes</code> are relative to the <code>array</code> and not to the size of the gathered type (i.e. array[i].*member1 is accessed instead of (&amp;(array-&gt;*member1))[i]) </td></tr>
    <tr><td class="paramname">member2</td><td>If <code>member1</code> is a struct then <code>member2</code> selects the member to be read from that struct (i.e. array[i].*member1.*member2 is read). </td></tr>
    <tr><td class="paramname">indexes</td><td>Determines the offsets into <code>array</code> where the values are gathered from/scattered to. The type of indexes can either be an integer vector or a type that supports operator[] access. </td></tr>
    <tr><td class="paramname">mask</td><td>If a mask is given only the active entries will be gathered/scattered. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="common_2vector_8h_source.html#l00313">313</a> of file <a class="el" href="common_2vector_8h_source.html">vector.h</a>.</p>

</div>
</div>
<a class="anchor" id="a1c5483ca134f9a288a89b2fa76115c82"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVc_1_1Vector.html">Vector</a> </td>
          <td>(</td>
          <td class="paramtype">const S1 *&#160;</td>
          <td class="paramname"><em>array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classVc_1_1Vector.html#ae9cb6038cbd15cb0bdc596f5383c2b21">EntryType</a> *const S1::*&#160;</td>
          <td class="paramname"><em>ptrMember1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IT1&#160;</td>
          <td class="paramname"><em>outerIndexes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IT2&#160;</td>
          <td class="paramname"><em>innerIndexes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000062">Deprecated:</a></b></dt><dd>Use Vc::array or <a class="el" href="group__Utilities.html#gac1ffd8b29c356abdbb821a7854c53b07" title="An adapted std::vector container with an additional subscript operator which implements gather and sc...">Vc::vector</a> subscripting instead.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">array</td><td>A pointer into memory (without alignment restrictions). </td></tr>
    <tr><td class="paramname">ptrMember1</td><td>If <code>array</code> points to a struct, <code>member1</code> determines the member in the struct to be read. Thus the offsets in <code>indexes</code> are relative to the <code>array</code> and not to the size of the gathered type (i.e. array[i].*member1 is accessed instead of (&amp;(array-&gt;*member1))[i]) </td></tr>
    <tr><td class="paramname">outerIndexes</td><td></td></tr>
    <tr><td class="paramname">innerIndexes</td><td></td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="common_2vector_8h_source.html#l00338">338</a> of file <a class="el" href="common_2vector_8h_source.html">vector.h</a>.</p>

</div>
</div>
<a class="anchor" id="addf0bbf9ea1c0395cdd636c5b3964a8c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVc_1_1Vector.html">Vector</a> </td>
          <td>(</td>
          <td class="paramtype">const S1 *&#160;</td>
          <td class="paramname"><em>array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classVc_1_1Vector.html#ae9cb6038cbd15cb0bdc596f5383c2b21">EntryType</a> *const S1::*&#160;</td>
          <td class="paramname"><em>ptrMember1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IT1&#160;</td>
          <td class="paramname"><em>outerIndexes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IT2&#160;</td>
          <td class="paramname"><em>innerIndexes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classVc_1_1Mask.html">MaskArgument</a>&#160;</td>
          <td class="paramname"><em>mask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000063">Deprecated:</a></b></dt><dd>Use Vc::array or <a class="el" href="group__Utilities.html#gac1ffd8b29c356abdbb821a7854c53b07" title="An adapted std::vector container with an additional subscript operator which implements gather and sc...">Vc::vector</a> subscripting instead.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">array</td><td>A pointer into memory (without alignment restrictions). </td></tr>
    <tr><td class="paramname">ptrMember1</td><td>If <code>array</code> points to a struct, <code>member1</code> determines the member in the struct to be read. Thus the offsets in <code>indexes</code> are relative to the <code>array</code> and not to the size of the gathered type (i.e. array[i].*member1 is accessed instead of (&amp;(array-&gt;*member1))[i]) </td></tr>
    <tr><td class="paramname">outerIndexes</td><td></td></tr>
    <tr><td class="paramname">innerIndexes</td><td></td></tr>
    <tr><td class="paramname">mask</td><td>If a mask is given only the active entries will be gathered/scattered. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="common_2vector_8h_source.html#l00362">362</a> of file <a class="el" href="common_2vector_8h_source.html">vector.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a1b5d7e2e663d7997796fd9f72b8af75a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr size_t size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of scalar components ( \(\mathcal{W}_\mathtt{T}\)) in a vector of this type. </p>
<p>The size of the vector. I.e. the number of scalar entries in the vector. Do not make any assumptions about the size of vectors. If you need vectors of <code>float</code> and <code>int</code> types use <a class="el" href="classVc_1_1Vector.html#a435ebd80eab40f6a9a311106fb234b82" title="The type of the vector used for indexes in gather and scatter operations. ">Vector::IndexType</a> or <a class="el" href="classVc_1_1SimdArray.html" title="Data-parallel arithmetic type with user-defined number of elements. ">SimdArray</a>.</p>
<p>You can easily use if clauses to compare <a class="el" href="classVc_1_1Vector.html" title="The main vector class for expressing data parallelism. ">Vector</a> sizes. The compiler can statically evaluate and fully optimize dead code away (very much like #ifdef, but with syntax checking).</p>
<dl class="section return"><dt>Returns</dt><dd>The number of components (i.e. \(\mathcal{W}_\mathtt{T}\)) objects of this vector type store and manipulate. </dd></dl>

<p>Definition at line <a class="el" href="common_2vector_8h_source.html#l00138">138</a> of file <a class="el" href="common_2vector_8h_source.html">vector.h</a>.</p>

</div>
</div>
<a class="anchor" id="aaa7aece82798960b1144c030e4c8f6cc"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classVc_1_1Vector.html">Vector</a> Random </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a vector with pseudo-random entries. </p>
<p>Currently the state of the random number generator cannot be modified and starts off with the same state. Thus you will get the same sequence of numbers for the same sequence of calls.</p>
<dl class="section return"><dt>Returns</dt><dd>a new random vector. Floating-point values will be in the 0-1 range. Integers will use the full range the integer representation allows.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function may use a very small amount of state and thus will be a weak random number generator. </dd></dl>

</div>
</div>
<a class="anchor" id="ae40a8b2e28c176cecd1c859666cfcc6c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void load </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classVc_1_1Vector.html#ae9cb6038cbd15cb0bdc596f5383c2b21">EntryType</a> *&#160;</td>
          <td class="paramname"><em>mem</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Load the vector entries from <code>mem</code>, overwriting the previous values. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mem</td><td>A pointer to data. The pointer must not be aligned on a MemoryAlignment boundary unless you add the <a class="el" href="group__Utilities.html#ga9e53bd74b9a47cb8f16bf12018c3670e" title="Use this object for a flags parameter to request aligned loads and stores. ">Vc::Aligned</a> flag as a second argument. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="common_2vector_8h_source.html#l00073">73</a> of file <a class="el" href="common_2vector_8h_source.html">vector.h</a>.</p>

</div>
</div>
<a class="anchor" id="a7696ba25b9a87a220ee33c0ccdd2949b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enable_if&lt;Traits::is_load_store_flag&lt;Flags&gt;::value, void&gt; load </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classVc_1_1Vector.html#ae9cb6038cbd15cb0bdc596f5383c2b21">EntryType</a> *&#160;</td>
          <td class="paramname"><em>mem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Flags&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Load the vector entries from <code>mem</code>, overwriting the previous values. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mem</td><td>A pointer to data. If <code>flags</code> contains the <a class="el" href="group__Utilities.html#ga9e53bd74b9a47cb8f16bf12018c3670e" title="Use this object for a flags parameter to request aligned loads and stores. ">Vc::Aligned</a> flag, the pointer must be aligned on a MemoryAlignment boundary. </td></tr>
    <tr><td class="paramname">flags</td><td>A (combination of) flag object(s), such as <a class="el" href="group__Utilities.html#ga9e53bd74b9a47cb8f16bf12018c3670e" title="Use this object for a flags parameter to request aligned loads and stores. ">Vc::Aligned</a>, <a class="el" href="group__Utilities.html#gadc83bcfec8f15d1d02fb53baa3f38185" title="Use this object for a flags parameter to request streaming loads and stores. ">Vc::Streaming</a>, <a class="el" href="group__Utilities.html#ga91774bc3f3fc00d22deff300919d811c" title="Use this object for a flags parameter to request unaligned loads and stores. ">Vc::Unaligned</a>, and/or <a class="el" href="group__Utilities.html#ga3bed7ba639e9ef78c79421c801b43e59" title="Use this object for a flags parameter to request default software prefetches to be emitted...">Vc::PrefetchDefault</a>. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="common_2vector_8h_source.html#l00089">89</a> of file <a class="el" href="common_2vector_8h_source.html">vector.h</a>.</p>

</div>
</div>
<a class="anchor" id="a877b3f1854117429aca9b4a84561cdbb"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void store </td>
          <td>(</td>
          <td class="paramtype">U *&#160;</td>
          <td class="paramname"><em>mem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Flags&#160;</td>
          <td class="paramname"><em>flags</em> = <code>Flags()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Store the vector data to <code>mem</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mem</td><td>A pointer to memory, where \(\mathcal{W}_\mathtt{T}\) consecutive values will be stored. </td></tr>
    <tr><td class="paramname">flags</td><td>The flags parameter can be used to select e.g. the <a class="el" href="group__Utilities.html#ga9e53bd74b9a47cb8f16bf12018c3670e" title="Use this object for a flags parameter to request aligned loads and stores. ">Vc::Aligned</a>, <a class="el" href="group__Utilities.html#ga91774bc3f3fc00d22deff300919d811c" title="Use this object for a flags parameter to request unaligned loads and stores. ">Vc::Unaligned</a>, <a class="el" href="group__Utilities.html#gadc83bcfec8f15d1d02fb53baa3f38185" title="Use this object for a flags parameter to request streaming loads and stores. ">Vc::Streaming</a>, and/or <a class="el" href="group__Utilities.html#ga3bed7ba639e9ef78c79421c801b43e59" title="Use this object for a flags parameter to request default software prefetches to be emitted...">Vc::PrefetchDefault</a> flags. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab3f17d28735a2e98b003aa6ee0ac6745"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Vc_VDECL store </td>
          <td>(</td>
          <td class="paramtype">U *&#160;</td>
          <td class="paramname"><em>mem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classVc_1_1Vector.html#a87ee111bfca7f15829e802bdf47c3b0e">MaskType</a>&#160;</td>
          <td class="paramname"><em>mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Flags&#160;</td>
          <td class="paramname"><em>flags</em> = <code>Flags()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Store the vector data to <code>mem</code> where <code>mask</code> is set. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mem</td><td>A pointer to memory, where \(\mathcal{W}_\mathtt{T}\) consecutive values will be stored. </td></tr>
    <tr><td class="paramname">mask</td><td>A mask object that determines which entries of the vector should be stored to <code>mem</code>. </td></tr>
    <tr><td class="paramname">flags</td><td>The flags parameter can be used to select e.g. the <a class="el" href="group__Utilities.html#ga9e53bd74b9a47cb8f16bf12018c3670e" title="Use this object for a flags parameter to request aligned loads and stores. ">Vc::Aligned</a>, <a class="el" href="group__Utilities.html#ga91774bc3f3fc00d22deff300919d811c" title="Use this object for a flags parameter to request unaligned loads and stores. ">Vc::Unaligned</a>, <a class="el" href="group__Utilities.html#gadc83bcfec8f15d1d02fb53baa3f38185" title="Use this object for a flags parameter to request streaming loads and stores. ">Vc::Streaming</a>, and/or <a class="el" href="group__Utilities.html#ga3bed7ba639e9ef78c79421c801b43e59" title="Use this object for a flags parameter to request default software prefetches to be emitted...">Vc::PrefetchDefault</a> flags.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The masked store does not pack the values into memory. I.e. the value at offset <code>i</code> will be stored to <code>mem[i]</code>, independent of whether <code>mask[j]</code> for any <code>j &lt; i</code> is <code>false</code>. </dd></dl>

</div>
</div>
<a class="anchor" id="a804d5492c78c2e5f9ca92f1d02c78c1b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void setZero </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classVc_1_1Vector.html#a87ee111bfca7f15829e802bdf47c3b0e">MaskType</a>&#160;</td>
          <td class="paramname"><em>mask</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set all entries to zero where the mask is set. </p>
<p>A 4-vector with a mask of <code>[0111]</code> therefore would set the last three entries to 0.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mask</td><td>Selects the entries to be set to zero. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a10b3726d4ad99374f9448860fa5229d5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void setZeroInverted </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classVc_1_1Vector.html#a87ee111bfca7f15829e802bdf47c3b0e">MaskType</a>&#160;</td>
          <td class="paramname"><em>mask</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set all entries to zero where the mask is not set. </p>
<p>A 4-vector with a mask of <code>[0111]</code> therefore would set only the first entry to 0.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mask</td><td>Selects the entries to not be set to zero. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a3b97acf03cd2b4e96eeed94c6bf6a3fa"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void setQnan </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classVc_1_1Vector.html#a87ee111bfca7f15829e802bdf47c3b0e">MaskType</a>&#160;</td>
          <td class="paramname"><em>mask</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set all entries to the bit representation of a QNaN where the mask is set. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mask</td><td>Selects the entries to be set to QNaN. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a74678fe3f7c4925bd19b5674fcac3ec2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void gather </td>
          <td>(</td>
          <td class="paramtype">const S1 *&#160;</td>
          <td class="paramname"><em>array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classVc_1_1Vector.html#ae9cb6038cbd15cb0bdc596f5383c2b21">EntryType</a> S1::*&#160;</td>
          <td class="paramname"><em>member1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IT&#160;</td>
          <td class="paramname"><em>indexes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000064">Deprecated:</a></b></dt><dd>Use Vc::array or <a class="el" href="group__Utilities.html#gac1ffd8b29c356abdbb821a7854c53b07" title="An adapted std::vector container with an additional subscript operator which implements gather and sc...">Vc::vector</a> subscripting instead.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">array</td><td>A pointer into memory (without alignment restrictions). </td></tr>
    <tr><td class="paramname">member1</td><td>If <code>array</code> points to a struct, <code>member1</code> determines the member in the struct to be read. Thus the offsets in <code>indexes</code> are relative to the <code>array</code> and not to the size of the gathered type (i.e. array[i].*member1 is accessed instead of (&amp;(array-&gt;*member1))[i]) </td></tr>
    <tr><td class="paramname">indexes</td><td>Determines the offsets into <code>array</code> where the values are gathered from/scattered to. The type of indexes can either be an integer vector or a type that supports operator[] access. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="common_2vector_8h_source.html#l00387">387</a> of file <a class="el" href="common_2vector_8h_source.html">vector.h</a>.</p>

</div>
</div>
<a class="anchor" id="a41aec2586ff985e863c78803d11d2306"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void gather </td>
          <td>(</td>
          <td class="paramtype">const S1 *&#160;</td>
          <td class="paramname"><em>array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classVc_1_1Vector.html#ae9cb6038cbd15cb0bdc596f5383c2b21">EntryType</a> S1::*&#160;</td>
          <td class="paramname"><em>member1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IT&#160;</td>
          <td class="paramname"><em>indexes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classVc_1_1Mask.html">MaskArgument</a>&#160;</td>
          <td class="paramname"><em>mask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000065">Deprecated:</a></b></dt><dd>Use Vc::array or <a class="el" href="group__Utilities.html#gac1ffd8b29c356abdbb821a7854c53b07" title="An adapted std::vector container with an additional subscript operator which implements gather and sc...">Vc::vector</a> subscripting instead.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">array</td><td>A pointer into memory (without alignment restrictions). </td></tr>
    <tr><td class="paramname">member1</td><td>If <code>array</code> points to a struct, <code>member1</code> determines the member in the struct to be read. Thus the offsets in <code>indexes</code> are relative to the <code>array</code> and not to the size of the gathered type (i.e. array[i].*member1 is accessed instead of (&amp;(array-&gt;*member1))[i]) </td></tr>
    <tr><td class="paramname">indexes</td><td>Determines the offsets into <code>array</code> where the values are gathered from/scattered to. The type of indexes can either be an integer vector or a type that supports operator[] access. </td></tr>
    <tr><td class="paramname">mask</td><td>If a mask is given only the active entries will be gathered/scattered. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="common_2vector_8h_source.html#l00410">410</a> of file <a class="el" href="common_2vector_8h_source.html">vector.h</a>.</p>

</div>
</div>
<a class="anchor" id="ab7e0e744bbf8112abc60707ec35782ac"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void gather </td>
          <td>(</td>
          <td class="paramtype">const S1 *&#160;</td>
          <td class="paramname"><em>array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const S2 S1::*&#160;</td>
          <td class="paramname"><em>member1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classVc_1_1Vector.html#ae9cb6038cbd15cb0bdc596f5383c2b21">EntryType</a> S2::*&#160;</td>
          <td class="paramname"><em>member2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IT&#160;</td>
          <td class="paramname"><em>indexes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000066">Deprecated:</a></b></dt><dd>Use Vc::array or <a class="el" href="group__Utilities.html#gac1ffd8b29c356abdbb821a7854c53b07" title="An adapted std::vector container with an additional subscript operator which implements gather and sc...">Vc::vector</a> subscripting instead.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">array</td><td>A pointer into memory (without alignment restrictions). </td></tr>
    <tr><td class="paramname">member1</td><td>If <code>array</code> points to a struct, <code>member1</code> determines the member in the struct to be read. Thus the offsets in <code>indexes</code> are relative to the <code>array</code> and not to the size of the gathered type (i.e. array[i].*member1 is accessed instead of (&amp;(array-&gt;*member1))[i]) </td></tr>
    <tr><td class="paramname">member2</td><td>If <code>member1</code> is a struct then <code>member2</code> selects the member to be read from that struct (i.e. array[i].*member1.*member2 is read). </td></tr>
    <tr><td class="paramname">indexes</td><td>Determines the offsets into <code>array</code> where the values are gathered from/scattered to. The type of indexes can either be an integer vector or a type that supports operator[] access. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="common_2vector_8h_source.html#l00437">437</a> of file <a class="el" href="common_2vector_8h_source.html">vector.h</a>.</p>

</div>
</div>
<a class="anchor" id="a0a0ce77d4761ff3d4c346f44b02d5168"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void gather </td>
          <td>(</td>
          <td class="paramtype">const S1 *&#160;</td>
          <td class="paramname"><em>array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const S2 S1::*&#160;</td>
          <td class="paramname"><em>member1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classVc_1_1Vector.html#ae9cb6038cbd15cb0bdc596f5383c2b21">EntryType</a> S2::*&#160;</td>
          <td class="paramname"><em>member2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IT&#160;</td>
          <td class="paramname"><em>indexes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classVc_1_1Mask.html">MaskArgument</a>&#160;</td>
          <td class="paramname"><em>mask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000067">Deprecated:</a></b></dt><dd>Use Vc::array or <a class="el" href="group__Utilities.html#gac1ffd8b29c356abdbb821a7854c53b07" title="An adapted std::vector container with an additional subscript operator which implements gather and sc...">Vc::vector</a> subscripting instead.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">array</td><td>A pointer into memory (without alignment restrictions). </td></tr>
    <tr><td class="paramname">member1</td><td>If <code>array</code> points to a struct, <code>member1</code> determines the member in the struct to be read. Thus the offsets in <code>indexes</code> are relative to the <code>array</code> and not to the size of the gathered type (i.e. array[i].*member1 is accessed instead of (&amp;(array-&gt;*member1))[i]) </td></tr>
    <tr><td class="paramname">member2</td><td>If <code>member1</code> is a struct then <code>member2</code> selects the member to be read from that struct (i.e. array[i].*member1.*member2 is read). </td></tr>
    <tr><td class="paramname">indexes</td><td>Determines the offsets into <code>array</code> where the values are gathered from/scattered to. The type of indexes can either be an integer vector or a type that supports operator[] access. </td></tr>
    <tr><td class="paramname">mask</td><td>If a mask is given only the active entries will be gathered/scattered. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="common_2vector_8h_source.html#l00462">462</a> of file <a class="el" href="common_2vector_8h_source.html">vector.h</a>.</p>

</div>
</div>
<a class="anchor" id="a851eee82fe0a753a26929a1a6982f84a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void gather </td>
          <td>(</td>
          <td class="paramtype">const S1 *&#160;</td>
          <td class="paramname"><em>array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classVc_1_1Vector.html#ae9cb6038cbd15cb0bdc596f5383c2b21">EntryType</a> *const S1::*&#160;</td>
          <td class="paramname"><em>ptrMember1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IT1&#160;</td>
          <td class="paramname"><em>outerIndexes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IT2&#160;</td>
          <td class="paramname"><em>innerIndexes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000068">Deprecated:</a></b></dt><dd>Use Vc::array or <a class="el" href="group__Utilities.html#gac1ffd8b29c356abdbb821a7854c53b07" title="An adapted std::vector container with an additional subscript operator which implements gather and sc...">Vc::vector</a> subscripting instead.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">array</td><td>A pointer into memory (without alignment restrictions). </td></tr>
    <tr><td class="paramname">ptrMember1</td><td>If <code>array</code> points to a struct, <code>member1</code> determines the member in the struct to be read. Thus the offsets in <code>indexes</code> are relative to the <code>array</code> and not to the size of the gathered type (i.e. array[i].*member1 is accessed instead of (&amp;(array-&gt;*member1))[i]) </td></tr>
    <tr><td class="paramname">outerIndexes</td><td></td></tr>
    <tr><td class="paramname">innerIndexes</td><td></td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="common_2vector_8h_source.html#l00485">485</a> of file <a class="el" href="common_2vector_8h_source.html">vector.h</a>.</p>

</div>
</div>
<a class="anchor" id="af179ee076927fb7ed38661b34e70b5ee"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void gather </td>
          <td>(</td>
          <td class="paramtype">const S1 *&#160;</td>
          <td class="paramname"><em>array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classVc_1_1Vector.html#ae9cb6038cbd15cb0bdc596f5383c2b21">EntryType</a> *const S1::*&#160;</td>
          <td class="paramname"><em>ptrMember1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IT1&#160;</td>
          <td class="paramname"><em>outerIndexes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IT2&#160;</td>
          <td class="paramname"><em>innerIndexes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classVc_1_1Mask.html">MaskArgument</a>&#160;</td>
          <td class="paramname"><em>mask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000069">Deprecated:</a></b></dt><dd>Use Vc::array or <a class="el" href="group__Utilities.html#gac1ffd8b29c356abdbb821a7854c53b07" title="An adapted std::vector container with an additional subscript operator which implements gather and sc...">Vc::vector</a> subscripting instead.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">array</td><td>A pointer into memory (without alignment restrictions). </td></tr>
    <tr><td class="paramname">ptrMember1</td><td>If <code>array</code> points to a struct, <code>member1</code> determines the member in the struct to be read. Thus the offsets in <code>indexes</code> are relative to the <code>array</code> and not to the size of the gathered type (i.e. array[i].*member1 is accessed instead of (&amp;(array-&gt;*member1))[i]) </td></tr>
    <tr><td class="paramname">outerIndexes</td><td></td></tr>
    <tr><td class="paramname">innerIndexes</td><td></td></tr>
    <tr><td class="paramname">mask</td><td>If a mask is given only the active entries will be gathered/scattered. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="common_2vector_8h_source.html#l00508">508</a> of file <a class="el" href="common_2vector_8h_source.html">vector.h</a>.</p>

</div>
</div>
<a class="anchor" id="af57dd65795bb03a652b52bdc59152974"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void scatter </td>
          <td>(</td>
          <td class="paramtype">S1 *&#160;</td>
          <td class="paramname"><em>array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classVc_1_1Vector.html#ae9cb6038cbd15cb0bdc596f5383c2b21">EntryType</a> S1::*&#160;</td>
          <td class="paramname"><em>member1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IT&#160;</td>
          <td class="paramname"><em>indexes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000070">Deprecated:</a></b></dt><dd>Use Vc::array or <a class="el" href="group__Utilities.html#gac1ffd8b29c356abdbb821a7854c53b07" title="An adapted std::vector container with an additional subscript operator which implements gather and sc...">Vc::vector</a> subscripting instead.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">array</td><td>A pointer into memory (without alignment restrictions). </td></tr>
    <tr><td class="paramname">member1</td><td>If <code>array</code> points to a struct, <code>member1</code> determines the member in the struct to be read. Thus the offsets in <code>indexes</code> are relative to the <code>array</code> and not to the size of the gathered type (i.e. array[i].*member1 is accessed instead of (&amp;(array-&gt;*member1))[i]) </td></tr>
    <tr><td class="paramname">indexes</td><td>Determines the offsets into <code>array</code> where the values are gathered from/scattered to. The type of indexes can either be an integer vector or a type that supports operator[] access. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="common_2vector_8h_source.html#l00133">133</a> of file <a class="el" href="common_2vector_8h_source.html">vector.h</a>.</p>

</div>
</div>
<a class="anchor" id="ac767f28c920a44d0f732505ec7bb9865"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void scatter </td>
          <td>(</td>
          <td class="paramtype">S1 *&#160;</td>
          <td class="paramname"><em>array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classVc_1_1Vector.html#ae9cb6038cbd15cb0bdc596f5383c2b21">EntryType</a> S1::*&#160;</td>
          <td class="paramname"><em>member1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IT&#160;</td>
          <td class="paramname"><em>indexes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classVc_1_1Mask.html">MaskArgument</a>&#160;</td>
          <td class="paramname"><em>mask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000071">Deprecated:</a></b></dt><dd>Use Vc::array or <a class="el" href="group__Utilities.html#gac1ffd8b29c356abdbb821a7854c53b07" title="An adapted std::vector container with an additional subscript operator which implements gather and sc...">Vc::vector</a> subscripting instead.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">array</td><td>A pointer into memory (without alignment restrictions). </td></tr>
    <tr><td class="paramname">member1</td><td>If <code>array</code> points to a struct, <code>member1</code> determines the member in the struct to be read. Thus the offsets in <code>indexes</code> are relative to the <code>array</code> and not to the size of the gathered type (i.e. array[i].*member1 is accessed instead of (&amp;(array-&gt;*member1))[i]) </td></tr>
    <tr><td class="paramname">indexes</td><td>Determines the offsets into <code>array</code> where the values are gathered from/scattered to. The type of indexes can either be an integer vector or a type that supports operator[] access. </td></tr>
    <tr><td class="paramname">mask</td><td>If a mask is given only the active entries will be gathered/scattered. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="common_2vector_8h_source.html#l00156">156</a> of file <a class="el" href="common_2vector_8h_source.html">vector.h</a>.</p>

</div>
</div>
<a class="anchor" id="a90951e0b3ea5b221cd6a71734d5ce93d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void scatter </td>
          <td>(</td>
          <td class="paramtype">S1 *&#160;</td>
          <td class="paramname"><em>array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">S2 S1::*&#160;</td>
          <td class="paramname"><em>member1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classVc_1_1Vector.html#ae9cb6038cbd15cb0bdc596f5383c2b21">EntryType</a> S2::*&#160;</td>
          <td class="paramname"><em>member2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IT&#160;</td>
          <td class="paramname"><em>indexes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000072">Deprecated:</a></b></dt><dd>Use Vc::array or <a class="el" href="group__Utilities.html#gac1ffd8b29c356abdbb821a7854c53b07" title="An adapted std::vector container with an additional subscript operator which implements gather and sc...">Vc::vector</a> subscripting instead.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">array</td><td>A pointer into memory (without alignment restrictions). </td></tr>
    <tr><td class="paramname">member1</td><td>If <code>array</code> points to a struct, <code>member1</code> determines the member in the struct to be read. Thus the offsets in <code>indexes</code> are relative to the <code>array</code> and not to the size of the gathered type (i.e. array[i].*member1 is accessed instead of (&amp;(array-&gt;*member1))[i]) </td></tr>
    <tr><td class="paramname">member2</td><td>If <code>member1</code> is a struct then <code>member2</code> selects the member to be read from that struct (i.e. array[i].*member1.*member2 is read). </td></tr>
    <tr><td class="paramname">indexes</td><td>Determines the offsets into <code>array</code> where the values are gathered from/scattered to. The type of indexes can either be an integer vector or a type that supports operator[] access. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="common_2vector_8h_source.html#l00181">181</a> of file <a class="el" href="common_2vector_8h_source.html">vector.h</a>.</p>

</div>
</div>
<a class="anchor" id="a299631364e9c623ac9597f31801bd927"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void scatter </td>
          <td>(</td>
          <td class="paramtype">S1 *&#160;</td>
          <td class="paramname"><em>array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">S2 S1::*&#160;</td>
          <td class="paramname"><em>member1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classVc_1_1Vector.html#ae9cb6038cbd15cb0bdc596f5383c2b21">EntryType</a> S2::*&#160;</td>
          <td class="paramname"><em>member2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IT&#160;</td>
          <td class="paramname"><em>indexes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classVc_1_1Mask.html">MaskArgument</a>&#160;</td>
          <td class="paramname"><em>mask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000073">Deprecated:</a></b></dt><dd>Use Vc::array or <a class="el" href="group__Utilities.html#gac1ffd8b29c356abdbb821a7854c53b07" title="An adapted std::vector container with an additional subscript operator which implements gather and sc...">Vc::vector</a> subscripting instead.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">array</td><td>A pointer into memory (without alignment restrictions). </td></tr>
    <tr><td class="paramname">member1</td><td>If <code>array</code> points to a struct, <code>member1</code> determines the member in the struct to be read. Thus the offsets in <code>indexes</code> are relative to the <code>array</code> and not to the size of the gathered type (i.e. array[i].*member1 is accessed instead of (&amp;(array-&gt;*member1))[i]) </td></tr>
    <tr><td class="paramname">member2</td><td>If <code>member1</code> is a struct then <code>member2</code> selects the member to be read from that struct (i.e. array[i].*member1.*member2 is read). </td></tr>
    <tr><td class="paramname">indexes</td><td>Determines the offsets into <code>array</code> where the values are gathered from/scattered to. The type of indexes can either be an integer vector or a type that supports operator[] access. </td></tr>
    <tr><td class="paramname">mask</td><td>If a mask is given only the active entries will be gathered/scattered. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="common_2vector_8h_source.html#l00207">207</a> of file <a class="el" href="common_2vector_8h_source.html">vector.h</a>.</p>

</div>
</div>
<a class="anchor" id="a811c74efda5768b9decec85dce246173"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void scatter </td>
          <td>(</td>
          <td class="paramtype">S1 *&#160;</td>
          <td class="paramname"><em>array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classVc_1_1Vector.html#ae9cb6038cbd15cb0bdc596f5383c2b21">EntryType</a> *S1::*&#160;</td>
          <td class="paramname"><em>ptrMember1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IT1&#160;</td>
          <td class="paramname"><em>outerIndexes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IT2&#160;</td>
          <td class="paramname"><em>innerIndexes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000074">Deprecated:</a></b></dt><dd>Use Vc::array or <a class="el" href="group__Utilities.html#gac1ffd8b29c356abdbb821a7854c53b07" title="An adapted std::vector container with an additional subscript operator which implements gather and sc...">Vc::vector</a> subscripting instead.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">array</td><td>A pointer into memory (without alignment restrictions). </td></tr>
    <tr><td class="paramname">ptrMember1</td><td>If <code>array</code> points to a struct, <code>member1</code> determines the member in the struct to be read. Thus the offsets in <code>indexes</code> are relative to the <code>array</code> and not to the size of the gathered type (i.e. array[i].*member1 is accessed instead of (&amp;(array-&gt;*member1))[i]) </td></tr>
    <tr><td class="paramname">outerIndexes</td><td></td></tr>
    <tr><td class="paramname">innerIndexes</td><td></td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="common_2vector_8h_source.html#l00230">230</a> of file <a class="el" href="common_2vector_8h_source.html">vector.h</a>.</p>

</div>
</div>
<a class="anchor" id="ab145b30f47b57e36d08592e2ab454d6f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void scatter </td>
          <td>(</td>
          <td class="paramtype">S1 *&#160;</td>
          <td class="paramname"><em>array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classVc_1_1Vector.html#ae9cb6038cbd15cb0bdc596f5383c2b21">EntryType</a> *S1::*&#160;</td>
          <td class="paramname"><em>ptrMember1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IT1&#160;</td>
          <td class="paramname"><em>outerIndexes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IT2&#160;</td>
          <td class="paramname"><em>innerIndexes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classVc_1_1Mask.html">MaskArgument</a>&#160;</td>
          <td class="paramname"><em>mask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000075">Deprecated:</a></b></dt><dd>Use Vc::array or <a class="el" href="group__Utilities.html#gac1ffd8b29c356abdbb821a7854c53b07" title="An adapted std::vector container with an additional subscript operator which implements gather and sc...">Vc::vector</a> subscripting instead.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">array</td><td>A pointer into memory (without alignment restrictions). </td></tr>
    <tr><td class="paramname">ptrMember1</td><td>If <code>array</code> points to a struct, <code>member1</code> determines the member in the struct to be read. Thus the offsets in <code>indexes</code> are relative to the <code>array</code> and not to the size of the gathered type (i.e. array[i].*member1 is accessed instead of (&amp;(array-&gt;*member1))[i]) </td></tr>
    <tr><td class="paramname">outerIndexes</td><td></td></tr>
    <tr><td class="paramname">innerIndexes</td><td></td></tr>
    <tr><td class="paramname">mask</td><td>If a mask is given only the active entries will be gathered/scattered. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="common_2vector_8h_source.html#l00253">253</a> of file <a class="el" href="common_2vector_8h_source.html">vector.h</a>.</p>

</div>
</div>
<a class="anchor" id="ad9490a1dfe9ab280829a12edea2a858b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">reference operator[] </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This operator can be used to modify scalar entries of the vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>A value between 0 and Size. This value is not checked internally so you must make/be sure it is in range.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to the vector entry at the given <code>index</code>.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>The use of this function may result in suboptimal performance. Please check whether you can find a more vector-friendly way to do what you intended. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>the returned object models the concept of a reference and as such it can exist longer than the data it is referencing. </dd>
<dd>
to avoid lifetime issues, we strongly advice not to store any reference objects. </dd></dl>

</div>
</div>
<a class="anchor" id="a61ea5f5cc301d8c25138afa9dfc3f04e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVc_1_1Vector.html#ae9cb6038cbd15cb0bdc596f5383c2b21">EntryType</a> operator[] </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This operator can be used to read scalar entries of the vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>A value between 0 and Size. This value is not checked internally so you must make/be sure it is in range.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a copy of the vector entry at the given <code>index</code>. </dd></dl>

</div>
</div>
<a class="anchor" id="af99b135180d40d99d3b707875007f7fb"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVc_1_1Vector.html#a87ee111bfca7f15829e802bdf47c3b0e">MaskType</a> operator! </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determine where the vector is null. </p>
<dl class="section return"><dt>Returns</dt><dd>a mask which denotes the zero entries of this vector object. </dd></dl>

</div>
</div>
<a class="anchor" id="af61178bc2c71839e7cb8e98358e453be"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVc_1_1Vector.html">Vector</a> operator~ </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inverts all bits. </p>
<dl class="section return"><dt>Returns</dt><dd>a new vector which has all bits inverted. I.e. <code>v &amp; ~v == 0</code>.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This operator is only defined for integral types <code>T</code>. </dd></dl>

</div>
</div>
<a class="anchor" id="a6197f3a5d43c38efd55819af6d9404ca"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Common::WriteMaskedVector&lt;<a class="el" href="classVc_1_1Vector.html">Vector</a>, <a class="el" href="classVc_1_1Vector.html#a87ee111bfca7f15829e802bdf47c3b0e">MaskType</a>&gt; operator() </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classVc_1_1Vector.html#a87ee111bfca7f15829e802bdf47c3b0e">MaskType</a>&#160;</td>
          <td class="paramname"><em>mask</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writemask the vector before an assignment. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mask</td><td>The writemask to be used.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an object that can be used for any kind of masked assignment.</dd></dl>
<p>The returned object is only to be used for assignments and should not be assigned to a variable.</p>
<p>Examples: </p><div class="fragment"><div class="line"><a class="code" href="group__Vectors.html#ga5cf7c5a0dadbbbbcb9b69c5e42ee0528">float_v</a> v = <a class="code" href="classVc_1_1Vector.html#af9c6cd3201b97b6c86d64a3b25e584d7">float_v::Zero</a>();         <span class="comment">// v  = [0, 0, 0, 0]</span></div>
<div class="line"><a class="code" href="group__Vectors.html#gaff6f527c244d2e97ae290d2325de8ec0">int_v</a> v2 = <a class="code" href="classVc_1_1Vector.html#a493fd531cf26bec9f8b40740ab110eec">int_v::IndexesFromZero</a>(); <span class="comment">// v2 = [0, 1, 2, 3]</span></div>
<div class="line">v(v2 &lt; 2) = 1.f;                     <span class="comment">// v  = [1, 1, 0, 0]</span></div>
<div class="line">v(v2 &lt; 3) += 1.f;                    <span class="comment">// v  = [2, 2, 1, 0]</span></div>
<div class="line">++v2(v &lt; 1.f);                       <span class="comment">// v2 = [0, 1, 2, 4]</span></div>
</div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="a01728148f46f24cd5a2bf9784006564c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVc_1_1Vector.html">Vector</a> shifted </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>amount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classVc_1_1Vector.html">Vector</a>&lt; T, Abi &gt;&#160;</td>
          <td class="paramname"><em>shiftIn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Shift vector entries to the left by <code>amount</code>; shifting in values from shiftIn (instead of zeros). </p>
<p>This function can be used to create vectors from unaligned memory locations.</p>
<p>Example: </p><div class="fragment"><div class="line">Vc::Memory&lt;int_v, 256&gt; mem;</div>
<div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; 256; ++i) { mem[i] = i + 1; }</div>
<div class="line"><a class="code" href="group__Vectors.html#gaff6f527c244d2e97ae290d2325de8ec0">int_v</a> a = mem.vectorAt(0);</div>
<div class="line"><a class="code" href="group__Vectors.html#gaff6f527c244d2e97ae290d2325de8ec0">int_v</a> b = mem.vectorAt(<a class="code" href="classVc_1_1Vector.html#a879ad9933a419e4e04c8a59cc19a34fe">int_v::Size</a>);</div>
<div class="line"><a class="code" href="group__Vectors.html#gaff6f527c244d2e97ae290d2325de8ec0">int_v</a> x = a.<a class="code" href="classVc_1_1Vector.html#a30fa8a10db5836f2a079df3960878714">shifted</a>(1, b);</div>
<div class="line"><span class="comment">// now x == mem.vectorAt(1, Vc::Unaligned)</span></div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">amount</td><td>The number of entries to shift by. <code>amount</code> must be between <code>-Size</code> and <code>Size</code>, otherwise the result is undefined. </td></tr>
    <tr><td class="paramname">shiftIn</td><td>The vector of values to shift in. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A new vector with values from <code>this</code> and <code>shiftIn</code> concatenated and then shifted by <code>amount</code>. </dd></dl>

</div>
</div>
<a class="anchor" id="a81df1f97caedbdaa2dc75b78a98a3033"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVc_1_1Vector.html">Vector</a> sorted </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a sorted copy of the vector. </p>
<dl class="section return"><dt>Returns</dt><dd>a sorted vector. The returned values are in ascending order: <pre class="fragment">v[0] &lt;= v[1] &lt;= v[2] &lt;= v[3] ...
</pre></dd></dl>
<dl class="section note"><dt>Note</dt><dd>If the vector contains NaNs the result is undefined.</dd></dl>
<p>Example: </p><div class="fragment"><div class="line"><a class="code" href="group__Vectors.html#gaff6f527c244d2e97ae290d2325de8ec0">int_v</a> v = <a class="code" href="classVc_1_1Vector.html#aaa7aece82798960b1144c030e4c8f6cc">int_v::Random</a>();</div>
<div class="line"><a class="code" href="group__Vectors.html#gaff6f527c244d2e97ae290d2325de8ec0">int_v</a> s = v.sorted();</div>
<div class="line">std::cout &lt;&lt; v &lt;&lt; <span class="charliteral">&#39;\n&#39;</span> &lt;&lt; s &lt;&lt; <span class="charliteral">&#39;\n&#39;</span>;</div>
</div><!-- fragment --><p>With SSE the output would be:</p>
<pre class="fragment">[1513634383, -963914658, 1763536262, -1285037745]
[-1285037745, -963914658, 1513634383, 1763536262]
</pre><p>With the Scalar implementation: </p><pre class="fragment">[1513634383]
[1513634383]
</pre> 
</div>
</div>
<a class="anchor" id="afc65cca01d680f8e70f8dd626fd07953"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVc_1_1Vector.html">Vector</a> exponent </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the exponents of the floating-point values in the vector. </p>
<dl class="section return"><dt>Returns</dt><dd>A new vector object of the same type containing the exponents.</dd></dl>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000076">Deprecated:</a></b></dt><dd>use <a class="el" href="group__SimdArray.html#gae35147ca0930dd1963bb751bf7a3d098" title="Applies the std:: exponent function component-wise and concurrently. ">Vc::exponent</a> instead. </dd></dl>

</div>
</div>
<a class="anchor" id="ae69d39745f8c88369041a693f6e5d0b7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVc_1_1Vector.html#a87ee111bfca7f15829e802bdf47c3b0e">MaskType</a> isNegative </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns whether a value is negative. </p>
<dl class="section return"><dt>Returns</dt><dd>A new mask object indicating the sign of each vector element.</dd></dl>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000077">Deprecated:</a></b></dt><dd>use <a class="el" href="group__SimdArray.html#ga2bbbde31371490c3600d9d301f22b9a6" title="Applies the std:: isnegative function component-wise and concurrently. ">Vc::isnegative</a> instead. </dd></dl>

</div>
</div>
<a class="anchor" id="af7d590c16931b1f6b0a834c6d3f6ca36"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">V2 staticCast </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Casts the current object to <code>V2</code>. </p>
<dl class="section return"><dt>Returns</dt><dd>a converted object of type <code><a class="el" href="namespaceVc.html" title="Vector Classes Namespace. ">Vc</a></code>.</dd></dl>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000079">Deprecated:</a></b></dt><dd>Use <a class="el" href="namespaceVc.html#a61262fcc2d367c5df6daca30d9fec43d" title="Casts the argument x from type From to type To. ">Vc::simd_cast</a> instead. </dd></dl>

</div>
</div>
<a class="anchor" id="a15c83c63439def0bc06102c4885ac03f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">V2 reinterpretCast </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>reinterpret_cast the vector components to construct a vector of type <code>V2</code>. </p>
<dl class="section return"><dt>Returns</dt><dd>An object of type <code>V2</code> with the smae bit-representation.</dd></dl>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000080">Deprecated:</a></b></dt><dd>use <a class="el" href="group__Utilities.html#ga50815bfe268083df7c8d7223dce212de" title="Constructs a new Vector object of type V from the Vector x, reinterpreting the bits of x for the new ...">Vc::reinterpret_components_cast</a> instead. </dd></dl>

</div>
</div>
<a class="anchor" id="a2cf4cf04978c7d21c69a671412dcd181"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVc_1_1Vector.html">Vector</a> copySign </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classVc_1_1Vector.html">Vector</a>&lt; T, Abi &gt;&#160;</td>
          <td class="paramname"><em>reference</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies the signs of the components of <code>reference</code> to the components of the current vector, returning the result. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">reference</td><td>A vector object that determines the sign of the the result. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A new vector with sign taken from <code>reference</code> and absolute value taken from the current vector object.</dd></dl>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000081">Deprecated:</a></b></dt><dd>Use <a class="el" href="group__SimdArray.html#gad34671db81c39d19c831bd1ef55ec22f" title="Applies the std:: copysign function component-wise and concurrently. ">Vc::copysign</a> instead. </dd></dl>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a class="anchor" id="a879ad9933a419e4e04c8a59cc19a34fe"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr size_t Size = VectorTraits&lt;T, Abi&gt;::<a class="el" href="classVc_1_1Vector.html#a1b5d7e2e663d7997796fd9f72b8af75a">size</a>()</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of scalar components ( \(\mathcal{W}_\mathtt{T}\)) in a vector of this type. </p>
<p>The size of the vector. I.e. the number of scalar entries in the vector. Do not make any assumptions about the size of vectors. If you need vectors of <code>float</code> and <code>int</code> types use <a class="el" href="classVc_1_1Vector.html#a435ebd80eab40f6a9a311106fb234b82" title="The type of the vector used for indexes in gather and scatter operations. ">Vector::IndexType</a> or <a class="el" href="classVc_1_1SimdArray.html" title="Data-parallel arithmetic type with user-defined number of elements. ">SimdArray</a>.</p>
<p>You can easily use if clauses to compare <a class="el" href="classVc_1_1Vector.html" title="The main vector class for expressing data parallelism. ">Vector</a> sizes. The compiler can statically evaluate and fully optimize dead code away (very much like #ifdef, but with syntax checking).</p>
<dl class="section return"><dt>Returns</dt><dd>The number of components (i.e. \(\mathcal{W}_\mathtt{T}\)) objects of this vector type store and manipulate. </dd></dl>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000078">Deprecated:</a></b></dt><dd>Use <a class="el" href="classVc_1_1Vector.html#a1b5d7e2e663d7997796fd9f72b8af75a" title="Returns the number of scalar components ( ) in a vector of this type. ">Vc::Vector::size</a> instead. </dd></dl>

<p>Definition at line <a class="el" href="common_2vector_8h_source.html#l00767">767</a> of file <a class="el" href="common_2vector_8h_source.html">vector.h</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>/u/mkretz/src/.Vc-dox/common/<a class="el" href="types_8h_source.html">types.h</a></li>
<li>/u/mkretz/src/.Vc-dox/common/<a class="el" href="common_2vector_8h_source.html">vector.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespaceVc.html">Vc</a></li><li class="navelem"><a class="el" href="classVc_1_1Vector.html">Vector</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.10 </li>
  </ul>
</div>
</body>
</html>
