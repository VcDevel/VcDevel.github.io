<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.10"/>
<title>Vc: Mask&lt; T, Abi &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() {
    if ($('.searchresults').length > 0) { searchBox.DOMSearchField().focus(); }
  });
</script>
<link rel="search" href="search_opensearch.php?v=opensearch.xml" type="application/opensearchdescription+xml" title="Vc"/>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo_small.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Vc
   &#160;<span id="projectnumber">1.3.2-dev</span>
   </div>
   <div id="projectbrief">SIMD Vector Classes for C++</div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
          <div class="left">
            <form id="FSearchBox" action="search.php" method="get">
              <img id="MSearchSelect" src="search/mag.png" alt=""/>
              <input type="text" id="MSearchField" name="query" value="Search" size="20" accesskey="S" 
                     onfocus="searchBox.OnSearchFieldFocus(true)" 
                     onblur="searchBox.OnSearchFieldFocus(false)"/>
            </form>
          </div><div class="right"></div>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.10 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('classVc_1_1Mask.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="classVc_1_1Mask-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">Mask&lt; T, Abi &gt; Class Template Reference<div class="ingroups"><a class="el" href="group__Masks.html">Masks</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename T, typename Abi = VectorAbi::Best&lt;T&gt;&gt;<br />
class Vc::Mask&lt; T, Abi &gt;</h3>

<p>The main SIMD mask class. </p>

<p>Definition at line <a class="el" href="mask_8h_source.html#l00041">41</a> of file <a class="el" href="mask_8h_source.html">mask.h</a>.</p>
</div>
<p><code>#include &lt;<a class="el" href="mask_8h_source.html">Vc/vector.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:abe9aa1f35fa46be781ae9e81d374a72b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abe9aa1f35fa46be781ae9e81d374a72b"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVc_1_1Mask.html#abe9aa1f35fa46be781ae9e81d374a72b">abi</a> = Abi</td></tr>
<tr class="memdesc:abe9aa1f35fa46be781ae9e81d374a72b"><td class="mdescLeft">&#160;</td><td class="mdescRight">The ABI tag type of the current template instantiation. <br /></td></tr>
<tr class="separator:abe9aa1f35fa46be781ae9e81d374a72b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8d79876e53834654a2c408d3a3bca6a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af8d79876e53834654a2c408d3a3bca6a"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVc_1_1Mask.html#af8d79876e53834654a2c408d3a3bca6a">EntryType</a> = bool</td></tr>
<tr class="memdesc:af8d79876e53834654a2c408d3a3bca6a"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <code>EntryType</code> of masks is always <code>bool</code>, independent of <code>T</code>. <br /></td></tr>
<tr class="separator:af8d79876e53834654a2c408d3a3bca6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af58a233cf0cdf62369686dd5798bd589"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVc_1_1Mask.html#af58a233cf0cdf62369686dd5798bd589">value_type</a> = <a class="el" href="classVc_1_1Mask.html#af8d79876e53834654a2c408d3a3bca6a">EntryType</a></td></tr>
<tr class="memdesc:af58a233cf0cdf62369686dd5798bd589"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <code>EntryType</code> of masks is always <code>bool</code>, independent of <code>T</code>.  <a href="#af58a233cf0cdf62369686dd5798bd589">More...</a><br /></td></tr>
<tr class="separator:af58a233cf0cdf62369686dd5798bd589"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70a0859ec263806a8067448f6b70b708"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a70a0859ec263806a8067448f6b70b708"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVc_1_1Mask.html#a70a0859ec263806a8067448f6b70b708">EntryReference</a> = typename VectorTraits&lt; T, Abi &gt;::<a class="el" href="classVc_1_1Mask.html#a70a0859ec263806a8067448f6b70b708">EntryReference</a></td></tr>
<tr class="memdesc:a70a0859ec263806a8067448f6b70b708"><td class="mdescLeft">&#160;</td><td class="mdescRight">The reference wrapper type used for accessing individual mask components. <br /></td></tr>
<tr class="separator:a70a0859ec263806a8067448f6b70b708"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83c8f8c1ebbda813702f777d870356ce"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVc_1_1Mask.html#a83c8f8c1ebbda813702f777d870356ce">value_reference</a> = <a class="el" href="classVc_1_1Mask.html#a70a0859ec263806a8067448f6b70b708">EntryReference</a></td></tr>
<tr class="memdesc:a83c8f8c1ebbda813702f777d870356ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">The reference wrapper type used for accessing individual mask components.  <a href="#a83c8f8c1ebbda813702f777d870356ce">More...</a><br /></td></tr>
<tr class="separator:a83c8f8c1ebbda813702f777d870356ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c3595d34ff3a3ad8ddf57a9225cd32b"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVc_1_1Mask.html#a2c3595d34ff3a3ad8ddf57a9225cd32b">VectorEntryType</a> = typename VectorTraits&lt; T, Abi &gt;::<a class="el" href="classVc_1_1Mask.html#a2c3595d34ff3a3ad8ddf57a9225cd32b">VectorEntryType</a></td></tr>
<tr class="memdesc:a2c3595d34ff3a3ad8ddf57a9225cd32b"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <code>VectorEntryType</code>, in contrast to <code>EntryType</code>, reveals information about the SIMD implementation.  <a href="#a2c3595d34ff3a3ad8ddf57a9225cd32b">More...</a><br /></td></tr>
<tr class="separator:a2c3595d34ff3a3ad8ddf57a9225cd32b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a0745638c9967e2ed90bc96c012288c55"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0745638c9967e2ed90bc96c012288c55"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVc_1_1Mask.html#a0745638c9967e2ed90bc96c012288c55">count</a> () const </td></tr>
<tr class="memdesc:a0745638c9967e2ed90bc96c012288c55"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns how many components of the mask are <code>true</code>. <br /></td></tr>
<tr class="separator:a0745638c9967e2ed90bc96c012288c55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adafff7979b5d1d4924e5a4fb4365a5e6"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVc_1_1Mask.html#adafff7979b5d1d4924e5a4fb4365a5e6">firstOne</a> () const </td></tr>
<tr class="memdesc:adafff7979b5d1d4924e5a4fb4365a5e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the index of the first one in the mask.  <a href="#adafff7979b5d1d4924e5a4fb4365a5e6">More...</a><br /></td></tr>
<tr class="separator:adafff7979b5d1d4924e5a4fb4365a5e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7a5586bcba0f228f5acb3b37ebae263"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVc_1_1Mask.html#af7a5586bcba0f228f5acb3b37ebae263">toInt</a> () const </td></tr>
<tr class="memdesc:af7a5586bcba0f228f5acb3b37ebae263"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert the boolean components of the mask into bits of an integer.  <a href="#af7a5586bcba0f228f5acb3b37ebae263">More...</a><br /></td></tr>
<tr class="separator:af7a5586bcba0f228f5acb3b37ebae263"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa003d1118d02313dcaf8bb64912f81e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afa003d1118d02313dcaf8bb64912f81e"></a>
<a class="el" href="classVc_1_1Mask.html">Mask</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVc_1_1Mask.html#afa003d1118d02313dcaf8bb64912f81e">shifted</a> (int amount) const </td></tr>
<tr class="memdesc:afa003d1118d02313dcaf8bb64912f81e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a mask with components shifted by <code>amount</code> places. <br /></td></tr>
<tr class="separator:afa003d1118d02313dcaf8bb64912f81e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Compile-Time Constant Initialization</div></td></tr>
<tr class="memitem:ae48184c82f0406652dfe7d677d004470"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVc_1_1Mask.html#ae48184c82f0406652dfe7d677d004470">Mask</a> ()=default</td></tr>
<tr class="memdesc:ae48184c82f0406652dfe7d677d004470"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a zero-initialized vector object.  <a href="#ae48184c82f0406652dfe7d677d004470">More...</a><br /></td></tr>
<tr class="separator:ae48184c82f0406652dfe7d677d004470"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05753623c69bb6eb3274d1daa8ede253"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVc_1_1Mask.html#a05753623c69bb6eb3274d1daa8ede253">Mask</a> (VectorSpecialInitializerZero)</td></tr>
<tr class="memdesc:a05753623c69bb6eb3274d1daa8ede253"><td class="mdescLeft">&#160;</td><td class="mdescRight">Zero-initialize the new mask object (<code>false</code>).  <a href="#a05753623c69bb6eb3274d1daa8ede253">More...</a><br /></td></tr>
<tr class="separator:a05753623c69bb6eb3274d1daa8ede253"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2a33ac7668b69f369c4ccec9e3fe7cb"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVc_1_1Mask.html#ab2a33ac7668b69f369c4ccec9e3fe7cb">Mask</a> (VectorSpecialInitializerOne)</td></tr>
<tr class="memdesc:ab2a33ac7668b69f369c4ccec9e3fe7cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize the new mask object to one (<code>true</code>).  <a href="#ab2a33ac7668b69f369c4ccec9e3fe7cb">More...</a><br /></td></tr>
<tr class="separator:ab2a33ac7668b69f369c4ccec9e3fe7cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Conversion/Broadcast Constructors</div></td></tr>
<tr class="memitem:af6744e24b21a80acc6213e2d5eeaeb41"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVc_1_1Mask.html#af6744e24b21a80acc6213e2d5eeaeb41">Mask</a> (bool b)</td></tr>
<tr class="memdesc:af6744e24b21a80acc6213e2d5eeaeb41"><td class="mdescLeft">&#160;</td><td class="mdescRight">Broadcast constructor.  <a href="#af6744e24b21a80acc6213e2d5eeaeb41">More...</a><br /></td></tr>
<tr class="separator:af6744e24b21a80acc6213e2d5eeaeb41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc651a788c27619d80dcc94ce0e2bda4"><td class="memTemplParams" colspan="2">template&lt;typename U &gt; </td></tr>
<tr class="memitem:acc651a788c27619d80dcc94ce0e2bda4"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classVc_1_1Mask.html#acc651a788c27619d80dcc94ce0e2bda4">Mask</a> (U &amp;&amp;otherMask, Common::enable_if_mask_converts_implicitly&lt; T, U &gt;=nullarg)</td></tr>
<tr class="memdesc:acc651a788c27619d80dcc94ce0e2bda4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implicit conversion from a compatible (equal \(\mathcal{W}_\mathtt{T}\) on every platform) mask object.  <a href="#acc651a788c27619d80dcc94ce0e2bda4">More...</a><br /></td></tr>
<tr class="separator:acc651a788c27619d80dcc94ce0e2bda4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Loads &amp; Stores</div></td></tr>
<tr class="memitem:a51f078ac5cebddf00ee5e1ed8ae31506"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVc_1_1Mask.html#a51f078ac5cebddf00ee5e1ed8ae31506">Mask</a> (const bool *mem)</td></tr>
<tr class="memdesc:a51f078ac5cebddf00ee5e1ed8ae31506"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load constructor from an array of <code>bool</code>.  <a href="#a51f078ac5cebddf00ee5e1ed8ae31506">More...</a><br /></td></tr>
<tr class="separator:a51f078ac5cebddf00ee5e1ed8ae31506"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7eadaf3069893c0130db3dd6e315845"><td class="memTemplParams" colspan="2">template&lt;typename Flags &gt; </td></tr>
<tr class="memitem:ae7eadaf3069893c0130db3dd6e315845"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classVc_1_1Mask.html#ae7eadaf3069893c0130db3dd6e315845">Mask</a> (const bool *mem, Flags flags)</td></tr>
<tr class="memdesc:ae7eadaf3069893c0130db3dd6e315845"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overload of the above with a load/store flag argument.  <a href="#ae7eadaf3069893c0130db3dd6e315845">More...</a><br /></td></tr>
<tr class="separator:ae7eadaf3069893c0130db3dd6e315845"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a587a49eeafeaca6d87eddd82401a9770"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVc_1_1Mask.html#a587a49eeafeaca6d87eddd82401a9770">load</a> (const bool *mem)</td></tr>
<tr class="memdesc:a587a49eeafeaca6d87eddd82401a9770"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load the components of the mask from an array of <code>bool</code>.  <a href="#a587a49eeafeaca6d87eddd82401a9770">More...</a><br /></td></tr>
<tr class="separator:a587a49eeafeaca6d87eddd82401a9770"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38343ac76b1d41622098b7cfb7b2c581"><td class="memTemplParams" colspan="2">template&lt;typename Flags &gt; </td></tr>
<tr class="memitem:a38343ac76b1d41622098b7cfb7b2c581"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classVc_1_1Mask.html#a38343ac76b1d41622098b7cfb7b2c581">load</a> (const bool *mem, Flags flags)</td></tr>
<tr class="memdesc:a38343ac76b1d41622098b7cfb7b2c581"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overload of the above with a load/store flag argument.  <a href="#a38343ac76b1d41622098b7cfb7b2c581">More...</a><br /></td></tr>
<tr class="separator:a38343ac76b1d41622098b7cfb7b2c581"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d92871e55fa3993d9e319ba5d17edba"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVc_1_1Mask.html#a9d92871e55fa3993d9e319ba5d17edba">store</a> (bool *mem) const </td></tr>
<tr class="memdesc:a9d92871e55fa3993d9e319ba5d17edba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Store the values of the mask to an array of <code>bool</code>.  <a href="#a9d92871e55fa3993d9e319ba5d17edba">More...</a><br /></td></tr>
<tr class="separator:a9d92871e55fa3993d9e319ba5d17edba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90d7c70cadfe67341ae0417aeadb9429"><td class="memTemplParams" colspan="2">template&lt;typename Flags &gt; </td></tr>
<tr class="memitem:a90d7c70cadfe67341ae0417aeadb9429"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classVc_1_1Mask.html#a90d7c70cadfe67341ae0417aeadb9429">store</a> (bool *mem, Flags flags) const </td></tr>
<tr class="memdesc:a90d7c70cadfe67341ae0417aeadb9429"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overload of the above with a load/store flag argument.  <a href="#a90d7c70cadfe67341ae0417aeadb9429">More...</a><br /></td></tr>
<tr class="separator:a90d7c70cadfe67341ae0417aeadb9429"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Comparison Operators</div></td></tr>
<tr class="memitem:a00e4fa929532b52b765d064465fbdb71"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVc_1_1Mask.html#a00e4fa929532b52b765d064465fbdb71">operator==</a> (const <a class="el" href="classVc_1_1Mask.html">Mask</a> &amp;mask) const </td></tr>
<tr class="memdesc:a00e4fa929532b52b765d064465fbdb71"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether the two masks are equal in all components.  <a href="#a00e4fa929532b52b765d064465fbdb71">More...</a><br /></td></tr>
<tr class="separator:a00e4fa929532b52b765d064465fbdb71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac24e7eba4a6e8ef312971575fbec01e2"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVc_1_1Mask.html#ac24e7eba4a6e8ef312971575fbec01e2">operator!=</a> (const <a class="el" href="classVc_1_1Mask.html">Mask</a> &amp;mask) const </td></tr>
<tr class="memdesc:ac24e7eba4a6e8ef312971575fbec01e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether the two masks are different in at least one component.  <a href="#ac24e7eba4a6e8ef312971575fbec01e2">More...</a><br /></td></tr>
<tr class="separator:ac24e7eba4a6e8ef312971575fbec01e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Logical and Binary Operators</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>Component-wise logical/binary operations on mask objects.</p>
<p>The effect of logical and binary <code>AND</code> and <code>OR</code> is equivalent for mask types (as it is for <code>bool</code>). </p>
</div></td></tr>
<tr class="memitem:a86abc28967e14508669ec02f539de423"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a86abc28967e14508669ec02f539de423"></a>
<a class="el" href="classVc_1_1Mask.html">Mask</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVc_1_1Mask.html#a86abc28967e14508669ec02f539de423">operator&amp;&amp;</a> (const <a class="el" href="classVc_1_1Mask.html">Mask</a> &amp;mask) const </td></tr>
<tr class="memdesc:a86abc28967e14508669ec02f539de423"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the component-wise application of a logical <code>AND</code> to <code>mask</code>. <br /></td></tr>
<tr class="separator:a86abc28967e14508669ec02f539de423"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a0729b3f6f0a7f7278a27dc001c8e2b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8a0729b3f6f0a7f7278a27dc001c8e2b"></a>
<a class="el" href="classVc_1_1Mask.html">Mask</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVc_1_1Mask.html#a8a0729b3f6f0a7f7278a27dc001c8e2b">operator&amp;</a> (const <a class="el" href="classVc_1_1Mask.html">Mask</a> &amp;mask) const </td></tr>
<tr class="memdesc:a8a0729b3f6f0a7f7278a27dc001c8e2b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the component-wise application of a binary <code>AND</code> to <code>mask</code>. <br /></td></tr>
<tr class="separator:a8a0729b3f6f0a7f7278a27dc001c8e2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e5c883aefdb766dc155de0ac0264dee"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4e5c883aefdb766dc155de0ac0264dee"></a>
<a class="el" href="classVc_1_1Mask.html">Mask</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVc_1_1Mask.html#a4e5c883aefdb766dc155de0ac0264dee">operator||</a> (const <a class="el" href="classVc_1_1Mask.html">Mask</a> &amp;mask) const </td></tr>
<tr class="memdesc:a4e5c883aefdb766dc155de0ac0264dee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the component-wise application of a logical <code>OR</code> to <code>mask</code>. <br /></td></tr>
<tr class="separator:a4e5c883aefdb766dc155de0ac0264dee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae93f4951e68b19575ef3e48dccdc7714"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae93f4951e68b19575ef3e48dccdc7714"></a>
<a class="el" href="classVc_1_1Mask.html">Mask</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVc_1_1Mask.html#ae93f4951e68b19575ef3e48dccdc7714">operator|</a> (const <a class="el" href="classVc_1_1Mask.html">Mask</a> &amp;mask) const </td></tr>
<tr class="memdesc:ae93f4951e68b19575ef3e48dccdc7714"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the component-wise application of a binary <code>OR</code> to <code>mask</code>. <br /></td></tr>
<tr class="separator:ae93f4951e68b19575ef3e48dccdc7714"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa943fb6a6dd8ebd54a6fc5d99f081a6d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa943fb6a6dd8ebd54a6fc5d99f081a6d"></a>
<a class="el" href="classVc_1_1Mask.html">Mask</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVc_1_1Mask.html#aa943fb6a6dd8ebd54a6fc5d99f081a6d">operator^</a> (const <a class="el" href="classVc_1_1Mask.html">Mask</a> &amp;mask) const </td></tr>
<tr class="memdesc:aa943fb6a6dd8ebd54a6fc5d99f081a6d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the component-wise application of a binary <code>XOR</code> to <code>mask</code>. <br /></td></tr>
<tr class="separator:aa943fb6a6dd8ebd54a6fc5d99f081a6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68c05b183b0c85c133955704ed90aa69"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a68c05b183b0c85c133955704ed90aa69"></a>
<a class="el" href="classVc_1_1Mask.html">Mask</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVc_1_1Mask.html#a68c05b183b0c85c133955704ed90aa69">operator!</a> () const </td></tr>
<tr class="memdesc:a68c05b183b0c85c133955704ed90aa69"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a mask with inverted components. <br /></td></tr>
<tr class="separator:a68c05b183b0c85c133955704ed90aa69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0949879b1fbd5ed8689b13e262a8a6ca"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0949879b1fbd5ed8689b13e262a8a6ca"></a>
<a class="el" href="classVc_1_1Mask.html">Mask</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVc_1_1Mask.html#a0949879b1fbd5ed8689b13e262a8a6ca">operator&amp;=</a> (const <a class="el" href="classVc_1_1Mask.html">Mask</a> &amp;mask)</td></tr>
<tr class="memdesc:a0949879b1fbd5ed8689b13e262a8a6ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Modifies the mask using an <code>AND</code> operation with <code>mask</code>. <br /></td></tr>
<tr class="separator:a0949879b1fbd5ed8689b13e262a8a6ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abadcdc8f19bcc2ca6b043246c9ca720a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abadcdc8f19bcc2ca6b043246c9ca720a"></a>
<a class="el" href="classVc_1_1Mask.html">Mask</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVc_1_1Mask.html#abadcdc8f19bcc2ca6b043246c9ca720a">operator|=</a> (const <a class="el" href="classVc_1_1Mask.html">Mask</a> &amp;mask)</td></tr>
<tr class="memdesc:abadcdc8f19bcc2ca6b043246c9ca720a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Modifies the mask using an <code>OR</code> operation with <code>mask</code>. <br /></td></tr>
<tr class="separator:abadcdc8f19bcc2ca6b043246c9ca720a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae332b76ae88262b62e28ec052ce4f5e3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae332b76ae88262b62e28ec052ce4f5e3"></a>
<a class="el" href="classVc_1_1Mask.html">Mask</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVc_1_1Mask.html#ae332b76ae88262b62e28ec052ce4f5e3">operator^=</a> (const <a class="el" href="classVc_1_1Mask.html">Mask</a> &amp;mask)</td></tr>
<tr class="memdesc:ae332b76ae88262b62e28ec052ce4f5e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Modifies the mask using an <code>XOR</code> operation with <code>mask</code>. <br /></td></tr>
<tr class="separator:ae332b76ae88262b62e28ec052ce4f5e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Reductions</div></td></tr>
<tr><td colspan="2"><div class="groupText"><dl class="section see"><dt>See also</dt><dd><a class="el" href="group__Utilities.html#ga0e357178e07b595d2e7879ca2b2c62e0" title="Returns whether at least one entry in the mask m is true. ">any_of</a>, <a class="el" href="group__Utilities.html#gaccfe8b53188a645a5c78e283defb0d23" title="Returns whether all entries in the mask m are true. ">all_of</a>, <a class="el" href="group__Utilities.html#gabe433dbbaa1f39731be6d183269cee3d" title="Returns whether all entries in the mask m are false. ">none_of</a>, <a class="el" href="group__Utilities.html#ga0d1f3affaf171f27a677d71501feb7ca" title="Returns whether at least one entry in m is true and at least one entry in m is false. ">some_of</a> </dd></dl>
</div></td></tr>
<tr class="memitem:a7ffe8a6212a0eb3fc7bbc8e9bc51dfcd"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7ffe8a6212a0eb3fc7bbc8e9bc51dfcd"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVc_1_1Mask.html#a7ffe8a6212a0eb3fc7bbc8e9bc51dfcd">isFull</a> () const </td></tr>
<tr class="memdesc:a7ffe8a6212a0eb3fc7bbc8e9bc51dfcd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a logical <code>AND</code> of all components. <br /></td></tr>
<tr class="separator:a7ffe8a6212a0eb3fc7bbc8e9bc51dfcd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac568746e2ae1664e31c42d4762abd391"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac568746e2ae1664e31c42d4762abd391"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVc_1_1Mask.html#ac568746e2ae1664e31c42d4762abd391">isNotEmpty</a> () const </td></tr>
<tr class="memdesc:ac568746e2ae1664e31c42d4762abd391"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a logical <code>OR</code> of all components. <br /></td></tr>
<tr class="separator:ac568746e2ae1664e31c42d4762abd391"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a479432127ee77145cc19d6a2d1590821"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a479432127ee77145cc19d6a2d1590821"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVc_1_1Mask.html#a479432127ee77145cc19d6a2d1590821">isEmpty</a> () const </td></tr>
<tr class="memdesc:a479432127ee77145cc19d6a2d1590821"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>true</code> if components are <code>false</code>, <code>false</code> otherwise. <br /></td></tr>
<tr class="separator:a479432127ee77145cc19d6a2d1590821"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62c98c8dfec1d613c4852926e9b787e9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a62c98c8dfec1d613c4852926e9b787e9"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVc_1_1Mask.html#a62c98c8dfec1d613c4852926e9b787e9">isMix</a> () const </td></tr>
<tr class="memdesc:a62c98c8dfec1d613c4852926e9b787e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>!isFull() &amp;&amp; !isEmpty()</code>. <br /></td></tr>
<tr class="separator:a62c98c8dfec1d613c4852926e9b787e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr><td colspan="2"><div class="groupHeader">Scalar Subscript Operators</div></td></tr>
<tr class="memitem:ae0f6159e65556d0cdcb735447e8a8b42"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classVc_1_1Mask.html#a70a0859ec263806a8067448f6b70b708">EntryReference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVc_1_1Mask.html#ae0f6159e65556d0cdcb735447e8a8b42">operator[]</a> (size_t index)</td></tr>
<tr class="memdesc:ae0f6159e65556d0cdcb735447e8a8b42"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lvalue-reference-like access to mask entries.  <a href="#ae0f6159e65556d0cdcb735447e8a8b42">More...</a><br /></td></tr>
<tr class="separator:ae0f6159e65556d0cdcb735447e8a8b42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd739ea8d2b44ff32db834a4200e405f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classVc_1_1Mask.html#af8d79876e53834654a2c408d3a3bca6a">EntryType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVc_1_1Mask.html#abd739ea8d2b44ff32db834a4200e405f">operator[]</a> (size_t index) const </td></tr>
<tr class="memdesc:abd739ea8d2b44ff32db834a4200e405f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read-only access to mask entries.  <a href="#abd739ea8d2b44ff32db834a4200e405f">More...</a><br /></td></tr>
<tr class="separator:abd739ea8d2b44ff32db834a4200e405f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">new/delete overloads for correct alignment</div></td></tr>
<tr class="memitem:a205ed048fdf5259c2e8e0cb60ee8f719"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a205ed048fdf5259c2e8e0cb60ee8f719"></a>
void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVc_1_1Mask.html#a205ed048fdf5259c2e8e0cb60ee8f719">operator new</a> (size_t <a class="el" href="classVc_1_1Mask.html#a1b5d7e2e663d7997796fd9f72b8af75a">size</a>)</td></tr>
<tr class="memdesc:a205ed048fdf5259c2e8e0cb60ee8f719"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocates correctly aligned memory. <br /></td></tr>
<tr class="separator:a205ed048fdf5259c2e8e0cb60ee8f719"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a32ddebc54410cf59dec423c0b0791b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0a32ddebc54410cf59dec423c0b0791b"></a>
void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVc_1_1Mask.html#a0a32ddebc54410cf59dec423c0b0791b">operator new</a> (size_t, void *p)</td></tr>
<tr class="memdesc:a0a32ddebc54410cf59dec423c0b0791b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>p</code>. <br /></td></tr>
<tr class="separator:a0a32ddebc54410cf59dec423c0b0791b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63ce4f64887b9307317aee5baae6b18f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a63ce4f64887b9307317aee5baae6b18f"></a>
void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVc_1_1Mask.html#a63ce4f64887b9307317aee5baae6b18f">operator new[]</a> (size_t <a class="el" href="classVc_1_1Mask.html#a1b5d7e2e663d7997796fd9f72b8af75a">size</a>)</td></tr>
<tr class="memdesc:a63ce4f64887b9307317aee5baae6b18f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocates correctly aligned memory. <br /></td></tr>
<tr class="separator:a63ce4f64887b9307317aee5baae6b18f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f5a0f061d65c77264411a2914503659"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7f5a0f061d65c77264411a2914503659"></a>
void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVc_1_1Mask.html#a7f5a0f061d65c77264411a2914503659">operator new[]</a> (size_t, void *p)</td></tr>
<tr class="memdesc:a7f5a0f061d65c77264411a2914503659"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>p</code>. <br /></td></tr>
<tr class="separator:a7f5a0f061d65c77264411a2914503659"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22999735d5b1e1cb645614d22f108611"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a22999735d5b1e1cb645614d22f108611"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVc_1_1Mask.html#a22999735d5b1e1cb645614d22f108611">operator delete</a> (void *ptr, size_t)</td></tr>
<tr class="memdesc:a22999735d5b1e1cb645614d22f108611"><td class="mdescLeft">&#160;</td><td class="mdescRight">Frees aligned memory. <br /></td></tr>
<tr class="separator:a22999735d5b1e1cb645614d22f108611"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41d83e8020f1d841b254be6ebeda92d2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a41d83e8020f1d841b254be6ebeda92d2"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVc_1_1Mask.html#a41d83e8020f1d841b254be6ebeda92d2">operator delete</a> (void *, void *)</td></tr>
<tr class="memdesc:a41d83e8020f1d841b254be6ebeda92d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Does nothing. <br /></td></tr>
<tr class="separator:a41d83e8020f1d841b254be6ebeda92d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abefd12c9bd2fa9cd4a27cdabf64b03f8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abefd12c9bd2fa9cd4a27cdabf64b03f8"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVc_1_1Mask.html#abefd12c9bd2fa9cd4a27cdabf64b03f8">operator delete[]</a> (void *ptr, size_t)</td></tr>
<tr class="memdesc:abefd12c9bd2fa9cd4a27cdabf64b03f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Frees aligned memory. <br /></td></tr>
<tr class="separator:abefd12c9bd2fa9cd4a27cdabf64b03f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afea8decef8f286c8d73c89a1a81d4555"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afea8decef8f286c8d73c89a1a81d4555"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVc_1_1Mask.html#afea8decef8f286c8d73c89a1a81d4555">operator delete[]</a> (void *, void *)</td></tr>
<tr class="memdesc:afea8decef8f286c8d73c89a1a81d4555"><td class="mdescLeft">&#160;</td><td class="mdescRight">Does nothing. <br /></td></tr>
<tr class="separator:afea8decef8f286c8d73c89a1a81d4555"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a1b5d7e2e663d7997796fd9f72b8af75a"><td class="memItemLeft" align="right" valign="top">static constexpr size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVc_1_1Mask.html#a1b5d7e2e663d7997796fd9f72b8af75a">size</a> ()</td></tr>
<tr class="memdesc:a1b5d7e2e663d7997796fd9f72b8af75a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of boolean components ( \(\mathcal{W}_\mathtt{T}\)) in a mask of this type.  <a href="#a1b5d7e2e663d7997796fd9f72b8af75a">More...</a><br /></td></tr>
<tr class="separator:a1b5d7e2e663d7997796fd9f72b8af75a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Generators</div></td></tr>
<tr class="memitem:a2be492a48f12ce0897fe60bf8980ebea"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classVc_1_1Mask.html">Mask</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVc_1_1Mask.html#a2be492a48f12ce0897fe60bf8980ebea">Zero</a> ()</td></tr>
<tr class="memdesc:a2be492a48f12ce0897fe60bf8980ebea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new mask object initialized to zero/<code>false</code>.  <a href="#a2be492a48f12ce0897fe60bf8980ebea">More...</a><br /></td></tr>
<tr class="separator:a2be492a48f12ce0897fe60bf8980ebea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9872d89a68448bcfdde4160df3229fb8"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classVc_1_1Mask.html">Mask</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVc_1_1Mask.html#a9872d89a68448bcfdde4160df3229fb8">One</a> ()</td></tr>
<tr class="memdesc:a9872d89a68448bcfdde4160df3229fb8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a mask object initialized to one/<code>true</code>.  <a href="#a9872d89a68448bcfdde4160df3229fb8">More...</a><br /></td></tr>
<tr class="separator:a9872d89a68448bcfdde4160df3229fb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d73e61b7aabfd8cb0070814f8e1897c"><td class="memTemplParams" colspan="2"><a class="anchor" id="a1d73e61b7aabfd8cb0070814f8e1897c"></a>
template&lt;typename G &gt; </td></tr>
<tr class="memitem:a1d73e61b7aabfd8cb0070814f8e1897c"><td class="memTemplItemLeft" align="right" valign="top">static <a class="el" href="classVc_1_1Mask.html">Mask</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classVc_1_1Mask.html#a1d73e61b7aabfd8cb0070814f8e1897c">generate</a> (G &amp;&amp;gen)</td></tr>
<tr class="memdesc:a1d73e61b7aabfd8cb0070814f8e1897c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate a mask object from booleans returned from the function <code>gen</code>. <br /></td></tr>
<tr class="separator:a1d73e61b7aabfd8cb0070814f8e1897c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:a879ad9933a419e4e04c8a59cc19a34fe"><td class="memItemLeft" align="right" valign="top">static constexpr size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVc_1_1Mask.html#a879ad9933a419e4e04c8a59cc19a34fe">Size</a> = VectorTraits&lt;T, Abi&gt;::<a class="el" href="classVc_1_1Mask.html#a1b5d7e2e663d7997796fd9f72b8af75a">size</a>()</td></tr>
<tr class="memdesc:a879ad9933a419e4e04c8a59cc19a34fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of boolean components ( \(\mathcal{W}_\mathtt{T}\)) in a mask of this type.  <a href="#a879ad9933a419e4e04c8a59cc19a34fe">More...</a><br /></td></tr>
<tr class="separator:a879ad9933a419e4e04c8a59cc19a34fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d80568e435be601eb87ade3966eda21"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9d80568e435be601eb87ade3966eda21"></a>
static constexpr size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVc_1_1Mask.html#a9d80568e435be601eb87ade3966eda21">MemoryAlignment</a> = VectorTraits&lt;T, Abi&gt;::maskMemoryAlignment()</td></tr>
<tr class="memdesc:a9d80568e435be601eb87ade3966eda21"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specifies the alignment requirement for aligned load and store calls for objects of this mask type. <br /></td></tr>
<tr class="separator:a9d80568e435be601eb87ade3966eda21"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Member Typedef Documentation</h2>
<a class="anchor" id="af58a233cf0cdf62369686dd5798bd589"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classVc_1_1Mask.html#af58a233cf0cdf62369686dd5798bd589">value_type</a> =  <a class="el" href="classVc_1_1Mask.html#af8d79876e53834654a2c408d3a3bca6a">EntryType</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The <code>EntryType</code> of masks is always <code>bool</code>, independent of <code>T</code>. </p>

<p>Definition at line <a class="el" href="mask_8h_source.html#l00076">76</a> of file <a class="el" href="mask_8h_source.html">mask.h</a>.</p>

</div>
</div>
<a class="anchor" id="a83c8f8c1ebbda813702f777d870356ce"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classVc_1_1Mask.html#a83c8f8c1ebbda813702f777d870356ce">value_reference</a> =  <a class="el" href="classVc_1_1Mask.html#a70a0859ec263806a8067448f6b70b708">EntryReference</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The reference wrapper type used for accessing individual mask components. </p>

<p>Definition at line <a class="el" href="mask_8h_source.html#l00081">81</a> of file <a class="el" href="mask_8h_source.html">mask.h</a>.</p>

</div>
</div>
<a class="anchor" id="a2c3595d34ff3a3ad8ddf57a9225cd32b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classVc_1_1Mask.html#a2c3595d34ff3a3ad8ddf57a9225cd32b">VectorEntryType</a> =  typename VectorTraits&lt;T, Abi&gt;::<a class="el" href="classVc_1_1Mask.html#a2c3595d34ff3a3ad8ddf57a9225cd32b">VectorEntryType</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The <code>VectorEntryType</code>, in contrast to <code>EntryType</code>, reveals information about the SIMD implementation. </p>
<p>This type is useful for the <code>sizeof</code> operator in generic functions. </p>

<p>Definition at line <a class="el" href="mask_8h_source.html#l00088">88</a> of file <a class="el" href="mask_8h_source.html">mask.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="ae48184c82f0406652dfe7d677d004470"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVc_1_1Mask.html">Mask</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct a zero-initialized vector object. </p>
<p>This constructor follows the behavior of the underlying <code>bool</code> type in that the expression <code>bool()</code> zero-initializes the object (to <code>false</code>). On the other hand the variable <code>x</code> in <code>bool x;</code> is uninitialized. Since, for class types, both expressions call the default constructor <code><a class="el" href="classVc_1_1Mask.html" title="The main SIMD mask class. ">Mask</a>&lt;T&gt; x</code> must zero-initialize <code>x</code> as well. </p>

</div>
</div>
<a class="anchor" id="a05753623c69bb6eb3274d1daa8ede253"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVc_1_1Mask.html">Mask</a> </td>
          <td>(</td>
          <td class="paramtype">VectorSpecialInitializerZero&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Zero-initialize the new mask object (<code>false</code>). </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__Utilities.html#gad24df8f04b4b68f7e992aeb8b449cdf2" title="The special object Vc::Zero can be used to construct Vector and Mask objects initialized to zero/fals...">Vc::Zero</a>, <a class="el" href="classVc_1_1Mask.html#a2be492a48f12ce0897fe60bf8980ebea" title="Creates a new mask object initialized to zero/false. ">Zero()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ab2a33ac7668b69f369c4ccec9e3fe7cb"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVc_1_1Mask.html">Mask</a> </td>
          <td>(</td>
          <td class="paramtype">VectorSpecialInitializerOne&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initialize the new mask object to one (<code>true</code>). </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__Utilities.html#ga7dc0e380f66c4c791b7bf95df154b3c6" title="The special object Vc::One can be used to construct Vector and Mask objects initialized to one/true...">Vc::One</a>, <a class="el" href="classVc_1_1Mask.html#a9872d89a68448bcfdde4160df3229fb8" title="Creates a mask object initialized to one/true. ">One()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="af6744e24b21a80acc6213e2d5eeaeb41"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVc_1_1Mask.html">Mask</a> </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>b</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Broadcast constructor. </p>
<p>Set all components of the new mask object to <code>b</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">b</td><td>Determines the initial state of the mask. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="acc651a788c27619d80dcc94ce0e2bda4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVc_1_1Mask.html">Mask</a> </td>
          <td>(</td>
          <td class="paramtype">U &amp;&amp;&#160;</td>
          <td class="paramname"><em>otherMask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Common::enable_if_mask_converts_implicitly&lt; T, U &gt;&#160;</td>
          <td class="paramname"> = <code>nullarg</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implicit conversion from a compatible (equal \(\mathcal{W}_\mathtt{T}\) on every platform) mask object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">otherMask</td><td>The mask to be converted. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a51f078ac5cebddf00ee5e1ed8ae31506"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVc_1_1Mask.html">Mask</a> </td>
          <td>(</td>
          <td class="paramtype">const bool *&#160;</td>
          <td class="paramname"><em>mem</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Load constructor from an array of <code>bool</code>. </p>
<p>This constructor implements an explicit conversion from an array of booleans to a mask object. It corresponds to a <a class="el" href="classVc_1_1Vector.html" title="The main vector class for expressing data parallelism. ">Vector</a> load constructor.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mem</td><td>A pointer to the start of the array of booleans. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classVc_1_1Mask.html#ae7eadaf3069893c0130db3dd6e315845" title="Overload of the above with a load/store flag argument. ">Mask(const bool *, Flags)</a>, <a class="el" href="classVc_1_1Mask.html#a587a49eeafeaca6d87eddd82401a9770" title="Load the components of the mask from an array of bool. ">load(const bool *)</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ae7eadaf3069893c0130db3dd6e315845"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVc_1_1Mask.html">Mask</a> </td>
          <td>(</td>
          <td class="paramtype">const bool *&#160;</td>
          <td class="paramname"><em>mem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Flags&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Overload of the above with a load/store flag argument. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mem</td><td>A pointer to the start of the array of booleans. </td></tr>
    <tr><td class="paramname">flags</td><td>Choose a combination of flags such as <a class="el" href="group__Utilities.html#ga9e53bd74b9a47cb8f16bf12018c3670e" title="Use this object for a flags parameter to request aligned loads and stores. ">Vc::Aligned</a>, <a class="el" href="group__Utilities.html#gadc83bcfec8f15d1d02fb53baa3f38185" title="Use this object for a flags parameter to request streaming loads and stores. ">Vc::Streaming</a>, <a class="el" href="group__Utilities.html#ga91774bc3f3fc00d22deff300919d811c" title="Use this object for a flags parameter to request unaligned loads and stores. ">Vc::Unaligned</a>, <a class="el" href="group__Utilities.html#ga3bed7ba639e9ef78c79421c801b43e59" title="Use this object for a flags parameter to request default software prefetches to be emitted...">Vc::PrefetchDefault</a>, ... </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classVc_1_1Mask.html#a38343ac76b1d41622098b7cfb7b2c581" title="Overload of the above with a load/store flag argument. ">load(const bool *, Flags)</a> </dd></dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a1b5d7e2e663d7997796fd9f72b8af75a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr size_t size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of boolean components ( \(\mathcal{W}_\mathtt{T}\)) in a mask of this type. </p>
<p>The size of the mask. I.e. the number of boolean entries in the mask. Do not make any assumptions about the size of masks.</p>
<p>In addition, you can easily use if clauses that compare sizes. The compiler can statically evaluate and fully optimize dead code away (very much like #ifdef, but with syntax checking).</p>
<dl class="section return"><dt>Returns</dt><dd>The number of components (i.e. \(\mathcal{W}_\mathtt{T}\)) objects of this mask type store and manipulate. </dd></dl>

<p>Definition at line <a class="el" href="mask_8h_source.html#l00057">57</a> of file <a class="el" href="mask_8h_source.html">mask.h</a>.</p>

</div>
</div>
<a class="anchor" id="a2be492a48f12ce0897fe60bf8980ebea"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classVc_1_1Mask.html">Mask</a> Zero </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new mask object initialized to zero/<code>false</code>. </p>
<dl class="section return"><dt>Returns</dt><dd>A mask object with zero-initialized components. </dd></dl>

</div>
</div>
<a class="anchor" id="a9872d89a68448bcfdde4160df3229fb8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classVc_1_1Mask.html">Mask</a> One </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a mask object initialized to one/<code>true</code>. </p>
<dl class="section return"><dt>Returns</dt><dd>A mask object with components initialized to <code>true</code>. </dd></dl>

</div>
</div>
<a class="anchor" id="a587a49eeafeaca6d87eddd82401a9770"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void load </td>
          <td>(</td>
          <td class="paramtype">const bool *&#160;</td>
          <td class="paramname"><em>mem</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Load the components of the mask from an array of <code>bool</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mem</td><td>A pointer to the start of the array of booleans. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classVc_1_1Mask.html#a38343ac76b1d41622098b7cfb7b2c581" title="Overload of the above with a load/store flag argument. ">load(const bool *, Flags)</a>, <a class="el" href="classVc_1_1Mask.html#a51f078ac5cebddf00ee5e1ed8ae31506" title="Load constructor from an array of bool. ">Mask(const bool *)</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a38343ac76b1d41622098b7cfb7b2c581"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void load </td>
          <td>(</td>
          <td class="paramtype">const bool *&#160;</td>
          <td class="paramname"><em>mem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Flags&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Overload of the above with a load/store flag argument. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mem</td><td>A pointer to the start of the array of booleans. </td></tr>
    <tr><td class="paramname">flags</td><td>Choose a combination of flags such as <a class="el" href="group__Utilities.html#ga9e53bd74b9a47cb8f16bf12018c3670e" title="Use this object for a flags parameter to request aligned loads and stores. ">Vc::Aligned</a>, <a class="el" href="group__Utilities.html#gadc83bcfec8f15d1d02fb53baa3f38185" title="Use this object for a flags parameter to request streaming loads and stores. ">Vc::Streaming</a>, <a class="el" href="group__Utilities.html#ga91774bc3f3fc00d22deff300919d811c" title="Use this object for a flags parameter to request unaligned loads and stores. ">Vc::Unaligned</a>, <a class="el" href="group__Utilities.html#ga3bed7ba639e9ef78c79421c801b43e59" title="Use this object for a flags parameter to request default software prefetches to be emitted...">Vc::PrefetchDefault</a>, ... </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classVc_1_1Mask.html#ae7eadaf3069893c0130db3dd6e315845" title="Overload of the above with a load/store flag argument. ">Mask(const bool *, Flags)</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a9d92871e55fa3993d9e319ba5d17edba"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void store </td>
          <td>(</td>
          <td class="paramtype">bool *&#160;</td>
          <td class="paramname"><em>mem</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Store the values of the mask to an array of <code>bool</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mem</td><td>A pointer to the start of the array of booleans. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd>store(bool *, Flags) </dd></dl>

</div>
</div>
<a class="anchor" id="a90d7c70cadfe67341ae0417aeadb9429"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void store </td>
          <td>(</td>
          <td class="paramtype">bool *&#160;</td>
          <td class="paramname"><em>mem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Flags&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Overload of the above with a load/store flag argument. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mem</td><td>A pointer to the start of the array of booleans. </td></tr>
    <tr><td class="paramname">flags</td><td>Choose a combination of flags such as <a class="el" href="group__Utilities.html#ga9e53bd74b9a47cb8f16bf12018c3670e" title="Use this object for a flags parameter to request aligned loads and stores. ">Vc::Aligned</a>, <a class="el" href="group__Utilities.html#gadc83bcfec8f15d1d02fb53baa3f38185" title="Use this object for a flags parameter to request streaming loads and stores. ">Vc::Streaming</a>, <a class="el" href="group__Utilities.html#ga91774bc3f3fc00d22deff300919d811c" title="Use this object for a flags parameter to request unaligned loads and stores. ">Vc::Unaligned</a>, <a class="el" href="group__Utilities.html#ga3bed7ba639e9ef78c79421c801b43e59" title="Use this object for a flags parameter to request default software prefetches to be emitted...">Vc::PrefetchDefault</a>, ... </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a00e4fa929532b52b765d064465fbdb71"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classVc_1_1Mask.html">Mask</a>&lt; T, Abi &gt; &amp;&#160;</td>
          <td class="paramname"><em>mask</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns whether the two masks are equal in all components. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mask</td><td>The other mask to compare against. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A scalar boolean value that says whether all components of the two masks are equal.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>If you expected a behavior similar to the compare operator of <a class="el" href="classVc_1_1Vector.html" title="The main vector class for expressing data parallelism. ">Vc::Vector</a>, consider that the bitwise operators already implement such functionality. There is little use, typically, in having <code>a == b</code> return the same as <code>a ^ b</code>. In general, it is more useful to query <code>all_of(a ^ b)</code> which is the same as this equality operator. </dd></dl>

</div>
</div>
<a class="anchor" id="ac24e7eba4a6e8ef312971575fbec01e2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classVc_1_1Mask.html#a68c05b183b0c85c133955704ed90aa69">operator!</a>= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classVc_1_1Mask.html">Mask</a>&lt; T, Abi &gt; &amp;&#160;</td>
          <td class="paramname"><em>mask</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns whether the two masks are different in at least one component. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mask</td><td>The other mask to compare against. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A scalar boolean value that says whether at least one component of the two masks is different.</dd></dl>
<dl class="section note"><dt>Note</dt><dd><code>(a == b) == !(a != b)</code> holds </dd></dl>
<dl class="section see"><dt>See also</dt><dd>Mask::operator==(const Mask &amp;) </dd></dl>

</div>
</div>
<a class="anchor" id="ae0f6159e65556d0cdcb735447e8a8b42"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVc_1_1Mask.html#a70a0859ec263806a8067448f6b70b708">EntryReference</a> operator[] </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Lvalue-reference-like access to mask entries. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>Determines the boolean to be accessed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a temporary proxy object referencing the <code>index</code> th entry of the mask.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>This operator does not return an lvalue reference (to <code>bool</code>), but rather a temporary (rvalue) object that mimics an lvalue reference (as much as is possible with C++11/14). </dd></dl>

</div>
</div>
<a class="anchor" id="abd739ea8d2b44ff32db834a4200e405f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVc_1_1Mask.html#af8d79876e53834654a2c408d3a3bca6a">EntryType</a> operator[] </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read-only access to mask entries. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>Determines the boolean to be accessed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The <code>index</code> th entry of the mask as a <code>bool</code> (rvalue).</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>This operator does not return an lvalue reference (to <code>const bool</code>), but rather a temporary (rvalue) <code>bool</code>. </dd></dl>

</div>
</div>
<a class="anchor" id="adafff7979b5d1d4924e5a4fb4365a5e6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int firstOne </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the index of the first one in the mask. </p>
<dl class="section return"><dt>Returns</dt><dd>the index of the first component that is <code>true</code>.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>The return value is undefined if the mask is empty.</dd></dl>
<p>Thus, unless <code>none_of(mask)</code>, <code>mask[mask.firstOne()] == true</code> holds and <code>mask[i] == false</code> for all <code>i &lt; mask.firstOne()</code>. </p>

</div>
</div>
<a class="anchor" id="af7a5586bcba0f228f5acb3b37ebae263"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int toInt </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert the boolean components of the mask into bits of an integer. </p>
<dl class="section return"><dt>Returns</dt><dd>An <code>int</code> where each bit corresponds to the boolean value in the mask.</dd></dl>
<p>For example, the mask <code>[true, false, false, true]</code> results in a <code>9</code> (in binary: <code>1001</code>). </p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a class="anchor" id="a879ad9933a419e4e04c8a59cc19a34fe"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr size_t Size = VectorTraits&lt;T, Abi&gt;::<a class="el" href="classVc_1_1Mask.html#a1b5d7e2e663d7997796fd9f72b8af75a">size</a>()</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of boolean components ( \(\mathcal{W}_\mathtt{T}\)) in a mask of this type. </p>
<p>The size of the mask. I.e. the number of boolean entries in the mask. Do not make any assumptions about the size of masks.</p>
<p>In addition, you can easily use if clauses that compare sizes. The compiler can statically evaluate and fully optimize dead code away (very much like #ifdef, but with syntax checking).</p>
<dl class="section return"><dt>Returns</dt><dd>The number of components (i.e. \(\mathcal{W}_\mathtt{T}\)) objects of this mask type store and manipulate. </dd></dl>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000014">Deprecated:</a></b></dt><dd>Use <a class="el" href="classVc_1_1Mask.html#a1b5d7e2e663d7997796fd9f72b8af75a" title="Returns the number of boolean components ( ) in a mask of this type. ">Vc::Mask::size</a> instead. </dd></dl>

<p>Definition at line <a class="el" href="mask_8h_source.html#l00060">60</a> of file <a class="el" href="mask_8h_source.html">mask.h</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>/u/mkretz/src/.Vc-dox/common/<a class="el" href="mask_8h_source.html">mask.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespaceVc.html">Vc</a></li><li class="navelem"><a class="el" href="classVc_1_1Mask.html">Mask</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.10 </li>
  </ul>
</div>
</body>
</html>
