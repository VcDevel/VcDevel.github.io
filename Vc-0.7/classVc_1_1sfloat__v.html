<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>Vc: sfloat_v Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() {
    if ($('.searchresults').length > 0) { searchBox.DOMSearchField().focus(); }
  });
</script>
<link rel="search" href="search-opensearch.php?v=opensearch.xml" type="application/opensearchdescription+xml" title="Vc"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo_small.png"/></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">Vc
   &#160;<span id="projectnumber">0.7.5-dev</span>
   </div>
   <div id="projectbrief">SIMD Vector Classes for C++</div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
          <div class="left">
            <form id="FSearchBox" action="search.php" method="get">
              <img id="MSearchSelect" src="search/mag.png" alt=""/>
              <input type="text" id="MSearchField" name="query" value="Search" size="20" accesskey="S" 
                     onfocus="searchBox.OnSearchFieldFocus(true)" 
                     onblur="searchBox.OnSearchFieldFocus(false)"/>
            </form>
          </div><div class="right"></div>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.1.2 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('classVc_1_1sfloat__v.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="classVc_1_1sfloat__v-members.html">List of all members</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a>  </div>
  <div class="headertitle">
<div class="title">sfloat_v Class Reference<div class="ingroups"><a class="el" href="group__Vectors.html">Vectors</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2>Detailed Description</h2>
<div class="textblock"><p>SIMD <a class="el" href="classVc_1_1Vector.html" title="The main SIMD vector class.">Vector</a> of single precision floats that is guaranteed to have as many entries as a <a class="el" href="classVc_1_1short__v.html" title="SIMD Vector of 16 bit signed integers.">Vc::short_v</a> and <a class="el" href="classVc_1_1ushort__v.html" title="SIMD Vector of 16 bit unsigned integers.">Vc::ushort_v</a>. </p>
</div>
<p><code>#include &lt;Vc/sfloat_v&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a0411cd49bb5b71852cecd93bcbf0ca2d"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom">{ <a class="el" href="classVc_1_1sfloat__v.html#a0411cd49bb5b71852cecd93bcbf0ca2daff9abf2b1a689f70a77a18da50c01d9f">Size</a>
 }</td></tr>
<tr class="memitem:a2f81c70f5c0e71cbafd2b2928d03c626"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2f81c70f5c0e71cbafd2b2928d03c626"></a>
typedef <a class="el" href="classVc_1_1ushort__v.html">ushort_v</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVc_1_1sfloat__v.html#a2f81c70f5c0e71cbafd2b2928d03c626">IndexType</a></td></tr>
<tr class="memdesc:a2f81c70f5c0e71cbafd2b2928d03c626"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type of the vector used for indexes in gather and scatter operations. <br/></td></tr>
<tr class="memitem:a955f7da87ee570489300c2e249867398"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a955f7da87ee570489300c2e249867398"></a>
typedef float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVc_1_1sfloat__v.html#a955f7da87ee570489300c2e249867398">EntryType</a></td></tr>
<tr class="memdesc:a955f7da87ee570489300c2e249867398"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type of the entries in the vector. <br/></td></tr>
<tr class="memitem:ad4a9b113ca185343c3706f8cb40bb494"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad4a9b113ca185343c3706f8cb40bb494"></a>
typedef <a class="el" href="classVc_1_1sfloat__m.html">sfloat_m</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVc_1_1sfloat__v.html#ad4a9b113ca185343c3706f8cb40bb494">Mask</a></td></tr>
<tr class="memdesc:ad4a9b113ca185343c3706f8cb40bb494"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type of the mask used for masked operations and returned from comparisons. <br/></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ac8fcac04e8febf105e1413fd2a4bca11"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac8fcac04e8febf105e1413fd2a4bca11"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVc_1_1sfloat__v.html#ac8fcac04e8febf105e1413fd2a4bca11">sfloat_v</a> ()</td></tr>
<tr class="memdesc:ac8fcac04e8febf105e1413fd2a4bca11"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct an uninitialized vector. <br/></td></tr>
<tr class="memitem:a10d6c061475bf49bbd8be117d82fc72f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVc_1_1sfloat__v.html#a10d6c061475bf49bbd8be117d82fc72f">sfloat_v</a> (<a class="el" href="group__Vectors.html#gga637228b0c9f9022584b3df6248183205ab9f6920de535f04ccfe34d670fa2c8a8">Vc::Zero</a>)</td></tr>
<tr class="memdesc:a10d6c061475bf49bbd8be117d82fc72f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a vector with the entries initialized to zero.  <a href="#a10d6c061475bf49bbd8be117d82fc72f"></a><br/></td></tr>
<tr class="memitem:a58a340c9e6ba402d39d87547e5fdd6a1"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVc_1_1sfloat__v.html#a58a340c9e6ba402d39d87547e5fdd6a1">sfloat_v</a> (<a class="el" href="group__Vectors.html#gga637228b0c9f9022584b3df6248183205ad4e07130bf8ac301c327f0e64bc2d292">Vc::One</a>)</td></tr>
<tr class="memdesc:a58a340c9e6ba402d39d87547e5fdd6a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a vector with the entries initialized to one.  <a href="#a58a340c9e6ba402d39d87547e5fdd6a1"></a><br/></td></tr>
<tr class="memitem:aa0cf02594b51bfa829bb9f42f3656cea"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVc_1_1sfloat__v.html#aa0cf02594b51bfa829bb9f42f3656cea">sfloat_v</a> (<a class="el" href="group__Vectors.html#gga637228b0c9f9022584b3df6248183205a99c4e745942c50c80621dfef60705703">Vc::IndexesFromZero</a>)</td></tr>
<tr class="memdesc:aa0cf02594b51bfa829bb9f42f3656cea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a vector with the entries initialized to 0, 1, 2, 3, 4, 5, ...  <a href="#aa0cf02594b51bfa829bb9f42f3656cea"></a><br/></td></tr>
<tr class="memitem:a7cbf08e6688cf3e47bf0831e13d674b5"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVc_1_1sfloat__v.html#a7cbf08e6688cf3e47bf0831e13d674b5">sfloat_v</a> (float *alignedMemory)</td></tr>
<tr class="memdesc:a7cbf08e6688cf3e47bf0831e13d674b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a vector loading its entries from <code>alignedMemory</code>.  <a href="#a7cbf08e6688cf3e47bf0831e13d674b5"></a><br/></td></tr>
<tr class="memitem:aa94024584f26211e592198232edda831"><td class="memTemplParams" colspan="2"><a class="anchor" id="aa94024584f26211e592198232edda831"></a>
template&lt;typename OtherVector &gt; </td></tr>
<tr class="memitem:aa94024584f26211e592198232edda831"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classVc_1_1sfloat__v.html#aa94024584f26211e592198232edda831">sfloat_v</a> (const OtherVector &amp;)</td></tr>
<tr class="memdesc:aa94024584f26211e592198232edda831"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert from another vector type. <br/></td></tr>
<tr class="memitem:a36ea9a0bbcb19362caeb5d8ce4136b3e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVc_1_1sfloat__v.html#a36ea9a0bbcb19362caeb5d8ce4136b3e">sfloat_v</a> (float x)</td></tr>
<tr class="memdesc:a36ea9a0bbcb19362caeb5d8ce4136b3e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Broadcast Constructor.  <a href="#a36ea9a0bbcb19362caeb5d8ce4136b3e"></a><br/></td></tr>
<tr class="memitem:aa895397ab1f083a86a5879896740c9b3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVc_1_1sfloat__v.html#aa895397ab1f083a86a5879896740c9b3">load</a> (const float *memory, <a class="el" href="group__Vectors.html#ga9157aa15b51290e8511edf1e7172513b">LoadStoreFlags</a> align=<a class="el" href="group__Vectors.html#gga9157aa15b51290e8511edf1e7172513bad5380ca00f3d74b38593adf8a0d06d3e">Aligned</a>)</td></tr>
<tr class="memdesc:aa895397ab1f083a86a5879896740c9b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a vector from an array of vectors with different Size.  <a href="#aa895397ab1f083a86a5879896740c9b3"></a><br/></td></tr>
<tr class="memitem:a47affd1a10b589811fc4828c1a2e0c6d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a47affd1a10b589811fc4828c1a2e0c6d"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVc_1_1sfloat__v.html#a47affd1a10b589811fc4828c1a2e0c6d">setZero</a> ()</td></tr>
<tr class="memdesc:a47affd1a10b589811fc4828c1a2e0c6d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set all entries to zero. <br/></td></tr>
<tr class="memitem:a53e9dbb604a1769583d0e69343a9c9c8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVc_1_1sfloat__v.html#a53e9dbb604a1769583d0e69343a9c9c8">setZero</a> (const <a class="el" href="classVc_1_1sfloat__m.html">sfloat_m</a> &amp;mask)</td></tr>
<tr class="memdesc:a53e9dbb604a1769583d0e69343a9c9c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set all entries to zero where the mask is set.  <a href="#a53e9dbb604a1769583d0e69343a9c9c8"></a><br/></td></tr>
<tr class="memitem:a632d6009866794df04f8eb9918c6b802"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVc_1_1sfloat__v.html#a632d6009866794df04f8eb9918c6b802">store</a> (<a class="el" href="classVc_1_1sfloat__v.html#a955f7da87ee570489300c2e249867398">EntryType</a> *memory, <a class="el" href="group__Vectors.html#ga9157aa15b51290e8511edf1e7172513b">LoadStoreFlags</a> align=<a class="el" href="group__Vectors.html#gga9157aa15b51290e8511edf1e7172513bad5380ca00f3d74b38593adf8a0d06d3e">Aligned</a>) const </td></tr>
<tr class="memdesc:a632d6009866794df04f8eb9918c6b802"><td class="mdescLeft">&#160;</td><td class="mdescRight">Store the vector data to <code>memory</code>.  <a href="#a632d6009866794df04f8eb9918c6b802"></a><br/></td></tr>
<tr class="memitem:a6af89dec7a2dde3440c8983aa9ffaaa7"><td class="memItemLeft" align="right" valign="top">float &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVc_1_1sfloat__v.html#a6af89dec7a2dde3440c8983aa9ffaaa7">operator[]</a> (int index)</td></tr>
<tr class="memdesc:a6af89dec7a2dde3440c8983aa9ffaaa7"><td class="mdescLeft">&#160;</td><td class="mdescRight">This operator can be used to modify scalar entries of the vector.  <a href="#a6af89dec7a2dde3440c8983aa9ffaaa7"></a><br/></td></tr>
<tr class="memitem:a151eef77f4fc6db54a86ac7962f51298"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVc_1_1sfloat__v.html#a151eef77f4fc6db54a86ac7962f51298">operator[]</a> (int index) const </td></tr>
<tr class="memdesc:a151eef77f4fc6db54a86ac7962f51298"><td class="mdescLeft">&#160;</td><td class="mdescRight">This operator can be used to read scalar entries of the vector.  <a href="#a151eef77f4fc6db54a86ac7962f51298"></a><br/></td></tr>
<tr class="memitem:a9f958f4fb9d4c82123e2973b9b4f1b2d"><td class="memItemLeft" align="right" valign="top">MaskedVector&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVc_1_1sfloat__v.html#a9f958f4fb9d4c82123e2973b9b4f1b2d">operator()</a> (const <a class="el" href="classVc_1_1sfloat__m.html">sfloat_m</a> &amp;mask)</td></tr>
<tr class="memdesc:a9f958f4fb9d4c82123e2973b9b4f1b2d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writemask the vector before an assignment.  <a href="#a9f958f4fb9d4c82123e2973b9b4f1b2d"></a><br/></td></tr>
<tr class="memitem:aa19d201a89cb214b555f403023033ded"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classVc_1_1sfloat__v.html">sfloat_v</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVc_1_1sfloat__v.html#aa19d201a89cb214b555f403023033ded">sorted</a> () const </td></tr>
<tr class="memdesc:aa19d201a89cb214b555f403023033ded"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a sorted copy of the vector.  <a href="#aa19d201a89cb214b555f403023033ded"></a><br/></td></tr>
<tr class="memitem:a76698ef0ed65fc78feacfcd49732d411"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classVc_1_1sfloat__v.html">sfloat_v</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVc_1_1sfloat__v.html#a76698ef0ed65fc78feacfcd49732d411">copySign</a> (<a class="el" href="classVc_1_1sfloat__v.html">sfloat_v</a> reference) const </td></tr>
<tr class="memdesc:a76698ef0ed65fc78feacfcd49732d411"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies the sign of <code>reference</code>.  <a href="#a76698ef0ed65fc78feacfcd49732d411"></a><br/></td></tr>
<tr class="memitem:a9896cb0171bf56d11a183cd85d08a0ba"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classVc_1_1sfloat__v.html">sfloat_v</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVc_1_1sfloat__v.html#a9896cb0171bf56d11a183cd85d08a0ba">exponent</a> () const </td></tr>
<tr class="memdesc:a9896cb0171bf56d11a183cd85d08a0ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts the exponent.  <a href="#a9896cb0171bf56d11a183cd85d08a0ba"></a><br/></td></tr>
<tr class="memitem:ae2c7550ba227c1418f364f6cca49a493"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classVc_1_1sfloat__m.html">sfloat_m</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVc_1_1sfloat__v.html#ae2c7550ba227c1418f364f6cca49a493">isNegative</a> () const </td></tr>
<tr class="memdesc:ae2c7550ba227c1418f364f6cca49a493"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check the sign bit of each vector entry.  <a href="#ae2c7550ba227c1418f364f6cca49a493"></a><br/></td></tr>
<tr><td colspan="2"><div class="groupHeader">Gather and Scatter Functions</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>The gather and scatter functions allow you to easily use vectors with structured data and random accesses.</p>
<p>There are several variants: </p>
<ul>
<li>random access in arrays (a[i]) </li>
<li>random access of members of structs in an array (a[i].member) </li>
<li>random access of members of members of structs in an array (a[i].member1.member2)</li>
</ul>
<p>All gather and scatter functions optionally take a mask as last argument. In that case only the entries that are selected in the mask are read in memory and copied to the vector. This allows you to have invalid indexes in the <code>indexes</code> vector if those are masked off in <code>mask</code>.</p>
<dl class="section note"><dt>Note</dt><dd>If you use a constructor for a masked gather then the unmodified entries of the vector are initilized to 0 before the gather. If you really want them uninitialized you can create a uninitialized vector object first and then call the masked gather function on it.</dd></dl>
<p>The index type (IndexT) can either be a pointer to integers (array) or a vector of integers.</p>
<p>Accessing values of a struct works like this: </p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>MyData {</div>
<div class="line">  <span class="keywordtype">float</span> a;</div>
<div class="line">  <span class="keywordtype">int</span> b;</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">void</span> foo(MyData *data, uint_v indexes) {</div>
<div class="line">  <span class="keyword">const</span> float_v v1(data, &amp;MyData::a, indexes);</div>
<div class="line">  <span class="keyword">const</span> int_v   v2(data, &amp;MyData::b, indexes);</div>
<div class="line">  v1.scatter(data, &amp;MyData::a, indexes - <a class="code" href="classVc_1_1float__v.html#adf764cbdea00d65edcd07bb9953ad2b7aff9abf2b1a689f70a77a18da50c01d9f" title="The size of the vector.">float_v::Size</a>);</div>
<div class="line">  v2.scatter(data, &amp;MyData::b, indexes - 1);</div>
<div class="line">}</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">array</td><td>A pointer into memory (without alignment restrictions). </td></tr>
    <tr><td class="paramname">member1</td><td>If <code>array</code> points to a struct, <code>member1</code> determines the member in the struct to be read. Thus the offsets in <code>indexes</code> are relative to the <code>array</code> and not to the size of the gathered type (i.e. array[i].*member1 is accessed instead of (&amp;(array-&gt;*member1))[i]) </td></tr>
    <tr><td class="paramname">member2</td><td>If <code>member1</code> is a struct then <code>member2</code> selects the member to be read from that struct (i.e. array[i].*member1.*member2 is read). </td></tr>
    <tr><td class="paramname">indexes</td><td>Determines the offsets into <code>array</code> where the values are gathered from/scattered to. The type of indexes can either be an integer vector or a type that supports operator[] access. </td></tr>
    <tr><td class="paramname">mask</td><td>If a mask is given only the active entries will be gathered/scattered. </td></tr>
  </table>
  </dd>
</dl>
</div></td></tr>
<tr class="memitem:a648d3508df0b40dca09dbac84f200e99"><td class="memTemplParams" colspan="2"><a class="anchor" id="a648d3508df0b40dca09dbac84f200e99"></a>
template&lt;typename IndexT &gt; </td></tr>
<tr class="memitem:a648d3508df0b40dca09dbac84f200e99"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classVc_1_1sfloat__v.html#a648d3508df0b40dca09dbac84f200e99">sfloat_v</a> (const float *array, const IndexT indexes)</td></tr>
<tr class="memdesc:a648d3508df0b40dca09dbac84f200e99"><td class="mdescLeft">&#160;</td><td class="mdescRight">gather constructor <br/></td></tr>
<tr class="memitem:a61b4eb71aceec8e901b61801e02a52cd"><td class="memTemplParams" colspan="2"><a class="anchor" id="a61b4eb71aceec8e901b61801e02a52cd"></a>
template&lt;typename IndexT &gt; </td></tr>
<tr class="memitem:a61b4eb71aceec8e901b61801e02a52cd"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classVc_1_1sfloat__v.html#a61b4eb71aceec8e901b61801e02a52cd">sfloat_v</a> (const float *array, const IndexT indexes, const <a class="el" href="classVc_1_1sfloat__m.html">sfloat_m</a> &amp;mask)</td></tr>
<tr class="memdesc:a61b4eb71aceec8e901b61801e02a52cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">masked gather constructor, initialized to zero <br/></td></tr>
<tr class="memitem:a7b9f2b676e7700e5a9e5c69917457f83"><td class="memTemplParams" colspan="2"><a class="anchor" id="a7b9f2b676e7700e5a9e5c69917457f83"></a>
template&lt;typename IndexT &gt; </td></tr>
<tr class="memitem:a7b9f2b676e7700e5a9e5c69917457f83"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classVc_1_1sfloat__v.html#a7b9f2b676e7700e5a9e5c69917457f83">gather</a> (const float *array, const IndexT indexes)</td></tr>
<tr class="memdesc:a7b9f2b676e7700e5a9e5c69917457f83"><td class="mdescLeft">&#160;</td><td class="mdescRight">gather <br/></td></tr>
<tr class="memitem:afd8d5622aac058217555299363ebd916"><td class="memTemplParams" colspan="2"><a class="anchor" id="afd8d5622aac058217555299363ebd916"></a>
template&lt;typename IndexT &gt; </td></tr>
<tr class="memitem:afd8d5622aac058217555299363ebd916"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classVc_1_1sfloat__v.html#afd8d5622aac058217555299363ebd916">gather</a> (const float *array, const IndexT indexes, const <a class="el" href="classVc_1_1sfloat__m.html">sfloat_m</a> &amp;mask)</td></tr>
<tr class="memdesc:afd8d5622aac058217555299363ebd916"><td class="mdescLeft">&#160;</td><td class="mdescRight">masked gather <br/></td></tr>
<tr class="memitem:aea4c6e4a608429d3eee9439720d47db7"><td class="memTemplParams" colspan="2"><a class="anchor" id="aea4c6e4a608429d3eee9439720d47db7"></a>
template&lt;typename IndexT &gt; </td></tr>
<tr class="memitem:aea4c6e4a608429d3eee9439720d47db7"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classVc_1_1sfloat__v.html#aea4c6e4a608429d3eee9439720d47db7">scatter</a> (float *array, const IndexT indexes) const </td></tr>
<tr class="memdesc:aea4c6e4a608429d3eee9439720d47db7"><td class="mdescLeft">&#160;</td><td class="mdescRight">scatter <br/></td></tr>
<tr class="memitem:a5dd2393acb301937ce1fe306a8df3976"><td class="memTemplParams" colspan="2"><a class="anchor" id="a5dd2393acb301937ce1fe306a8df3976"></a>
template&lt;typename IndexT &gt; </td></tr>
<tr class="memitem:a5dd2393acb301937ce1fe306a8df3976"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classVc_1_1sfloat__v.html#a5dd2393acb301937ce1fe306a8df3976">scatter</a> (float *array, const IndexT indexes, const <a class="el" href="classVc_1_1sfloat__m.html">sfloat_m</a> &amp;mask) const </td></tr>
<tr class="memdesc:a5dd2393acb301937ce1fe306a8df3976"><td class="mdescLeft">&#160;</td><td class="mdescRight">masked scatter <br/></td></tr>
<tr class="memitem:ae48c2e487128544ec00dc48ad441a94f"><td class="memTemplParams" colspan="2"><a class="anchor" id="ae48c2e487128544ec00dc48ad441a94f"></a>
template&lt;typename S1 , typename IndexT &gt; </td></tr>
<tr class="memitem:ae48c2e487128544ec00dc48ad441a94f"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classVc_1_1sfloat__v.html#ae48c2e487128544ec00dc48ad441a94f">sfloat_v</a> (const S1 *array, const float S1::*member1, const IndexT indexes)</td></tr>
<tr class="memdesc:ae48c2e487128544ec00dc48ad441a94f"><td class="mdescLeft">&#160;</td><td class="mdescRight">struct member gather constructor <br/></td></tr>
<tr class="memitem:a0436dde7629329742781b5ebf5c739ce"><td class="memTemplParams" colspan="2"><a class="anchor" id="a0436dde7629329742781b5ebf5c739ce"></a>
template&lt;typename S1 , typename IndexT &gt; </td></tr>
<tr class="memitem:a0436dde7629329742781b5ebf5c739ce"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classVc_1_1sfloat__v.html#a0436dde7629329742781b5ebf5c739ce">sfloat_v</a> (const S1 *array, const float S1::*member1, const IndexT indexes, const <a class="el" href="classVc_1_1sfloat__m.html">sfloat_m</a> &amp;mask)</td></tr>
<tr class="memdesc:a0436dde7629329742781b5ebf5c739ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">masked struct member gather constructor, initialized to zero <br/></td></tr>
<tr class="memitem:ad89bb708a475c427516341d61a74a159"><td class="memTemplParams" colspan="2"><a class="anchor" id="ad89bb708a475c427516341d61a74a159"></a>
template&lt;typename S1 , typename IndexT &gt; </td></tr>
<tr class="memitem:ad89bb708a475c427516341d61a74a159"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classVc_1_1sfloat__v.html#ad89bb708a475c427516341d61a74a159">gather</a> (const S1 *array, const float S1::*member1, const IndexT indexes)</td></tr>
<tr class="memdesc:ad89bb708a475c427516341d61a74a159"><td class="mdescLeft">&#160;</td><td class="mdescRight">struct member gather <br/></td></tr>
<tr class="memitem:ac9c0311257217881d8a9c22bbf202617"><td class="memTemplParams" colspan="2"><a class="anchor" id="ac9c0311257217881d8a9c22bbf202617"></a>
template&lt;typename S1 , typename IndexT &gt; </td></tr>
<tr class="memitem:ac9c0311257217881d8a9c22bbf202617"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classVc_1_1sfloat__v.html#ac9c0311257217881d8a9c22bbf202617">gather</a> (const S1 *array, const float S1::*member1, const IndexT indexes, const <a class="el" href="classVc_1_1sfloat__m.html">sfloat_m</a> &amp;mask)</td></tr>
<tr class="memdesc:ac9c0311257217881d8a9c22bbf202617"><td class="mdescLeft">&#160;</td><td class="mdescRight">masked struct member gather <br/></td></tr>
<tr class="memitem:acdcd096c785d6e5b1a08e526c7f849dc"><td class="memTemplParams" colspan="2"><a class="anchor" id="acdcd096c785d6e5b1a08e526c7f849dc"></a>
template&lt;typename S1 , typename IndexT &gt; </td></tr>
<tr class="memitem:acdcd096c785d6e5b1a08e526c7f849dc"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classVc_1_1sfloat__v.html#acdcd096c785d6e5b1a08e526c7f849dc">scatter</a> (S1 *array, float S1::*member1, const IndexT indexes) const </td></tr>
<tr class="memdesc:acdcd096c785d6e5b1a08e526c7f849dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">struct member scatter <br/></td></tr>
<tr class="memitem:a05bd011d645c902d420f2b58b5d6b5a7"><td class="memTemplParams" colspan="2"><a class="anchor" id="a05bd011d645c902d420f2b58b5d6b5a7"></a>
template&lt;typename S1 , typename IndexT &gt; </td></tr>
<tr class="memitem:a05bd011d645c902d420f2b58b5d6b5a7"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classVc_1_1sfloat__v.html#a05bd011d645c902d420f2b58b5d6b5a7">scatter</a> (S1 *array, float S1::*member1, const IndexT indexes, const <a class="el" href="classVc_1_1sfloat__m.html">sfloat_m</a> &amp;mask) const </td></tr>
<tr class="memdesc:a05bd011d645c902d420f2b58b5d6b5a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">masked struct member scatter <br/></td></tr>
<tr class="memitem:a6a02995600f850f0571d523937eb6e4e"><td class="memTemplParams" colspan="2"><a class="anchor" id="a6a02995600f850f0571d523937eb6e4e"></a>
template&lt;typename S1 , typename S2 , typename IndexT &gt; </td></tr>
<tr class="memitem:a6a02995600f850f0571d523937eb6e4e"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classVc_1_1sfloat__v.html#a6a02995600f850f0571d523937eb6e4e">sfloat_v</a> (const S1 *array, const S2 S1::*member1, const float S2::*member2, const IndexT indexes)</td></tr>
<tr class="memdesc:a6a02995600f850f0571d523937eb6e4e"><td class="mdescLeft">&#160;</td><td class="mdescRight">struct member of struct member gather constructor <br/></td></tr>
<tr class="memitem:ad50d575cc1731d0a233a43017c5e234e"><td class="memTemplParams" colspan="2"><a class="anchor" id="ad50d575cc1731d0a233a43017c5e234e"></a>
template&lt;typename S1 , typename S2 , typename IndexT &gt; </td></tr>
<tr class="memitem:ad50d575cc1731d0a233a43017c5e234e"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classVc_1_1sfloat__v.html#ad50d575cc1731d0a233a43017c5e234e">sfloat_v</a> (const S1 *array, const S2 S1::*member1, const float S2::*member2, const IndexT indexes, const <a class="el" href="classVc_1_1sfloat__m.html">sfloat_m</a> &amp;mask)</td></tr>
<tr class="memdesc:ad50d575cc1731d0a233a43017c5e234e"><td class="mdescLeft">&#160;</td><td class="mdescRight">masked struct member of struct member gather constructor, initialized to zero <br/></td></tr>
<tr class="memitem:a4d253d3bb3064afdbac8e69b1a498283"><td class="memTemplParams" colspan="2"><a class="anchor" id="a4d253d3bb3064afdbac8e69b1a498283"></a>
template&lt;typename S1 , typename S2 , typename IndexT &gt; </td></tr>
<tr class="memitem:a4d253d3bb3064afdbac8e69b1a498283"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classVc_1_1sfloat__v.html#a4d253d3bb3064afdbac8e69b1a498283">gather</a> (const S1 *array, const S2 S1::*member1, const float S2::*member2, const IndexT indexes)</td></tr>
<tr class="memdesc:a4d253d3bb3064afdbac8e69b1a498283"><td class="mdescLeft">&#160;</td><td class="mdescRight">struct member of struct member gather <br/></td></tr>
<tr class="memitem:a86544d315c15ac82df9b2ec704f57301"><td class="memTemplParams" colspan="2"><a class="anchor" id="a86544d315c15ac82df9b2ec704f57301"></a>
template&lt;typename S1 , typename S2 , typename IndexT &gt; </td></tr>
<tr class="memitem:a86544d315c15ac82df9b2ec704f57301"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classVc_1_1sfloat__v.html#a86544d315c15ac82df9b2ec704f57301">gather</a> (const S1 *array, const S2 S1::*member1, const float S2::*member2, const IndexT indexes, const <a class="el" href="classVc_1_1sfloat__m.html">sfloat_m</a> &amp;mask)</td></tr>
<tr class="memdesc:a86544d315c15ac82df9b2ec704f57301"><td class="mdescLeft">&#160;</td><td class="mdescRight">masked struct member of struct member gather <br/></td></tr>
<tr class="memitem:a980ec250fcb22c399bcf608a326bfa7d"><td class="memTemplParams" colspan="2"><a class="anchor" id="a980ec250fcb22c399bcf608a326bfa7d"></a>
template&lt;typename S1 , typename S2 , typename IndexT &gt; </td></tr>
<tr class="memitem:a980ec250fcb22c399bcf608a326bfa7d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classVc_1_1sfloat__v.html#a980ec250fcb22c399bcf608a326bfa7d">scatter</a> (S1 *array, S2 S1::*member1, float S2::*member2, const IndexT indexes) const </td></tr>
<tr class="memdesc:a980ec250fcb22c399bcf608a326bfa7d"><td class="mdescLeft">&#160;</td><td class="mdescRight">struct member of struct member scatter <br/></td></tr>
<tr class="memitem:a0e873b581ca26856a37c430c0e790347"><td class="memTemplParams" colspan="2"><a class="anchor" id="a0e873b581ca26856a37c430c0e790347"></a>
template&lt;typename S1 , typename S2 , typename IndexT &gt; </td></tr>
<tr class="memitem:a0e873b581ca26856a37c430c0e790347"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classVc_1_1sfloat__v.html#a0e873b581ca26856a37c430c0e790347">scatter</a> (S1 *array, S2 S1::*member1, float S2::*member2, const IndexT indexes, const <a class="el" href="classVc_1_1sfloat__m.html">sfloat_m</a> &amp;mask) const </td></tr>
<tr class="memdesc:a0e873b581ca26856a37c430c0e790347"><td class="mdescLeft">&#160;</td><td class="mdescRight">maksed struct member of struct member scatter <br/></td></tr>
<tr><td colspan="2"><div class="groupHeader">Comparisons</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>All comparison operators return a mask object.</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> foo(<span class="keyword">const</span> float_v &amp;a, <span class="keyword">const</span> float_v &amp;b) {</div>
<div class="line">  <span class="keyword">const</span> float_m mask = a &lt; b;</div>
<div class="line">  ...</div>
<div class="line">}</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>The vector to compare with. </td></tr>
  </table>
  </dd>
</dl>
</div></td></tr>
<tr class="memitem:a62a537620390057d6acf6060fd8accaf"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a62a537620390057d6acf6060fd8accaf"></a>
<a class="el" href="classVc_1_1sfloat__m.html">sfloat_m</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVc_1_1sfloat__v.html#a62a537620390057d6acf6060fd8accaf">operator==</a> (const <a class="el" href="classVc_1_1sfloat__v.html">sfloat_v</a> &amp;x) const </td></tr>
<tr class="memdesc:a62a537620390057d6acf6060fd8accaf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns mask that is <code>true</code> where vector entries are equal and <code>false</code> otherwise. <br/></td></tr>
<tr class="memitem:af483aaaa4ae474113119d55c2e66fb7b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af483aaaa4ae474113119d55c2e66fb7b"></a>
<a class="el" href="classVc_1_1sfloat__m.html">sfloat_m</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVc_1_1sfloat__v.html#af483aaaa4ae474113119d55c2e66fb7b">operator!=</a> (const <a class="el" href="classVc_1_1sfloat__v.html">sfloat_v</a> &amp;x) const </td></tr>
<tr class="memdesc:af483aaaa4ae474113119d55c2e66fb7b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns mask that is <code>true</code> where vector entries are not equal and <code>false</code> otherwise. <br/></td></tr>
<tr class="memitem:a4ee12ca0985ede676b7e72e2f24099f2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4ee12ca0985ede676b7e72e2f24099f2"></a>
<a class="el" href="classVc_1_1sfloat__m.html">sfloat_m</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVc_1_1sfloat__v.html#a4ee12ca0985ede676b7e72e2f24099f2">operator&gt;</a> (const <a class="el" href="classVc_1_1sfloat__v.html">sfloat_v</a> &amp;x) const </td></tr>
<tr class="memdesc:a4ee12ca0985ede676b7e72e2f24099f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns mask that is <code>true</code> where the left vector entries are greater than on the right and <code>false</code> otherwise. <br/></td></tr>
<tr class="memitem:acab774bef938aabf73c5d7bd654ad703"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="acab774bef938aabf73c5d7bd654ad703"></a>
<a class="el" href="classVc_1_1sfloat__m.html">sfloat_m</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVc_1_1sfloat__v.html#acab774bef938aabf73c5d7bd654ad703">operator&gt;=</a> (const <a class="el" href="classVc_1_1sfloat__v.html">sfloat_v</a> &amp;x) const </td></tr>
<tr class="memdesc:acab774bef938aabf73c5d7bd654ad703"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns mask that is <code>true</code> where the left vector entries are greater than on the right or equal and <code>false</code> otherwise. <br/></td></tr>
<tr class="memitem:a1c03067c625e155019775f60797cf0c9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1c03067c625e155019775f60797cf0c9"></a>
<a class="el" href="classVc_1_1sfloat__m.html">sfloat_m</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVc_1_1sfloat__v.html#a1c03067c625e155019775f60797cf0c9">operator&lt;</a> (const <a class="el" href="classVc_1_1sfloat__v.html">sfloat_v</a> &amp;x) const </td></tr>
<tr class="memdesc:a1c03067c625e155019775f60797cf0c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns mask that is <code>true</code> where the left vector entries are less than on the right and <code>false</code> otherwise. <br/></td></tr>
<tr class="memitem:ada8be4403bbb46b32f0528eccfc56e73"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ada8be4403bbb46b32f0528eccfc56e73"></a>
<a class="el" href="classVc_1_1sfloat__m.html">sfloat_m</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVc_1_1sfloat__v.html#ada8be4403bbb46b32f0528eccfc56e73">operator&lt;=</a> (const <a class="el" href="classVc_1_1sfloat__v.html">sfloat_v</a> &amp;x) const </td></tr>
<tr class="memdesc:ada8be4403bbb46b32f0528eccfc56e73"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns mask that is <code>true</code> where the left vector entries are less than on the right or equal and <code>false</code> otherwise. <br/></td></tr>
<tr><td colspan="2"><div class="groupHeader">Arithmetic Operations</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>The vector classes implement all the arithmetic and (bitwise) logical operations as you know from builtin types.</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> foo(<span class="keyword">const</span> float_v &amp;a, <span class="keyword">const</span> float_v &amp;b) {</div>
<div class="line">  <span class="keyword">const</span> float_v <a class="code" href="classVc_1_1sfloat__v.html#a754382ebed79652e6d1a9e600cde05fc" title="Returns the product of all entries in the vector.">product</a>    = a * b;</div>
<div class="line">  <span class="keyword">const</span> float_v difference = a - b;</div>
<div class="line">}</div>
</div><!-- fragment --> </div></td></tr>
<tr class="memitem:a6b0cd6ec789a6ca7b68859494436ed00"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6b0cd6ec789a6ca7b68859494436ed00"></a>
<a class="el" href="classVc_1_1sfloat__v.html">sfloat_v</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVc_1_1sfloat__v.html#a6b0cd6ec789a6ca7b68859494436ed00">operator+</a> (<a class="el" href="classVc_1_1sfloat__v.html">sfloat_v</a> x) const </td></tr>
<tr class="memdesc:a6b0cd6ec789a6ca7b68859494436ed00"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a new vector with the sum of the respective entries of the left and right vector. <br/></td></tr>
<tr class="memitem:a77c7815f32166c3ba100f5ff34c6e7bb"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a77c7815f32166c3ba100f5ff34c6e7bb"></a>
<a class="el" href="classVc_1_1sfloat__v.html">sfloat_v</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVc_1_1sfloat__v.html#a77c7815f32166c3ba100f5ff34c6e7bb">operator+=</a> (<a class="el" href="classVc_1_1sfloat__v.html">sfloat_v</a> x)</td></tr>
<tr class="memdesc:a77c7815f32166c3ba100f5ff34c6e7bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds the respective entries of <code>x</code> to this vector. <br/></td></tr>
<tr class="memitem:a71865f433fd56829c07d9dd6f004654e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a71865f433fd56829c07d9dd6f004654e"></a>
<a class="el" href="classVc_1_1sfloat__v.html">sfloat_v</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVc_1_1sfloat__v.html#a71865f433fd56829c07d9dd6f004654e">operator-</a> (<a class="el" href="classVc_1_1sfloat__v.html">sfloat_v</a> x) const </td></tr>
<tr class="memdesc:a71865f433fd56829c07d9dd6f004654e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a new vector with the difference of the respective entries of the left and right vector. <br/></td></tr>
<tr class="memitem:a520d62a005ad409d98a68b0153e29112"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a520d62a005ad409d98a68b0153e29112"></a>
<a class="el" href="classVc_1_1sfloat__v.html">sfloat_v</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVc_1_1sfloat__v.html#a520d62a005ad409d98a68b0153e29112">operator-=</a> (<a class="el" href="classVc_1_1sfloat__v.html">sfloat_v</a> x)</td></tr>
<tr class="memdesc:a520d62a005ad409d98a68b0153e29112"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtracts the respective entries of <code>x</code> from this vector. <br/></td></tr>
<tr class="memitem:a59b7c48445f3540e2f1419dbd76b7811"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a59b7c48445f3540e2f1419dbd76b7811"></a>
<a class="el" href="classVc_1_1sfloat__v.html">sfloat_v</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVc_1_1sfloat__v.html#a59b7c48445f3540e2f1419dbd76b7811">operator*</a> (<a class="el" href="classVc_1_1sfloat__v.html">sfloat_v</a> x) const </td></tr>
<tr class="memdesc:a59b7c48445f3540e2f1419dbd76b7811"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a new vector with the product of the respective entries of the left and right vector. <br/></td></tr>
<tr class="memitem:a7da109f0d75ffaa678afa8f03968a6ac"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7da109f0d75ffaa678afa8f03968a6ac"></a>
<a class="el" href="classVc_1_1sfloat__v.html">sfloat_v</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVc_1_1sfloat__v.html#a7da109f0d75ffaa678afa8f03968a6ac">operator*=</a> (<a class="el" href="classVc_1_1sfloat__v.html">sfloat_v</a> x)</td></tr>
<tr class="memdesc:a7da109f0d75ffaa678afa8f03968a6ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplies the respective entries of <code>x</code> from to vector. <br/></td></tr>
<tr class="memitem:a0eeeebf555477cd11a0e9082fa5ce586"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0eeeebf555477cd11a0e9082fa5ce586"></a>
<a class="el" href="classVc_1_1sfloat__v.html">sfloat_v</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVc_1_1sfloat__v.html#a0eeeebf555477cd11a0e9082fa5ce586">operator/</a> (<a class="el" href="classVc_1_1sfloat__v.html">sfloat_v</a> x) const </td></tr>
<tr class="memdesc:a0eeeebf555477cd11a0e9082fa5ce586"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a new vector with the quotient of the respective entries of the left and right vector. <br/></td></tr>
<tr class="memitem:a2d8406cb3241a2e14086c9b12f054868"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2d8406cb3241a2e14086c9b12f054868"></a>
<a class="el" href="classVc_1_1sfloat__v.html">sfloat_v</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVc_1_1sfloat__v.html#a2d8406cb3241a2e14086c9b12f054868">operator/=</a> (<a class="el" href="classVc_1_1sfloat__v.html">sfloat_v</a> x)</td></tr>
<tr class="memdesc:a2d8406cb3241a2e14086c9b12f054868"><td class="mdescLeft">&#160;</td><td class="mdescRight">Divides the respective entries of this vector by <code>x</code>. <br/></td></tr>
<tr class="memitem:aad3715dc43a19860c197b090062890c4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aad3715dc43a19860c197b090062890c4"></a>
<a class="el" href="classVc_1_1sfloat__v.html">sfloat_v</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVc_1_1sfloat__v.html#aad3715dc43a19860c197b090062890c4">operator-</a> () const </td></tr>
<tr class="memdesc:aad3715dc43a19860c197b090062890c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a new vector with all entries negated. <br/></td></tr>
<tr class="memitem:af7f4453c69261156162b975caf2dfceb"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af7f4453c69261156162b975caf2dfceb"></a>
<a class="el" href="classVc_1_1sfloat__v.html">sfloat_v</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVc_1_1sfloat__v.html#af7f4453c69261156162b975caf2dfceb">operator|</a> (<a class="el" href="classVc_1_1sfloat__v.html">sfloat_v</a> x) const </td></tr>
<tr class="memdesc:af7f4453c69261156162b975caf2dfceb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a new vector with the binary or of the respective entries of the left and right vector. <br/></td></tr>
<tr class="memitem:adb78bf74123624f1d5b4d91c781242b3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="adb78bf74123624f1d5b4d91c781242b3"></a>
<a class="el" href="classVc_1_1sfloat__v.html">sfloat_v</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVc_1_1sfloat__v.html#adb78bf74123624f1d5b4d91c781242b3">operator&amp;</a> (<a class="el" href="classVc_1_1sfloat__v.html">sfloat_v</a> x) const </td></tr>
<tr class="memdesc:adb78bf74123624f1d5b4d91c781242b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a new vector with the binary and of the respective entries of the left and right vector. <br/></td></tr>
<tr class="memitem:a78e667391112f4eb353b2fc37793ba06"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a78e667391112f4eb353b2fc37793ba06"></a>
<a class="el" href="classVc_1_1sfloat__v.html">sfloat_v</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVc_1_1sfloat__v.html#a78e667391112f4eb353b2fc37793ba06">operator^</a> (<a class="el" href="classVc_1_1sfloat__v.html">sfloat_v</a> x) const </td></tr>
<tr class="memdesc:a78e667391112f4eb353b2fc37793ba06"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a new vector with the binary xor of the respective entries of the left and right vector. <br/></td></tr>
<tr class="memitem:a1890abc015c007d07786a5c2f6700156"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1890abc015c007d07786a5c2f6700156"></a>
<a class="el" href="classVc_1_1sfloat__v.html">sfloat_v</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVc_1_1sfloat__v.html#a1890abc015c007d07786a5c2f6700156">operator&lt;&lt;</a> (int x) const </td></tr>
<tr class="memdesc:a1890abc015c007d07786a5c2f6700156"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a new vector with each entry bitshifted to the left by <code>x</code> bits. <br/></td></tr>
<tr class="memitem:af80ed89ff253d42d9255e06c7da68b19"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af80ed89ff253d42d9255e06c7da68b19"></a>
<a class="el" href="classVc_1_1sfloat__v.html">sfloat_v</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVc_1_1sfloat__v.html#af80ed89ff253d42d9255e06c7da68b19">operator&lt;&lt;=</a> (int x)</td></tr>
<tr class="memdesc:af80ed89ff253d42d9255e06c7da68b19"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bitshift each entry to the left by <code>x</code> bits. <br/></td></tr>
<tr class="memitem:a7c90d888da22330f58be3dcc66c05096"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7c90d888da22330f58be3dcc66c05096"></a>
<a class="el" href="classVc_1_1sfloat__v.html">sfloat_v</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVc_1_1sfloat__v.html#a7c90d888da22330f58be3dcc66c05096">operator&gt;&gt;</a> (int x) const </td></tr>
<tr class="memdesc:a7c90d888da22330f58be3dcc66c05096"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a new vector with each entry bitshifted to the right by <code>x</code> bits. <br/></td></tr>
<tr class="memitem:a87e45d338daf4bd4e88c1eb82ab2cb6d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a87e45d338daf4bd4e88c1eb82ab2cb6d"></a>
<a class="el" href="classVc_1_1sfloat__v.html">sfloat_v</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVc_1_1sfloat__v.html#a87e45d338daf4bd4e88c1eb82ab2cb6d">operator&gt;&gt;=</a> (int x)</td></tr>
<tr class="memdesc:a87e45d338daf4bd4e88c1eb82ab2cb6d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bitshift each entry to the right by <code>x</code> bits. <br/></td></tr>
<tr class="memitem:a04f1c8542a86f9c665445ef82703d55d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a04f1c8542a86f9c665445ef82703d55d"></a>
<a class="el" href="classVc_1_1sfloat__v.html">sfloat_v</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVc_1_1sfloat__v.html#a04f1c8542a86f9c665445ef82703d55d">operator&lt;&lt;</a> (<a class="el" href="classVc_1_1sfloat__v.html">sfloat_v</a> x) const </td></tr>
<tr class="memdesc:a04f1c8542a86f9c665445ef82703d55d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a new vector with each entry bitshifted to the left by <code>x</code>[i] bits. <br/></td></tr>
<tr class="memitem:a11200e0d227c057868fbefbbde8c4e7f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a11200e0d227c057868fbefbbde8c4e7f"></a>
<a class="el" href="classVc_1_1sfloat__v.html">sfloat_v</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVc_1_1sfloat__v.html#a11200e0d227c057868fbefbbde8c4e7f">operator&lt;&lt;=</a> (<a class="el" href="classVc_1_1sfloat__v.html">sfloat_v</a> x)</td></tr>
<tr class="memdesc:a11200e0d227c057868fbefbbde8c4e7f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bitshift each entry to the left by <code>x</code>[i] bits. <br/></td></tr>
<tr class="memitem:ab2e5e803e736cf63a45c095d08467d1d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab2e5e803e736cf63a45c095d08467d1d"></a>
<a class="el" href="classVc_1_1sfloat__v.html">sfloat_v</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVc_1_1sfloat__v.html#ab2e5e803e736cf63a45c095d08467d1d">operator&gt;&gt;</a> (<a class="el" href="classVc_1_1sfloat__v.html">sfloat_v</a> x) const </td></tr>
<tr class="memdesc:ab2e5e803e736cf63a45c095d08467d1d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a new vector with each entry bitshifted to the right by <code>x</code>[i] bits. <br/></td></tr>
<tr class="memitem:a04f60be41059a96dd1c9e4aaff7e6c7f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a04f60be41059a96dd1c9e4aaff7e6c7f"></a>
<a class="el" href="classVc_1_1sfloat__v.html">sfloat_v</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVc_1_1sfloat__v.html#a04f60be41059a96dd1c9e4aaff7e6c7f">operator&gt;&gt;=</a> (<a class="el" href="classVc_1_1sfloat__v.html">sfloat_v</a> x)</td></tr>
<tr class="memdesc:a04f60be41059a96dd1c9e4aaff7e6c7f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bitshift each entry to the right by <code>x</code>[i] bits. <br/></td></tr>
<tr class="memitem:a12251d6ec24adc218697dac0668f3a90"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVc_1_1sfloat__v.html#a12251d6ec24adc218697dac0668f3a90">fusedMultiplyAdd</a> (<a class="el" href="classVc_1_1sfloat__v.html">sfloat_v</a> factor, <a class="el" href="classVc_1_1sfloat__v.html">sfloat_v</a> summand)</td></tr>
<tr class="memdesc:a12251d6ec24adc218697dac0668f3a90"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplies this vector with <code>factor</code> and then adds <code>summand</code>, without rounding between the multiplication and the addition.  <a href="#a12251d6ec24adc218697dac0668f3a90"></a><br/></td></tr>
<tr><td colspan="2"><div class="groupHeader">Horizontal Reduction Operations</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>There are four horizontal operations available to reduce the values of a vector to a scalar value.</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> foo(<span class="keyword">const</span> float_v &amp;v) {</div>
<div class="line">  <span class="keywordtype">float</span> min = v.min(); <span class="comment">// smallest value in v</span></div>
<div class="line">  <span class="keywordtype">float</span> sum = v.sum(); <span class="comment">// sum of all values in v</span></div>
<div class="line">}</div>
</div><!-- fragment --> </div></td></tr>
<tr class="memitem:a3ac649f18d903bce9e1b4d1c2db7f5e8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3ac649f18d903bce9e1b4d1c2db7f5e8"></a>
float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVc_1_1sfloat__v.html#a3ac649f18d903bce9e1b4d1c2db7f5e8">min</a> () const </td></tr>
<tr class="memdesc:a3ac649f18d903bce9e1b4d1c2db7f5e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the smallest entry in the vector. <br/></td></tr>
<tr class="memitem:a5d1632024b58ff4da8952a5bb851e1ce"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5d1632024b58ff4da8952a5bb851e1ce"></a>
float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVc_1_1sfloat__v.html#a5d1632024b58ff4da8952a5bb851e1ce">max</a> () const </td></tr>
<tr class="memdesc:a5d1632024b58ff4da8952a5bb851e1ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the largest entry in the vector. <br/></td></tr>
<tr class="memitem:a754382ebed79652e6d1a9e600cde05fc"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a754382ebed79652e6d1a9e600cde05fc"></a>
float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVc_1_1sfloat__v.html#a754382ebed79652e6d1a9e600cde05fc">product</a> () const </td></tr>
<tr class="memdesc:a754382ebed79652e6d1a9e600cde05fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the product of all entries in the vector. <br/></td></tr>
<tr class="memitem:a09cc33fe5a79fe807278f2ff98d72666"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a09cc33fe5a79fe807278f2ff98d72666"></a>
float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVc_1_1sfloat__v.html#a09cc33fe5a79fe807278f2ff98d72666">sum</a> () const </td></tr>
<tr class="memdesc:a09cc33fe5a79fe807278f2ff98d72666"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the sum of all entries in the vector. <br/></td></tr>
<tr><td colspan="2"><div class="groupHeader">Apply/Call/Fill Functions</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>There are still many situations where the code needs to switch from SIMD operations to scalar execution.</p>
<p>In this case you can, of course rely on operator[]. But there are also a number of functions that can help with common patterns.</p>
<p>The apply functions expect a function that returns a scalar value, i.e. a function of the form "T f(T)". The call functions do not return a value and thus the function passed does not need a return value. The fill functions are used to serially set the entries of the vector from the return values of a function.</p>
<p>Example: </p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> foo(float_v v) {</div>
<div class="line">  float_v logarithm = v.apply(<a class="code" href="group__Math.html#gad3bc65dcbcd5a298c604400d4b55bdbc" title="Returns the natural logarithm of v.">std::log</a>);</div>
<div class="line">  float_v exponential = v.apply(<a class="code" href="group__Math.html#gad77aaacf492f74f852a7efb16d8ea780" title="Returns the exponential of v.">std::exp</a>);</div>
<div class="line">}</div>
</div><!-- fragment --><p>Of course, with C++11, you can also use lambdas here: </p>
<div class="fragment"><div class="line">float_v power = v.apply([](<span class="keywordtype">float</span> f) { <span class="keywordflow">return</span> std::pow(f, 0.6f); })</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>A functor: this can either be a function or an object that implements operator(). </td></tr>
  </table>
  </dd>
</dl>
</div></td></tr>
<tr class="memitem:afc1d604e49c1954554703978c2b3b029"><td class="memTemplParams" colspan="2"><a class="anchor" id="afc1d604e49c1954554703978c2b3b029"></a>
template&lt;typename Functor &gt; </td></tr>
<tr class="memitem:afc1d604e49c1954554703978c2b3b029"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classVc_1_1sfloat__v.html">sfloat_v</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classVc_1_1sfloat__v.html#afc1d604e49c1954554703978c2b3b029">apply</a> (Functor &amp;f) const </td></tr>
<tr class="memdesc:afc1d604e49c1954554703978c2b3b029"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a new vector where each entry is the return value of <code>f</code> called on the current value. <br/></td></tr>
<tr class="memitem:a392ade7f5321c7b64fa9925b12e8e64c"><td class="memTemplParams" colspan="2"><a class="anchor" id="a392ade7f5321c7b64fa9925b12e8e64c"></a>
template&lt;typename Functor &gt; </td></tr>
<tr class="memitem:a392ade7f5321c7b64fa9925b12e8e64c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classVc_1_1sfloat__v.html">sfloat_v</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classVc_1_1sfloat__v.html#a392ade7f5321c7b64fa9925b12e8e64c">apply</a> (const Functor &amp;f) const </td></tr>
<tr class="memdesc:a392ade7f5321c7b64fa9925b12e8e64c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Const overload of the above function. <br/></td></tr>
<tr class="memitem:a70315f317e530549da3cb002a038525c"><td class="memTemplParams" colspan="2"><a class="anchor" id="a70315f317e530549da3cb002a038525c"></a>
template&lt;typename Functor &gt; </td></tr>
<tr class="memitem:a70315f317e530549da3cb002a038525c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classVc_1_1sfloat__v.html">sfloat_v</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classVc_1_1sfloat__v.html#a70315f317e530549da3cb002a038525c">apply</a> (Functor &amp;f, <a class="el" href="classVc_1_1sfloat__m.html">sfloat_m</a> mask) const </td></tr>
<tr class="memdesc:a70315f317e530549da3cb002a038525c"><td class="mdescLeft">&#160;</td><td class="mdescRight">As above, but skip the entries where <code>mask</code> is not set. <br/></td></tr>
<tr class="memitem:a5ce5b79a411a948db3700ce224b52fe8"><td class="memTemplParams" colspan="2"><a class="anchor" id="a5ce5b79a411a948db3700ce224b52fe8"></a>
template&lt;typename Functor &gt; </td></tr>
<tr class="memitem:a5ce5b79a411a948db3700ce224b52fe8"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classVc_1_1sfloat__v.html">sfloat_v</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classVc_1_1sfloat__v.html#a5ce5b79a411a948db3700ce224b52fe8">apply</a> (const Functor &amp;f, <a class="el" href="classVc_1_1sfloat__m.html">sfloat_m</a> mask) const </td></tr>
<tr class="memdesc:a5ce5b79a411a948db3700ce224b52fe8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Const overload of the above function. <br/></td></tr>
<tr class="memitem:a8b2a06cbb52b755129ded56a4dfdb488"><td class="memTemplParams" colspan="2"><a class="anchor" id="a8b2a06cbb52b755129ded56a4dfdb488"></a>
template&lt;typename Functor &gt; </td></tr>
<tr class="memitem:a8b2a06cbb52b755129ded56a4dfdb488"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classVc_1_1sfloat__v.html#a8b2a06cbb52b755129ded56a4dfdb488">call</a> (Functor &amp;f) const </td></tr>
<tr class="memdesc:a8b2a06cbb52b755129ded56a4dfdb488"><td class="mdescLeft">&#160;</td><td class="mdescRight">Call <code>f</code> with the scalar entries of the vector. <br/></td></tr>
<tr class="memitem:a687902149e0ecb683622ffc94adfb2b1"><td class="memTemplParams" colspan="2"><a class="anchor" id="a687902149e0ecb683622ffc94adfb2b1"></a>
template&lt;typename Functor &gt; </td></tr>
<tr class="memitem:a687902149e0ecb683622ffc94adfb2b1"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classVc_1_1sfloat__v.html#a687902149e0ecb683622ffc94adfb2b1">call</a> (const Functor &amp;f) const </td></tr>
<tr class="memdesc:a687902149e0ecb683622ffc94adfb2b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Const overload of the above function. <br/></td></tr>
<tr class="memitem:a91a18ba2ab1df0e9d36fe08267b6ca99"><td class="memTemplParams" colspan="2"><a class="anchor" id="a91a18ba2ab1df0e9d36fe08267b6ca99"></a>
template&lt;typename Functor &gt; </td></tr>
<tr class="memitem:a91a18ba2ab1df0e9d36fe08267b6ca99"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classVc_1_1sfloat__v.html#a91a18ba2ab1df0e9d36fe08267b6ca99">call</a> (Functor &amp;f, <a class="el" href="classVc_1_1sfloat__m.html">sfloat_m</a> mask) const </td></tr>
<tr class="memdesc:a91a18ba2ab1df0e9d36fe08267b6ca99"><td class="mdescLeft">&#160;</td><td class="mdescRight">As above, but skip the entries where <code>mask</code> is not set. <br/></td></tr>
<tr class="memitem:a974ecc033f6805dfbe5cdce852d323bc"><td class="memTemplParams" colspan="2"><a class="anchor" id="a974ecc033f6805dfbe5cdce852d323bc"></a>
template&lt;typename Functor &gt; </td></tr>
<tr class="memitem:a974ecc033f6805dfbe5cdce852d323bc"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classVc_1_1sfloat__v.html#a974ecc033f6805dfbe5cdce852d323bc">call</a> (const Functor &amp;f, <a class="el" href="classVc_1_1sfloat__m.html">sfloat_m</a> mask) const </td></tr>
<tr class="memdesc:a974ecc033f6805dfbe5cdce852d323bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Const overload of the above function. <br/></td></tr>
<tr class="memitem:a032611928c3dd5fed00b31993d0e8b0d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a032611928c3dd5fed00b31993d0e8b0d"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVc_1_1sfloat__v.html#a032611928c3dd5fed00b31993d0e8b0d">fill</a> (float(&amp;f)())</td></tr>
<tr class="memdesc:a032611928c3dd5fed00b31993d0e8b0d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fill the vector with the values [f(), f(), f(), ...]. <br/></td></tr>
<tr class="memitem:a5d16436cc69f42eca839d89c656a47b0"><td class="memTemplParams" colspan="2"><a class="anchor" id="a5d16436cc69f42eca839d89c656a47b0"></a>
template&lt;typename IndexT &gt; </td></tr>
<tr class="memitem:a5d16436cc69f42eca839d89c656a47b0"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classVc_1_1sfloat__v.html#a5d16436cc69f42eca839d89c656a47b0">fill</a> (float(&amp;f)(IndexT))</td></tr>
<tr class="memdesc:a5d16436cc69f42eca839d89c656a47b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fill the vector with the values [f(0), f(1), f(2), ...]. <br/></td></tr>
<tr><td colspan="2"><div class="groupHeader">Swizzles</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>Swizzles are a special form of shuffles that, depending on the target hardware and swizzle type, may be used without extra cost.</p>
<p>The swizzles act on every successive four entries in the vector. Thus the swizzle </p>
<pre class="fragment">[0, 1, 2, 3, 4, 5, 6, 7].dcba() </pre><p> results in </p>
<pre class="fragment">[3, 2, 1, 0, 7, 6, 5, 4] </pre><p>.</p>
<p>This implies a portability issue. The swizzles can only work on vectors where Size is a multiple of four. On Vc::Scalar all swizzles are implemented as no-ops. If a swizzle is used on a vector of Size == 2 compilation will fail. </p>
</div></td></tr>
<tr class="memitem:a2dd29be9cd95af6c45431e67affe469b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2dd29be9cd95af6c45431e67affe469b"></a>
const <a class="el" href="classVc_1_1sfloat__v.html">sfloat_v</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVc_1_1sfloat__v.html#a2dd29be9cd95af6c45431e67affe469b">abcd</a> () const </td></tr>
<tr class="memdesc:a2dd29be9cd95af6c45431e67affe469b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Identity. <br/></td></tr>
<tr class="memitem:ae314cb613b9884e2ee83ea9896560b3c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae314cb613b9884e2ee83ea9896560b3c"></a>
const <a class="el" href="classVc_1_1sfloat__v.html">sfloat_v</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVc_1_1sfloat__v.html#ae314cb613b9884e2ee83ea9896560b3c">badc</a> () const </td></tr>
<tr class="memdesc:ae314cb613b9884e2ee83ea9896560b3c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Permute pairs. <br/></td></tr>
<tr class="memitem:a9fb1e38730fdfa4398b3adcf7ae1ed13"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9fb1e38730fdfa4398b3adcf7ae1ed13"></a>
const <a class="el" href="classVc_1_1sfloat__v.html">sfloat_v</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVc_1_1sfloat__v.html#a9fb1e38730fdfa4398b3adcf7ae1ed13">cdab</a> () const </td></tr>
<tr class="memdesc:a9fb1e38730fdfa4398b3adcf7ae1ed13"><td class="mdescLeft">&#160;</td><td class="mdescRight">Permute pairs of two / Rotate twice. <br/></td></tr>
<tr class="memitem:a19ff9803c9d091697c20f0e5edb47524"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a19ff9803c9d091697c20f0e5edb47524"></a>
const <a class="el" href="classVc_1_1sfloat__v.html">sfloat_v</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVc_1_1sfloat__v.html#a19ff9803c9d091697c20f0e5edb47524">aaaa</a> () const </td></tr>
<tr class="memdesc:a19ff9803c9d091697c20f0e5edb47524"><td class="mdescLeft">&#160;</td><td class="mdescRight">Broadcast a. <br/></td></tr>
<tr class="memitem:a5826808f47d3f6deebc4e6c90990d6c8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5826808f47d3f6deebc4e6c90990d6c8"></a>
const <a class="el" href="classVc_1_1sfloat__v.html">sfloat_v</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVc_1_1sfloat__v.html#a5826808f47d3f6deebc4e6c90990d6c8">bbbb</a> () const </td></tr>
<tr class="memdesc:a5826808f47d3f6deebc4e6c90990d6c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Broadcast b. <br/></td></tr>
<tr class="memitem:a2257d9ceb46875fe9b024c679e812099"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2257d9ceb46875fe9b024c679e812099"></a>
const <a class="el" href="classVc_1_1sfloat__v.html">sfloat_v</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVc_1_1sfloat__v.html#a2257d9ceb46875fe9b024c679e812099">cccc</a> () const </td></tr>
<tr class="memdesc:a2257d9ceb46875fe9b024c679e812099"><td class="mdescLeft">&#160;</td><td class="mdescRight">Broadcast c. <br/></td></tr>
<tr class="memitem:aa84303b1a55767dee2402c9d827c14e3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa84303b1a55767dee2402c9d827c14e3"></a>
const <a class="el" href="classVc_1_1sfloat__v.html">sfloat_v</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVc_1_1sfloat__v.html#aa84303b1a55767dee2402c9d827c14e3">dddd</a> () const </td></tr>
<tr class="memdesc:aa84303b1a55767dee2402c9d827c14e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Broadcast d. <br/></td></tr>
<tr class="memitem:aa538c4699f7c5c4d3844975ded27a69e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa538c4699f7c5c4d3844975ded27a69e"></a>
const <a class="el" href="classVc_1_1sfloat__v.html">sfloat_v</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVc_1_1sfloat__v.html#aa538c4699f7c5c4d3844975ded27a69e">bcad</a> () const </td></tr>
<tr class="memdesc:aa538c4699f7c5c4d3844975ded27a69e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rotate three: cross-product swizzle. <br/></td></tr>
<tr class="memitem:a9ea84f45fb2ef157be63bf7d65d2081d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9ea84f45fb2ef157be63bf7d65d2081d"></a>
const <a class="el" href="classVc_1_1sfloat__v.html">sfloat_v</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVc_1_1sfloat__v.html#a9ea84f45fb2ef157be63bf7d65d2081d">bcda</a> () const </td></tr>
<tr class="memdesc:a9ea84f45fb2ef157be63bf7d65d2081d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rotate left. <br/></td></tr>
<tr class="memitem:ae2148e474c9404c3e7ae1de852be439a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae2148e474c9404c3e7ae1de852be439a"></a>
const <a class="el" href="classVc_1_1sfloat__v.html">sfloat_v</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVc_1_1sfloat__v.html#ae2148e474c9404c3e7ae1de852be439a">dabc</a> () const </td></tr>
<tr class="memdesc:ae2148e474c9404c3e7ae1de852be439a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rotate right. <br/></td></tr>
<tr class="memitem:a27ce2e73e6ddd0eb81b92967e8f6b165"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a27ce2e73e6ddd0eb81b92967e8f6b165"></a>
const <a class="el" href="classVc_1_1sfloat__v.html">sfloat_v</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVc_1_1sfloat__v.html#a27ce2e73e6ddd0eb81b92967e8f6b165">acbd</a> () const </td></tr>
<tr class="memdesc:a27ce2e73e6ddd0eb81b92967e8f6b165"><td class="mdescLeft">&#160;</td><td class="mdescRight">Permute inner pair. <br/></td></tr>
<tr class="memitem:a6c256b424d066cb9bd2b8017581f008a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6c256b424d066cb9bd2b8017581f008a"></a>
const <a class="el" href="classVc_1_1sfloat__v.html">sfloat_v</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVc_1_1sfloat__v.html#a6c256b424d066cb9bd2b8017581f008a">dbca</a> () const </td></tr>
<tr class="memdesc:a6c256b424d066cb9bd2b8017581f008a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Permute outer pair. <br/></td></tr>
<tr class="memitem:a0c4108e34b78f5c93600f41602a36825"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0c4108e34b78f5c93600f41602a36825"></a>
const <a class="el" href="classVc_1_1sfloat__v.html">sfloat_v</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVc_1_1sfloat__v.html#a0c4108e34b78f5c93600f41602a36825">dcba</a> () const </td></tr>
<tr class="memdesc:a0c4108e34b78f5c93600f41602a36825"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reverse. <br/></td></tr>
<tr><td colspan="2"><div class="groupHeader">Shift and Rotate</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>These functions allow to shift or rotate the entries in a vector by the given <code>amount</code>.</p>
<p>Both functions support positive and negative numbers for the shift/rotate value.</p>
<p>Example: </p>
<div class="fragment"><div class="line"><span class="keyword">using namespace </span>Vc;</div>
<div class="line"><a class="code" href="classVc_1_1int__v.html" title="SIMD Vector of 32 bit signed integers.">int_v</a> foo = <a class="code" href="classVc_1_1sfloat__v.html#a9f637994d1b02f99c34d2a1a5d4ba3ec" title="Returns a vector with the entries initialized to 0, 1, 2, 3, 4, 5, ...">int_v::IndexesFromZero</a>() + 1; <span class="comment">// e.g. [1, 2, 3, 4] with SSE</span></div>
<div class="line"><a class="code" href="classVc_1_1int__v.html" title="SIMD Vector of 32 bit signed integers.">int_v</a> x;</div>
<div class="line">x = foo.<a class="code" href="classVc_1_1int__v.html#a5aaaa4170434110136b91400e1c5be1e" title="Shift vector entries to the left by amount; shifting in zeros.">shifted</a>( 1); <span class="comment">// [2, 3, 4, 0]</span></div>
<div class="line">x = foo.<a class="code" href="classVc_1_1int__v.html#a5aaaa4170434110136b91400e1c5be1e" title="Shift vector entries to the left by amount; shifting in zeros.">shifted</a>( 2); <span class="comment">// [3, 4, 0, 0]</span></div>
<div class="line">x = foo.<a class="code" href="classVc_1_1int__v.html#a5aaaa4170434110136b91400e1c5be1e" title="Shift vector entries to the left by amount; shifting in zeros.">shifted</a>( 3); <span class="comment">// [4, 0, 0, 0]</span></div>
<div class="line">x = foo.<a class="code" href="classVc_1_1int__v.html#a5aaaa4170434110136b91400e1c5be1e" title="Shift vector entries to the left by amount; shifting in zeros.">shifted</a>( 4); <span class="comment">// [0, 0, 0, 0]</span></div>
<div class="line">x = foo.<a class="code" href="classVc_1_1int__v.html#a5aaaa4170434110136b91400e1c5be1e" title="Shift vector entries to the left by amount; shifting in zeros.">shifted</a>(-1); <span class="comment">// [0, 1, 2, 3]</span></div>
<div class="line">x = foo.<a class="code" href="classVc_1_1int__v.html#a5aaaa4170434110136b91400e1c5be1e" title="Shift vector entries to the left by amount; shifting in zeros.">shifted</a>(-2); <span class="comment">// [0, 0, 1, 2]</span></div>
<div class="line">x = foo.<a class="code" href="classVc_1_1int__v.html#a5aaaa4170434110136b91400e1c5be1e" title="Shift vector entries to the left by amount; shifting in zeros.">shifted</a>(-3); <span class="comment">// [0, 0, 0, 1]</span></div>
<div class="line">x = foo.<a class="code" href="classVc_1_1int__v.html#a5aaaa4170434110136b91400e1c5be1e" title="Shift vector entries to the left by amount; shifting in zeros.">shifted</a>(-4); <span class="comment">// [0, 0, 0, 0]</span></div>
<div class="line"></div>
<div class="line">x = foo.<a class="code" href="classVc_1_1int__v.html#aecc5dca2d8cbdbe23a0fcac00dc09d42" title="Rotate vector entries to the left by amount.">rotated</a>( 1); <span class="comment">// [2, 3, 4, 1]</span></div>
<div class="line">x = foo.<a class="code" href="classVc_1_1int__v.html#aecc5dca2d8cbdbe23a0fcac00dc09d42" title="Rotate vector entries to the left by amount.">rotated</a>( 2); <span class="comment">// [3, 4, 1, 2]</span></div>
<div class="line">x = foo.<a class="code" href="classVc_1_1int__v.html#aecc5dca2d8cbdbe23a0fcac00dc09d42" title="Rotate vector entries to the left by amount.">rotated</a>( 3); <span class="comment">// [4, 1, 2, 3]</span></div>
<div class="line">x = foo.<a class="code" href="classVc_1_1int__v.html#aecc5dca2d8cbdbe23a0fcac00dc09d42" title="Rotate vector entries to the left by amount.">rotated</a>( 4); <span class="comment">// [1, 2, 3, 4]</span></div>
<div class="line">x = foo.<a class="code" href="classVc_1_1int__v.html#aecc5dca2d8cbdbe23a0fcac00dc09d42" title="Rotate vector entries to the left by amount.">rotated</a>(-1); <span class="comment">// [4, 1, 2, 3]</span></div>
<div class="line">x = foo.<a class="code" href="classVc_1_1int__v.html#aecc5dca2d8cbdbe23a0fcac00dc09d42" title="Rotate vector entries to the left by amount.">rotated</a>(-2); <span class="comment">// [3, 4, 1, 2]</span></div>
<div class="line">x = foo.<a class="code" href="classVc_1_1int__v.html#aecc5dca2d8cbdbe23a0fcac00dc09d42" title="Rotate vector entries to the left by amount.">rotated</a>(-3); <span class="comment">// [2, 3, 4, 1]</span></div>
<div class="line">x = foo.<a class="code" href="classVc_1_1int__v.html#aecc5dca2d8cbdbe23a0fcac00dc09d42" title="Rotate vector entries to the left by amount.">rotated</a>(-4); <span class="comment">// [1, 2, 3, 4]</span></div>
</div><!-- fragment --><p>These functions are slightly related to the above swizzles. In any case, they are often useful for communication between SIMD lanes or binary decoding operations. </p>
</div></td></tr>
<tr class="memitem:ac8a3fa22c4539d057f250112c5fd9f8c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac8a3fa22c4539d057f250112c5fd9f8c"></a>
const <a class="el" href="classVc_1_1sfloat__v.html">sfloat_v</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVc_1_1sfloat__v.html#ac8a3fa22c4539d057f250112c5fd9f8c">shifted</a> (int amount) const </td></tr>
<tr class="memdesc:ac8a3fa22c4539d057f250112c5fd9f8c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shift vector entries to the left by <code>amount</code>; shifting in zeros. <br/></td></tr>
<tr class="memitem:a872fb02d2b734d12d05c0be85099480a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a872fb02d2b734d12d05c0be85099480a"></a>
const <a class="el" href="classVc_1_1sfloat__v.html">sfloat_v</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVc_1_1sfloat__v.html#a872fb02d2b734d12d05c0be85099480a">rotated</a> (int amount) const </td></tr>
<tr class="memdesc:a872fb02d2b734d12d05c0be85099480a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rotate vector entries to the left by <code>amount</code>. <br/></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:ab67571d1c87a66074a5607a17286f80a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab67571d1c87a66074a5607a17286f80a"></a>
static <a class="el" href="classVc_1_1sfloat__v.html">sfloat_v</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVc_1_1sfloat__v.html#ab67571d1c87a66074a5607a17286f80a">Zero</a> ()</td></tr>
<tr class="memdesc:ab67571d1c87a66074a5607a17286f80a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a vector with the entries initialized to zero. <br/></td></tr>
<tr class="memitem:aeb00e7c456e2bc124f4e89154e0a630f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aeb00e7c456e2bc124f4e89154e0a630f"></a>
static <a class="el" href="classVc_1_1sfloat__v.html">sfloat_v</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVc_1_1sfloat__v.html#aeb00e7c456e2bc124f4e89154e0a630f">One</a> ()</td></tr>
<tr class="memdesc:aeb00e7c456e2bc124f4e89154e0a630f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a vector with the entries initialized to one. <br/></td></tr>
<tr class="memitem:a9f637994d1b02f99c34d2a1a5d4ba3ec"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9f637994d1b02f99c34d2a1a5d4ba3ec"></a>
static <a class="el" href="classVc_1_1sfloat__v.html">sfloat_v</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVc_1_1sfloat__v.html#a9f637994d1b02f99c34d2a1a5d4ba3ec">IndexesFromZero</a> ()</td></tr>
<tr class="memdesc:a9f637994d1b02f99c34d2a1a5d4ba3ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a vector with the entries initialized to 0, 1, 2, 3, 4, 5, ... <br/></td></tr>
<tr class="memitem:a5b04c986a1c5b54fdc58107b87891772"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classVc_1_1sfloat__v.html">sfloat_v</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVc_1_1sfloat__v.html#a5b04c986a1c5b54fdc58107b87891772">Random</a> ()</td></tr>
<tr class="memdesc:a5b04c986a1c5b54fdc58107b87891772"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a vector with pseudo-random entries.  <a href="#a5b04c986a1c5b54fdc58107b87891772"></a><br/></td></tr>
</table>
<h2>Member Enumeration Documentation</h2>
<a class="anchor" id="a0411cd49bb5b71852cecd93bcbf0ca2d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">anonymous enum</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="a0411cd49bb5b71852cecd93bcbf0ca2daff9abf2b1a689f70a77a18da50c01d9f"></a>Size</em>&nbsp;</td><td>
<p>The size of the vector. </p>
<p>I.e. the number of scalar entries in the vector. Do not make any assumptions about the size of vectors. If you need a vector of float vs. integer of the same size make use of IndexType instead. Note that this still does not guarantee the same size (e.g. <a class="el" href="classVc_1_1double__v.html" title="SIMD Vector of double precision floats.">double_v</a> on SSE has two entries but there exists no 64 bit integer vector type in <a class="el" href="namespaceVc.html" title="Vector Classes Namespace.">Vc</a> - which would have two entries; thus <a class="el" href="classVc_1_1double__v.html#adf50037aa0d85a369b491188c43f8954" title="The type of the vector used for indexes in gather and scatter operations.">double_v::IndexType</a> is <a class="el" href="classVc_1_1uint__v.html" title="SIMD Vector of 32 bit unsigned integers.">uint_v</a>).</p>
<p>Also you can easily use if clauses that compare sizes. The compiler can statically evaluate and fully optimize dead code away (very much like #ifdef, but with syntax checking). </p>
</td></tr>
</table>
</dd>
</dl>

</div>
</div>
<h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a10d6c061475bf49bbd8be117d82fc72f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVc_1_1sfloat__v.html">sfloat_v</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__Vectors.html#gga637228b0c9f9022584b3df6248183205ab9f6920de535f04ccfe34d670fa2c8a8">Vc::Zero</a>&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct a vector with the entries initialized to zero. </p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__Vectors.html#gga637228b0c9f9022584b3df6248183205ab9f6920de535f04ccfe34d670fa2c8a8" title="Used for optimized construction of vectors initialized to zero.">Vc::Zero</a>, <a class="el" href="classVc_1_1sfloat__v.html#ab67571d1c87a66074a5607a17286f80a" title="Returns a vector with the entries initialized to zero.">Zero()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a58a340c9e6ba402d39d87547e5fdd6a1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVc_1_1sfloat__v.html">sfloat_v</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__Vectors.html#gga637228b0c9f9022584b3df6248183205ad4e07130bf8ac301c327f0e64bc2d292">Vc::One</a>&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct a vector with the entries initialized to one. </p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__Vectors.html#gga637228b0c9f9022584b3df6248183205ad4e07130bf8ac301c327f0e64bc2d292" title="Used for optimized construction of vectors initialized to one.">Vc::One</a> </dd></dl>

</div>
</div>
<a class="anchor" id="aa0cf02594b51bfa829bb9f42f3656cea"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVc_1_1sfloat__v.html">sfloat_v</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__Vectors.html#gga637228b0c9f9022584b3df6248183205a99c4e745942c50c80621dfef60705703">Vc::IndexesFromZero</a>&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct a vector with the entries initialized to 0, 1, 2, 3, 4, 5, ... </p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__Vectors.html#gga637228b0c9f9022584b3df6248183205a99c4e745942c50c80621dfef60705703" title="Parameter to create a vector with the entries 0, 1, 2, 3, 4, 5, ...">Vc::IndexesFromZero</a>, <a class="el" href="classVc_1_1sfloat__v.html#a9f637994d1b02f99c34d2a1a5d4ba3ec" title="Returns a vector with the entries initialized to 0, 1, 2, 3, 4, 5, ...">IndexesFromZero()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a7cbf08e6688cf3e47bf0831e13d674b5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVc_1_1sfloat__v.html">sfloat_v</a> </td>
          <td>(</td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>alignedMemory</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct a vector loading its entries from <code>alignedMemory</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">alignedMemory</td><td>A pointer to data. The pointer must be aligned on a <a class="el" href="group__Vectors.html#ggafc69e2f69e7e54557954b8da4bd6c6afa65da35888fae8203b2da4f4e92523f50" title="Specifies the byte boundary for memory alignments necessary for aligned loads and stores...">Vc::VectorAlignment</a> boundary. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a36ea9a0bbcb19362caeb5d8ce4136b3e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVc_1_1sfloat__v.html">sfloat_v</a> </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Broadcast Constructor. </p>
<p>Constructs a vector with all entries of the vector filled with the given value.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>The scalar value to broadcast to all entries of the constructed vector.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>If you want to set it to 0 or 1 use the special initializer constructors above. Calling this constructor with 0 will cause a compilation error because the compiler cannot know which constructor you meant. </dd></dl>

</div>
</div>
<h2>Member Function Documentation</h2>
<a class="anchor" id="a5b04c986a1c5b54fdc58107b87891772"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classVc_1_1sfloat__v.html">sfloat_v</a> Random </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a vector with pseudo-random entries. </p>
<p>Currently the state of the random number generator cannot be modified and starts off with the same state. Thus you will get the same sequence of numbers for the same sequence of calls.</p>
<dl class="section return"><dt>Returns</dt><dd>a new random vector. Floating-point values will be in the 0-1 range. Integers will use the full range the integer representation allows.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function may use a very small amount of state and thus will be a weak random number generator. </dd></dl>

</div>
</div>
<a class="anchor" id="aa895397ab1f083a86a5879896740c9b3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void load </td>
          <td>(</td>
          <td class="paramtype">const float *&#160;</td>
          <td class="paramname"><em>memory</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__Vectors.html#ga9157aa15b51290e8511edf1e7172513b">LoadStoreFlags</a>&#160;</td>
          <td class="paramname"><em>align</em> = <code><a class="el" href="group__Vectors.html#gga9157aa15b51290e8511edf1e7172513bad5380ca00f3d74b38593adf8a0d06d3e">Aligned</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct a vector from an array of vectors with different Size. </p>
<p>E.g. convert from two <a class="el" href="classVc_1_1double__v.html" title="SIMD Vector of double precision floats.">double_v</a> to one <a class="el" href="classVc_1_1float__v.html" title="SIMD Vector of single precision floats.">float_v</a>.</p>
<dl class="section see"><dt>See Also</dt><dd>expand Expand the values into an array of vectors that have a different <a class="el" href="classVc_1_1sfloat__v.html#a0411cd49bb5b71852cecd93bcbf0ca2daff9abf2b1a689f70a77a18da50c01d9f" title="The size of the vector.">Size</a>.</dd></dl>
<p>E.g. convert from one <a class="el" href="classVc_1_1float__v.html" title="SIMD Vector of single precision floats.">float_v</a> to two <a class="el" href="classVc_1_1double__v.html" title="SIMD Vector of double precision floats.">double_v</a>.</p>
<p>This is the reverse of the above constructor. Load the vector entries from <code>memory</code>, overwriting the previous values.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">memory</td><td>A pointer to data. </td></tr>
    <tr><td class="paramname">align</td><td>Determines whether <code>memory</code> is an aligned pointer or not.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="classVc_1_1Memory.html" title="A helper class for fixed-size two-dimensional arrays.">Memory</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a53e9dbb604a1769583d0e69343a9c9c8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void setZero </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classVc_1_1sfloat__m.html">sfloat_m</a> &amp;&#160;</td>
          <td class="paramname"><em>mask</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set all entries to zero where the mask is set. </p>
<p>I.e. a 4-vector with a mask of 0111 would set the last three entries to 0.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mask</td><td>Selects the entries to be set to zero. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a632d6009866794df04f8eb9918c6b802"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void store </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classVc_1_1sfloat__v.html#a955f7da87ee570489300c2e249867398">EntryType</a> *&#160;</td>
          <td class="paramname"><em>memory</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__Vectors.html#ga9157aa15b51290e8511edf1e7172513b">LoadStoreFlags</a>&#160;</td>
          <td class="paramname"><em>align</em> = <code><a class="el" href="group__Vectors.html#gga9157aa15b51290e8511edf1e7172513bad5380ca00f3d74b38593adf8a0d06d3e">Aligned</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Store the vector data to <code>memory</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">memory</td><td>A pointer to memory, where to store. </td></tr>
    <tr><td class="paramname">align</td><td>Determines whether <code>memory</code> is an aligned pointer or not.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="classVc_1_1Memory.html" title="A helper class for fixed-size two-dimensional arrays.">Memory</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a6af89dec7a2dde3440c8983aa9ffaaa7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float&amp; operator[] </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This operator can be used to modify scalar entries of the vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>A value between 0 and Size. This value is not checked internally so you must make/be sure it is in range.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to the vector entry at the given <code>index</code>.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>This operator is known to miscompile with GCC 4.3.x. </dd>
<dd>
The use of this function may result in suboptimal performance. Please check whether you can find a more vector-friendly way to do what you need. </dd></dl>

</div>
</div>
<a class="anchor" id="a151eef77f4fc6db54a86ac7962f51298"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float operator[] </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This operator can be used to read scalar entries of the vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>A value between 0 and Size. This value is not checked internally so you must make/be sure it is in range.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the vector entry at the given <code>index</code>. </dd></dl>

</div>
</div>
<a class="anchor" id="a9f958f4fb9d4c82123e2973b9b4f1b2d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MaskedVector operator() </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classVc_1_1sfloat__m.html">sfloat_m</a> &amp;&#160;</td>
          <td class="paramname"><em>mask</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writemask the vector before an assignment. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mask</td><td>The writemask to be used.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an object that can be used for any kind of masked assignment.</dd></dl>
<p>The returned object is only to be used for assignments and should not be assigned to a variable.</p>
<p>Examples: </p>
<div class="fragment"><div class="line">float_v v = <a class="code" href="classVc_1_1sfloat__v.html#ab67571d1c87a66074a5607a17286f80a" title="Returns a vector with the entries initialized to zero.">float_v::Zero</a>();         <span class="comment">// v  = [0, 0, 0, 0]</span></div>
<div class="line">int_v v2 = <a class="code" href="classVc_1_1sfloat__v.html#a9f637994d1b02f99c34d2a1a5d4ba3ec" title="Returns a vector with the entries initialized to 0, 1, 2, 3, 4, 5, ...">int_v::IndexesFromZero</a>(); <span class="comment">// v2 = [0, 1, 2, 3]</span></div>
<div class="line">v(v2 &lt; 2) = 1.f;                     <span class="comment">// v  = [1, 1, 0, 0]</span></div>
<div class="line">v(v2 &lt; 3) += 1.f;                    <span class="comment">// v  = [2, 2, 1, 0]</span></div>
<div class="line">++v2(v &lt; 1.f);                       <span class="comment">// v2 = [0, 1, 2, 4]</span></div>
</div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="a12251d6ec24adc218697dac0668f3a90"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fusedMultiplyAdd </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classVc_1_1sfloat__v.html">sfloat_v</a>&#160;</td>
          <td class="paramname"><em>factor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classVc_1_1sfloat__v.html">sfloat_v</a>&#160;</td>
          <td class="paramname"><em>summand</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiplies this vector with <code>factor</code> and then adds <code>summand</code>, without rounding between the multiplication and the addition. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">factor</td><td>The multiplication factor. </td></tr>
    <tr><td class="paramname">summand</td><td>The summand that will be added after multiplication.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This operation may have explicit hardware support, in which case it is normally faster to use the FMA instead of separate multiply and add instructions. </dd>
<dd>
If the target hardware does not have FMA support this function will be considerably slower than a normal a * b + c. This is due to the increased precision fusedMultiplyAdd provides. </dd></dl>

</div>
</div>
<a class="anchor" id="aa19d201a89cb214b555f403023033ded"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVc_1_1sfloat__v.html">sfloat_v</a> sorted </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a sorted copy of the vector. </p>
<dl class="section return"><dt>Returns</dt><dd>A sorted vector. The returned values are in ascending order: <pre class="fragment">v[0] &lt;= v[1] &lt;= v[2] &lt;= v[3] ...
</pre></dd></dl>
<p>Example: </p>
<div class="fragment"><div class="line">int_v v = <a class="code" href="classVc_1_1sfloat__v.html#a5b04c986a1c5b54fdc58107b87891772" title="Returns a vector with pseudo-random entries.">int_v::Random</a>();</div>
<div class="line">int_v s = v.sorted();</div>
<div class="line">std::cout &lt;&lt; v &lt;&lt; <span class="charliteral">&#39;\n&#39;</span> &lt;&lt; s &lt;&lt; <span class="charliteral">&#39;\n&#39;</span>;</div>
</div><!-- fragment --><p>With SSE the output would be:</p>
<pre class="fragment">[1513634383, -963914658, 1763536262, -1285037745]
[-1285037745, -963914658, 1513634383, 1763536262]
</pre><p>With the Scalar implementation: </p>
<pre class="fragment">[1513634383]
[1513634383]
</pre> 
</div>
</div>
<a class="anchor" id="a76698ef0ed65fc78feacfcd49732d411"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVc_1_1sfloat__v.html">sfloat_v</a> copySign </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classVc_1_1sfloat__v.html">sfloat_v</a>&#160;</td>
          <td class="paramname"><em>reference</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copies the sign of <code>reference</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">reference</td><td>This values sign bit will be transferred.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a value where the sign of the value equals the sign of <code>reference</code>. I.e. sign(v.copySign(r)) == sign(r). </dd></dl>

</div>
</div>
<a class="anchor" id="a9896cb0171bf56d11a183cd85d08a0ba"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVc_1_1sfloat__v.html">sfloat_v</a> exponent </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Extracts the exponent. </p>
<dl class="section return"><dt>Returns</dt><dd>the exponent to base 2.</dd></dl>
<p>This function provides efficient access to the exponent of the floating point number. The returned value is a fast approximation to the logarithm of base 2. The absolute error of that approximation is between [0, 1[.</p>
<p>Examples: </p>
<pre class="fragment"> value | exponent | log2
=======|==========|=======
   1.0 |        0 | 0
   2.0 |        1 | 1
   3.0 |        1 | 1.585
   3.9 |        1 | 1.963
   4.0 |        2 | 2
   4.1 |        2 | 2.036
</pre><dl class="section warning"><dt>Warning</dt><dd>This function assumes a positive value (non-zero). If the value is negative the sign bit will modify the returned value. An input value of zero will return the bias of the floating-point representation. If you compile with <a class="el" href="namespaceVc.html" title="Vector Classes Namespace.">Vc</a> runtime checks, the function will assert values greater than or equal to zero.</dd></dl>
<p>You may use abs to apply this function to negative values: </p>
<div class="fragment"><div class="line"><a class="code" href="group__Math.html#ga5743c4736b0c214b1a2a48c5f3d187a3" title="Returns the absolute value of v.">abs</a>(v).<a class="code" href="classVc_1_1float__v.html#a0d3ca9f194a88cf37626e2395898edb1" title="Extracts the exponent.">exponent</a>()</div>
</div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="ae2c7550ba227c1418f364f6cca49a493"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVc_1_1sfloat__m.html">sfloat_m</a> isNegative </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check the sign bit of each vector entry. </p>
<dl class="section return"><dt>Returns</dt><dd>whether the sign bit is set.</dd></dl>
<p>This function is especially useful to distinguish negative zero. </p>
<div class="fragment"><div class="line">float_v z  = <a class="code" href="classVc_1_1sfloat__v.html#ab67571d1c87a66074a5607a17286f80a" title="Returns a vector with the entries initialized to zero.">float_v::Zero</a>(); <span class="comment">//  z.isNegative() will be m[0000],  z &lt; float_v::Zero() will be m[0000]</span></div>
<div class="line">float_v nz = -0.f;            <span class="comment">// nz.isNegative() will be m[1111], nz &lt; float_v::Zero() will be m[0000]</span></div>
<div class="line">float_v n  = -1.f;            <span class="comment">//  n.isNegative() will be m[1111],  n &lt; float_v::Zero() will be m[1111]</span></div>
</div><!-- fragment --> 
</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespaceVc.html">Vc</a></li><li class="navelem"><a class="el" href="classVc_1_1sfloat__v.html">sfloat_v</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.1.2 </li>
  </ul>
</div>
</body>
</html>
