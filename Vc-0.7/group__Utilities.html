<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>Vc: Utilities</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() {
    if ($('.searchresults').length > 0) { searchBox.DOMSearchField().focus(); }
  });
</script>
<link rel="search" href="search-opensearch.php?v=opensearch.xml" type="application/opensearchdescription+xml" title="Vc"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo_small.png"/></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">Vc
   &#160;<span id="projectnumber">0.7.5-dev</span>
   </div>
   <div id="projectbrief">SIMD Vector Classes for C++</div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
          <div class="left">
            <form id="FSearchBox" action="search.php" method="get">
              <img id="MSearchSelect" src="search/mag.png" alt=""/>
              <input type="text" id="MSearchField" name="query" value="Search" size="20" accesskey="S" 
                     onfocus="searchBox.OnSearchFieldFocus(true)" 
                     onblur="searchBox.OnSearchFieldFocus(false)"/>
            </form>
          </div><div class="right"></div>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.1.2 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('group__Utilities.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Utilities</div>  </div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2>Detailed Description</h2>
<p>Additional classes, macros, and functions that help to work more easily with the main vector types. </p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVc_1_1CpuId.html">CpuId</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class is available for x86 / AMD64 systems to read and interpret information about the CPU's capabilities.  <a href="classVc_1_1CpuId.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVc_1_1Allocator.html">Allocator&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An allocator that uses global new and supports over-aligned types, as per [C++11 20.6.9].  <a href="classVc_1_1Allocator.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVc_1_1VectorAlignedBase.html">VectorAlignedBase</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper class to ensure proper alignment.  <a href="classVc_1_1VectorAlignedBase.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVc_1_1VectorAlignedBaseT.html">VectorAlignedBaseT&lt; V &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper class to ensure proper alignment.  <a href="classVc_1_1VectorAlignedBaseT.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVc_1_1InterleavedMemoryWrapper.html">InterleavedMemoryWrapper&lt; S, V &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wraps a pointer to memory with convenience functions to access it via vectors.  <a href="classVc_1_1InterleavedMemoryWrapper.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVc_1_1Memory.html">Memory&lt; V, Size1, Size2 &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A helper class for fixed-size two-dimensional arrays.  <a href="classVc_1_1Memory.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVc_1_1Memory_3_01V_00_01Size_00_010u_01_4.html">Memory&lt; V, Size, 0u &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A helper class to simplify usage of correctly aligned and padded memory, allowing both vector and scalar access.  <a href="classVc_1_1Memory_3_01V_00_01Size_00_010u_01_4.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVc_1_1Memory_3_01V_00_010u_00_010u_01_4.html">Memory&lt; V, 0u, 0u &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A helper class that is very similar to Memory&lt;V, Size&gt; but with dynamically allocated memory and thus dynamic size.  <a href="classVc_1_1Memory_3_01V_00_010u_00_010u_01_4.html#details">More...</a><br/></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ga0d6b1a2931c3ae6e7897f6f2ebe737ee"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Utilities.html#ga0d6b1a2931c3ae6e7897f6f2ebe737ee">VC_DECLARE_ALLOCATOR</a>(Type)</td></tr>
<tr class="memdesc:ga0d6b1a2931c3ae6e7897f6f2ebe737ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience macro to set the default allocator for a given <code>Type</code> to <a class="el" href="classVc_1_1Allocator.html" title="An allocator that uses global new and supports over-aligned types, as per [C++11 20.6.9].">Vc::Allocator</a>.  <a href="#ga0d6b1a2931c3ae6e7897f6f2ebe737ee"></a><br/></td></tr>
<tr class="memitem:gac915a9bb47c44669503fa6c6ca912a7d"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Utilities.html#gac915a9bb47c44669503fa6c6ca912a7d">Vc_foreach_bit</a>(iterator, mask)</td></tr>
<tr class="memdesc:gac915a9bb47c44669503fa6c6ca912a7d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loop over all set bits in the mask.  <a href="#gac915a9bb47c44669503fa6c6ca912a7d"></a><br/></td></tr>
<tr class="memitem:ga06c3d30b8dc466b32e2e7a341fb4e3de"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga06c3d30b8dc466b32e2e7a341fb4e3de"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Utilities.html#ga06c3d30b8dc466b32e2e7a341fb4e3de">foreach_bit</a>(iterator, mask)</td></tr>
<tr class="memdesc:ga06c3d30b8dc466b32e2e7a341fb4e3de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias for Vc_foreach_bit unless VC_CLEAN_NAMESPACE is defined. <br/></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:gaebce8b3227fdcca97fba94556a1b2461"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Utilities.html#gaebce8b3227fdcca97fba94556a1b2461">MallocAlignment</a> { <a class="el" href="group__Utilities.html#ggaebce8b3227fdcca97fba94556a1b2461aea1085049aede31b7bbb8c5a06815446">AlignOnVector</a>, 
<a class="el" href="group__Utilities.html#ggaebce8b3227fdcca97fba94556a1b2461ae5f918b27baba790e8931d2f1173905f">AlignOnCacheline</a>, 
<a class="el" href="group__Utilities.html#ggaebce8b3227fdcca97fba94556a1b2461ae4cff9800dfef630b91432a0eda00f4b">AlignOnPage</a>
 }</td></tr>
<tr class="memdesc:gaebce8b3227fdcca97fba94556a1b2461"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enum that specifies the alignment and padding restrictions to use for memory allocation with <a class="el" href="group__Utilities.html#ga3ad68314ae283bc298864bf18b3aa8a4" title="Allocates memory on the Heap with alignment and padding suitable for vectorized access.">Vc::malloc</a>.  <a href="group__Utilities.html#gaebce8b3227fdcca97fba94556a1b2461">More...</a><br/></td></tr>
<tr class="memitem:ga9107acb389f0886054bea6298a73e191"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Utilities.html#ga9107acb389f0886054bea6298a73e191">Implementation</a> { <br/>
&#160;&#160;<a class="el" href="group__Utilities.html#gga9107acb389f0886054bea6298a73e191af8eadb5528c544043ceb2e0bbe1615ac">ScalarImpl</a>, 
<a class="el" href="group__Utilities.html#gga9107acb389f0886054bea6298a73e191a96e70e00d8209faf9f4f5d45d5fb2c91">SSE2Impl</a>, 
<a class="el" href="group__Utilities.html#gga9107acb389f0886054bea6298a73e191a7d172cb38b02af566e6e256bc3c9fc6f">SSE3Impl</a>, 
<a class="el" href="group__Utilities.html#gga9107acb389f0886054bea6298a73e191a4f2b8ddd973d24ac7984678bf4a9bf7a">SSSE3Impl</a>, 
<br/>
&#160;&#160;<a class="el" href="group__Utilities.html#gga9107acb389f0886054bea6298a73e191a42c84ad8cf63407232d74ccef344d1b4">SSE41Impl</a>, 
<a class="el" href="group__Utilities.html#gga9107acb389f0886054bea6298a73e191a9ebefe4bccb3fb7ae762b9513f7d1f3e">SSE42Impl</a>, 
<a class="el" href="group__Utilities.html#gga9107acb389f0886054bea6298a73e191a43a1748f49066bcfb077da5844e5ac19">AVXImpl</a>, 
<a class="el" href="group__Utilities.html#gga9107acb389f0886054bea6298a73e191a0ec1beefc339f966fe6bc79f29157417">AVX2Impl</a>
<br/>
 }</td></tr>
<tr class="memdesc:ga9107acb389f0886054bea6298a73e191"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enum to identify a certain SIMD instruction set.  <a href="group__Utilities.html#ga9107acb389f0886054bea6298a73e191">More...</a><br/></td></tr>
<tr class="memitem:ga89dcaec020724abe1ef7f3d65c7df429"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Utilities.html#ga89dcaec020724abe1ef7f3d65c7df429">ExtraInstructions</a> { <br/>
&#160;&#160;<a class="el" href="group__Utilities.html#gga89dcaec020724abe1ef7f3d65c7df429acaab28ad7711fd8542454766cef23f2c">Float16cInstructions</a> =  0x01000, 
<a class="el" href="group__Utilities.html#gga89dcaec020724abe1ef7f3d65c7df429a785542afdf7805511a1c0d1679a9d6ea">Fma4Instructions</a> =  0x02000, 
<a class="el" href="group__Utilities.html#gga89dcaec020724abe1ef7f3d65c7df429a439e5c3106f696004e78b4f79e5918b6">XopInstructions</a> =  0x04000, 
<a class="el" href="group__Utilities.html#gga89dcaec020724abe1ef7f3d65c7df429aee6cf7ebb69a99ec4ffbdea63d0d7a76">PopcntInstructions</a> =  0x08000, 
<br/>
&#160;&#160;<a class="el" href="group__Utilities.html#gga89dcaec020724abe1ef7f3d65c7df429af7a4407dc74ee8444bffedca74ca942d">Sse4aInstructions</a> =  0x10000, 
<a class="el" href="group__Utilities.html#gga89dcaec020724abe1ef7f3d65c7df429a84146480ab7df66c222fdda2f7a513da">FmaInstructions</a> =  0x20000
<br/>
 }</td></tr>
<tr class="memdesc:ga89dcaec020724abe1ef7f3d65c7df429"><td class="mdescLeft">&#160;</td><td class="mdescRight">The list of available instructions is not easily described by a linear list of instruction sets.  <a href="group__Utilities.html#ga89dcaec020724abe1ef7f3d65c7df429">More...</a><br/></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gabfd2bbd2ca053de313afe500a540a1e1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Utilities.html#gabfd2bbd2ca053de313afe500a540a1e1">forceToRegisters</a> (const vec &amp;,...)</td></tr>
<tr class="memdesc:gabfd2bbd2ca053de313afe500a540a1e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Force the vectors passed to the function into registers.  <a href="#gabfd2bbd2ca053de313afe500a540a1e1"></a><br/></td></tr>
<tr class="memitem:ga455ba5c796b6a7ea10b4637b5f91fd21"><td class="memTemplParams" colspan="2">template&lt;typename V , typename Parent , typename Dimension , typename RM &gt; </td></tr>
<tr class="memitem:ga455ba5c796b6a7ea10b4637b5f91fd21"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Utilities.html#ga455ba5c796b6a7ea10b4637b5f91fd21">operator&lt;&lt;</a> (std::ostream &amp;s, const <a class="el" href="classVc_1_1MemoryBase.html">Vc::MemoryBase</a>&lt; V, Parent, Dimension, RM &gt; &amp;m)</td></tr>
<tr class="memdesc:ga455ba5c796b6a7ea10b4637b5f91fd21"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints the contents of a Memory object into a stream object.  <a href="#ga455ba5c796b6a7ea10b4637b5f91fd21"></a><br/></td></tr>
<tr class="memitem:ga5f60d3eac127759ab0725a07a27d564a"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Utilities.html#ga5f60d3eac127759ab0725a07a27d564a">versionString</a> ()</td></tr>
<tr class="memitem:ga0ff0ab27c63416b49278b0d00c5981f4"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Utilities.html#ga0ff0ab27c63416b49278b0d00c5981f4">versionNumber</a> ()</td></tr>
<tr class="memitem:ga3ad68314ae283bc298864bf18b3aa8a4"><td class="memTemplParams" colspan="2">template&lt;typename T , Vc::MallocAlignment A&gt; </td></tr>
<tr class="memitem:ga3ad68314ae283bc298864bf18b3aa8a4"><td class="memTemplItemLeft" align="right" valign="top">T *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Utilities.html#ga3ad68314ae283bc298864bf18b3aa8a4">malloc</a> (size_t n)</td></tr>
<tr class="memdesc:ga3ad68314ae283bc298864bf18b3aa8a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocates memory on the Heap with alignment and padding suitable for vectorized access.  <a href="#ga3ad68314ae283bc298864bf18b3aa8a4"></a><br/></td></tr>
<tr class="memitem:gaee7f695ddd66d27230262733d9727435"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:gaee7f695ddd66d27230262733d9727435"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Utilities.html#gaee7f695ddd66d27230262733d9727435">free</a> (T *p)</td></tr>
<tr class="memdesc:gaee7f695ddd66d27230262733d9727435"><td class="mdescLeft">&#160;</td><td class="mdescRight">Frees memory that was allocated with <a class="el" href="group__Utilities.html#ga3ad68314ae283bc298864bf18b3aa8a4" title="Allocates memory on the Heap with alignment and padding suitable for vectorized access.">Vc::malloc</a>.  <a href="#gaee7f695ddd66d27230262733d9727435"></a><br/></td></tr>
<tr class="memitem:ga750e7279ea163a807f12ca559c86b8be"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Utilities.html#ga750e7279ea163a807f12ca559c86b8be">prefetchForOneRead</a> (const void *addr)</td></tr>
<tr class="memdesc:ga750e7279ea163a807f12ca559c86b8be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prefetch the cacheline containing <code>addr</code> for a single read access.  <a href="#ga750e7279ea163a807f12ca559c86b8be"></a><br/></td></tr>
<tr class="memitem:ga66e169340ecf92fea214f0c11f2bada7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Utilities.html#ga66e169340ecf92fea214f0c11f2bada7">prefetchForModify</a> (const void *addr)</td></tr>
<tr class="memdesc:ga66e169340ecf92fea214f0c11f2bada7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prefetch the cacheline containing <code>addr</code> for modification.  <a href="#ga66e169340ecf92fea214f0c11f2bada7"></a><br/></td></tr>
<tr class="memitem:ga251e2a042b8723d9a272e40730b775c4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Utilities.html#ga251e2a042b8723d9a272e40730b775c4">prefetchClose</a> (const void *addr)</td></tr>
<tr class="memdesc:ga251e2a042b8723d9a272e40730b775c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prefetch the cacheline containing <code>addr</code> to L1 cache.  <a href="#ga251e2a042b8723d9a272e40730b775c4"></a><br/></td></tr>
<tr class="memitem:gabac2858df65bd48aad8268073c23a975"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Utilities.html#gabac2858df65bd48aad8268073c23a975">prefetchMid</a> (const void *addr)</td></tr>
<tr class="memdesc:gabac2858df65bd48aad8268073c23a975"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prefetch the cacheline containing <code>addr</code> to L2 cache.  <a href="#gabac2858df65bd48aad8268073c23a975"></a><br/></td></tr>
<tr class="memitem:ga7294a2e0deacbb4773f4f2d0722861c9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Utilities.html#ga7294a2e0deacbb4773f4f2d0722861c9">prefetchFar</a> (const void *addr)</td></tr>
<tr class="memdesc:ga7294a2e0deacbb4773f4f2d0722861c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prefetch the cacheline containing <code>addr</code> to L3 cache.  <a href="#ga7294a2e0deacbb4773f4f2d0722861c9"></a><br/></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="member-group"></a>
Micro-Architecture Feature Tests</h2></td></tr>
<tr class="memitem:ga382d9c155a283ee6e0b6db203f563ed0"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Utilities.html#ga382d9c155a283ee6e0b6db203f563ed0">extraInstructionsSupported</a> ()</td></tr>
<tr class="memdesc:ga382d9c155a283ee6e0b6db203f563ed0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines the extra instructions supported by the current CPU.  <a href="#ga382d9c155a283ee6e0b6db203f563ed0"></a><br/></td></tr>
<tr class="memitem:ga85daae7f9fd2e0509b317bbaaade7d90"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Utilities.html#ga85daae7f9fd2e0509b317bbaaade7d90">isImplementationSupported</a> (<a class="el" href="group__Utilities.html#ga9107acb389f0886054bea6298a73e191">Vc::Implementation</a> impl)</td></tr>
<tr class="memdesc:ga85daae7f9fd2e0509b317bbaaade7d90"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tests whether the given implementation is supported by the system the code is executing on.  <a href="#ga85daae7f9fd2e0509b317bbaaade7d90"></a><br/></td></tr>
<tr class="memitem:ga4bd9588ab59f9c0316f73c4de8b328a4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__Utilities.html#ga9107acb389f0886054bea6298a73e191">Vc::Implementation</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Utilities.html#ga4bd9588ab59f9c0316f73c4de8b328a4">bestImplementationSupported</a> ()</td></tr>
<tr class="memdesc:ga4bd9588ab59f9c0316f73c4de8b328a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines the best supported implementation for the current system.  <a href="#ga4bd9588ab59f9c0316f73c4de8b328a4"></a><br/></td></tr>
<tr class="memitem:gaf6a7f1d58808117b81cac7dcd054895e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Utilities.html#gaf6a7f1d58808117b81cac7dcd054895e">currentImplementationSupported</a> ()</td></tr>
<tr class="memdesc:gaf6a7f1d58808117b81cac7dcd054895e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tests that the CPU and Operating System support the vector unit which was compiled for.  <a href="#gaf6a7f1d58808117b81cac7dcd054895e"></a><br/></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="member-group"></a>
SIMD Support Feature Macros</h2></td></tr>
<tr class="memitem:ga63c9e529b3dce02bcbc2e9f16f86be27"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga63c9e529b3dce02bcbc2e9f16f86be27"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Utilities.html#ga63c9e529b3dce02bcbc2e9f16f86be27">VC_IMPL</a></td></tr>
<tr class="memdesc:ga63c9e529b3dce02bcbc2e9f16f86be27"><td class="mdescLeft">&#160;</td><td class="mdescRight">This macro is set to the value of <a class="el" href="group__Utilities.html#ga9107acb389f0886054bea6298a73e191">Vc::Implementation</a> that the current translation unit is compiled with. <br/></td></tr>
<tr class="memitem:ga936bfd12575997951283ac139374d6e6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga936bfd12575997951283ac139374d6e6"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Utilities.html#ga936bfd12575997951283ac139374d6e6">VC_IMPL_XOP</a></td></tr>
<tr class="memdesc:ga936bfd12575997951283ac139374d6e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">This macro is defined if the current translation unit is compiled with XOP instruction support. <br/></td></tr>
<tr class="memitem:ga7f817e8925138083abc94e2da6ce09dc"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga7f817e8925138083abc94e2da6ce09dc"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Utilities.html#ga7f817e8925138083abc94e2da6ce09dc">VC_IMPL_FMA4</a></td></tr>
<tr class="memdesc:ga7f817e8925138083abc94e2da6ce09dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">This macro is defined if the current translation unit is compiled with FMA4 instruction support. <br/></td></tr>
<tr class="memitem:ga4594c74ec7af5aeda73c83b1ec283bfd"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga4594c74ec7af5aeda73c83b1ec283bfd"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Utilities.html#ga4594c74ec7af5aeda73c83b1ec283bfd">VC_IMPL_F16C</a></td></tr>
<tr class="memdesc:ga4594c74ec7af5aeda73c83b1ec283bfd"><td class="mdescLeft">&#160;</td><td class="mdescRight">This macro is defined if the current translation unit is compiled with F16C instruction support. <br/></td></tr>
<tr class="memitem:ga0f269649513968fdf44994aef1b6e91e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga0f269649513968fdf44994aef1b6e91e"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Utilities.html#ga0f269649513968fdf44994aef1b6e91e">VC_IMPL_POPCNT</a></td></tr>
<tr class="memdesc:ga0f269649513968fdf44994aef1b6e91e"><td class="mdescLeft">&#160;</td><td class="mdescRight">This macro is defined if the current translation unit is compiled with POPCNT instruction support. <br/></td></tr>
<tr class="memitem:gafe8ed9e2900ce7595e88e8027ff4b782"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gafe8ed9e2900ce7595e88e8027ff4b782"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Utilities.html#gafe8ed9e2900ce7595e88e8027ff4b782">VC_IMPL_SSE4a</a></td></tr>
<tr class="memdesc:gafe8ed9e2900ce7595e88e8027ff4b782"><td class="mdescLeft">&#160;</td><td class="mdescRight">This macro is defined if the current translation unit is compiled with SSE4a instruction support. <br/></td></tr>
<tr class="memitem:ga78070586c83cce48c4dd5cf216296016"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga78070586c83cce48c4dd5cf216296016"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Utilities.html#ga78070586c83cce48c4dd5cf216296016">VC_IMPL_Scalar</a></td></tr>
<tr class="memdesc:ga78070586c83cce48c4dd5cf216296016"><td class="mdescLeft">&#160;</td><td class="mdescRight">This macro is defined if the current translation unit is compiled without any SIMD support. <br/></td></tr>
<tr class="memitem:ga4011911958c613d8d6f13ea3c487bd05"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga4011911958c613d8d6f13ea3c487bd05"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Utilities.html#ga4011911958c613d8d6f13ea3c487bd05">VC_IMPL_SSE</a></td></tr>
<tr class="memdesc:ga4011911958c613d8d6f13ea3c487bd05"><td class="mdescLeft">&#160;</td><td class="mdescRight">This macro is defined if the current translation unit is compiled with any version of SSE (but not AVX). <br/></td></tr>
<tr class="memitem:gafb27bdc29c007187c36e80d5f8ea87f3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gafb27bdc29c007187c36e80d5f8ea87f3"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Utilities.html#gafb27bdc29c007187c36e80d5f8ea87f3">VC_IMPL_SSE2</a></td></tr>
<tr class="memdesc:gafb27bdc29c007187c36e80d5f8ea87f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">This macro is defined if the current translation unit is compiled with SSE2 instruction support (excluding SSE3 and up). <br/></td></tr>
<tr class="memitem:gaa554a8044ca9c06d8a091f14aa406622"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaa554a8044ca9c06d8a091f14aa406622"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Utilities.html#gaa554a8044ca9c06d8a091f14aa406622">VC_IMPL_SSE3</a></td></tr>
<tr class="memdesc:gaa554a8044ca9c06d8a091f14aa406622"><td class="mdescLeft">&#160;</td><td class="mdescRight">This macro is defined if the current translation unit is compiled with SSE3 instruction support (excluding SSSE3 and up). <br/></td></tr>
<tr class="memitem:gaba3f10f362a0324b50ff4303f52bc580"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaba3f10f362a0324b50ff4303f52bc580"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Utilities.html#gaba3f10f362a0324b50ff4303f52bc580">VC_IMPL_SSSE3</a></td></tr>
<tr class="memdesc:gaba3f10f362a0324b50ff4303f52bc580"><td class="mdescLeft">&#160;</td><td class="mdescRight">This macro is defined if the current translation unit is compiled with SSSE3 instruction support (excluding SSE4.1 and up). <br/></td></tr>
<tr class="memitem:ga86b2f48ff2002645386b0ce52381d72a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga86b2f48ff2002645386b0ce52381d72a"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Utilities.html#ga86b2f48ff2002645386b0ce52381d72a">VC_IMPL_SSE4_1</a></td></tr>
<tr class="memdesc:ga86b2f48ff2002645386b0ce52381d72a"><td class="mdescLeft">&#160;</td><td class="mdescRight">This macro is defined if the current translation unit is compiled with SSE4.1 instruction support (excluding SSE4.2 and up). <br/></td></tr>
<tr class="memitem:ga8cec9b6caa532d2146583c23b08d8922"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga8cec9b6caa532d2146583c23b08d8922"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Utilities.html#ga8cec9b6caa532d2146583c23b08d8922">VC_IMPL_SSE4_2</a></td></tr>
<tr class="memdesc:ga8cec9b6caa532d2146583c23b08d8922"><td class="mdescLeft">&#160;</td><td class="mdescRight">This macro is defined if the current translation unit is compiled with SSE4.2 instruction support (excluding AVX and up). <br/></td></tr>
<tr class="memitem:ga50f1604f3f2fb1b6831efa51f0e57919"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga50f1604f3f2fb1b6831efa51f0e57919"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Utilities.html#ga50f1604f3f2fb1b6831efa51f0e57919">VC_IMPL_AVX</a></td></tr>
<tr class="memdesc:ga50f1604f3f2fb1b6831efa51f0e57919"><td class="mdescLeft">&#160;</td><td class="mdescRight">This macro is defined if the current translation unit is compiled with AVX instruction support (excluding AVX2 and up). <br/></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="member-group"></a>
Version Macros</h2></td></tr>
<tr class="memitem:ga812c8294294cb348ff0ad259ac798265"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Utilities.html#ga812c8294294cb348ff0ad259ac798265">VC_VERSION_STRING</a></td></tr>
<tr class="memdesc:ga812c8294294cb348ff0ad259ac798265"><td class="mdescLeft">&#160;</td><td class="mdescRight">Contains the version string of the Vc headers.  <a href="#ga812c8294294cb348ff0ad259ac798265"></a><br/></td></tr>
<tr class="memitem:ga55b71a0f868dbe08069a277a6111d7af"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Utilities.html#ga55b71a0f868dbe08069a277a6111d7af">VC_VERSION_NUMBER</a></td></tr>
<tr class="memdesc:ga55b71a0f868dbe08069a277a6111d7af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Contains the encoded version number of the Vc headers.  <a href="#ga55b71a0f868dbe08069a277a6111d7af"></a><br/></td></tr>
<tr class="memitem:ga2e250b133707bed3fa84d1bb38d4b14e"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Utilities.html#ga2e250b133707bed3fa84d1bb38d4b14e">VC_VERSION_CHECK</a>(major, minor, patch)</td></tr>
<tr class="memdesc:ga2e250b133707bed3fa84d1bb38d4b14e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper macro to compare against an encoded version number.  <a href="#ga2e250b133707bed3fa84d1bb38d4b14e"></a><br/></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="member-group"></a>
SIMD Vector Size Macros</h2></td></tr>
<tr class="memitem:gaa471ec0eae4d903396f86cae3d18ecf0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaa471ec0eae4d903396f86cae3d18ecf0"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Utilities.html#gaa471ec0eae4d903396f86cae3d18ecf0">VC_DOUBLE_V_SIZE</a></td></tr>
<tr class="memdesc:gaa471ec0eae4d903396f86cae3d18ecf0"><td class="mdescLeft">&#160;</td><td class="mdescRight">An integer (for use with the preprocessor) that gives the number of entries in a double_v. <br/></td></tr>
<tr class="memitem:ga38e670b3ba0070c4eecbada758f7660c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga38e670b3ba0070c4eecbada758f7660c"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Utilities.html#ga38e670b3ba0070c4eecbada758f7660c">VC_FLOAT_V_SIZE</a></td></tr>
<tr class="memdesc:ga38e670b3ba0070c4eecbada758f7660c"><td class="mdescLeft">&#160;</td><td class="mdescRight">An integer (for use with the preprocessor) that gives the number of entries in a float_v. <br/></td></tr>
<tr class="memitem:gad41e89974fd0b4dc744da19d33152bd4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gad41e89974fd0b4dc744da19d33152bd4"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Utilities.html#gad41e89974fd0b4dc744da19d33152bd4">VC_SFLOAT_V_SIZE</a></td></tr>
<tr class="memdesc:gad41e89974fd0b4dc744da19d33152bd4"><td class="mdescLeft">&#160;</td><td class="mdescRight">An integer (for use with the preprocessor) that gives the number of entries in a sfloat_v. <br/></td></tr>
<tr class="memitem:ga7341c660e0843ff9f357eefdb8731c98"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga7341c660e0843ff9f357eefdb8731c98"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Utilities.html#ga7341c660e0843ff9f357eefdb8731c98">VC_INT_V_SIZE</a></td></tr>
<tr class="memdesc:ga7341c660e0843ff9f357eefdb8731c98"><td class="mdescLeft">&#160;</td><td class="mdescRight">An integer (for use with the preprocessor) that gives the number of entries in a int_v. <br/></td></tr>
<tr class="memitem:gae17e7328bbc0be4ce5c6494325901240"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gae17e7328bbc0be4ce5c6494325901240"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Utilities.html#gae17e7328bbc0be4ce5c6494325901240">VC_UINT_V_SIZE</a></td></tr>
<tr class="memdesc:gae17e7328bbc0be4ce5c6494325901240"><td class="mdescLeft">&#160;</td><td class="mdescRight">An integer (for use with the preprocessor) that gives the number of entries in a uint_v. <br/></td></tr>
<tr class="memitem:gaf71c950e166bb6eabaffb990865e30ab"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaf71c950e166bb6eabaffb990865e30ab"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Utilities.html#gaf71c950e166bb6eabaffb990865e30ab">VC_SHORT_V_SIZE</a></td></tr>
<tr class="memdesc:gaf71c950e166bb6eabaffb990865e30ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">An integer (for use with the preprocessor) that gives the number of entries in a short_v. <br/></td></tr>
<tr class="memitem:ga0edb66f22e3261ff8a8d6e26610e4023"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga0edb66f22e3261ff8a8d6e26610e4023"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Utilities.html#ga0edb66f22e3261ff8a8d6e26610e4023">VC_USHORT_V_SIZE</a></td></tr>
<tr class="memdesc:ga0edb66f22e3261ff8a8d6e26610e4023"><td class="mdescLeft">&#160;</td><td class="mdescRight">An integer (for use with the preprocessor) that gives the number of entries in a ushort_v. <br/></td></tr>
</table>
<h2>Macro Definition Documentation</h2>
<a class="anchor" id="ga0d6b1a2931c3ae6e7897f6f2ebe737ee"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define VC_DECLARE_ALLOCATOR</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">Type</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line"><span class="keyword">namespace </span>std \</div>
<div class="line">{ \</div>
<div class="line">    template&lt;&gt; <span class="keyword">class </span>allocator&lt;Type&gt; : <span class="keyword">public</span> <a class="code" href="classVc_1_1Allocator.html" title="An allocator that uses global new and supports over-aligned types, as per [C++11 20.6.9].">::Vc::Allocator</a>&lt;Type&gt; \</div>
<div class="line">    { \</div>
<div class="line">    public: \</div>
<div class="line">        template&lt;typename U&gt; <span class="keyword">struct </span>rebind { typedef ::std::allocator&lt;U&gt; other; }; \</div>
<div class="line">    }; \</div>
<div class="line">}</div>
</div><!-- fragment -->
<p>Convenience macro to set the default allocator for a given <code>Type</code> to <a class="el" href="classVc_1_1Allocator.html" title="An allocator that uses global new and supports over-aligned types, as per [C++11 20.6.9].">Vc::Allocator</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Type</td><td>Your type that you want to use with STL containers.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>You have to use this macro in the global namespace. </dd></dl>

</div>
</div>
<a class="anchor" id="gac915a9bb47c44669503fa6c6ca912a7d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define Vc_foreach_bit</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">iterator, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">mask&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Loop over all set bits in the mask. </p>
<p>The iterator variable will be set to the position of the set bits. A mask of e.g. 00011010 would result in the loop being called with the iterator being set to 1, 3, and 4.</p>
<p>This allows you to write: </p>
<div class="fragment"><div class="line">float_v a = ...;</div>
<div class="line"><a class="code" href="group__Utilities.html#gac915a9bb47c44669503fa6c6ca912a7d" title="Loop over all set bits in the mask.">Vc_foreach_bit</a>(<span class="keywordtype">int</span> i, a &lt; 0.f) {</div>
<div class="line">  std::cout &lt;&lt; a[i] &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div>
<div class="line">}</div>
</div><!-- fragment --><p> The example prints all the values in <code>a</code> that are negative, and only those.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">iterator</td><td>The iterator variable. For example "int i". </td></tr>
    <tr><td class="paramname">mask</td><td>The mask to iterate over. You can also just write a vector operation that returns a mask.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Since Vc 0.7 break and continue are supported in foreach_bit loops. </dd></dl>

</div>
</div>
<a class="anchor" id="ga812c8294294cb348ff0ad259ac798265"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define VC_VERSION_STRING</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Contains the version string of the Vc headers. </p>
<p>Same as <a class="el" href="group__Utilities.html#ga5f60d3eac127759ab0725a07a27d564a">Vc::versionString()</a>. </p>

</div>
</div>
<a class="anchor" id="ga55b71a0f868dbe08069a277a6111d7af"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define VC_VERSION_NUMBER</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Contains the encoded version number of the Vc headers. </p>
<p>Same as <a class="el" href="group__Utilities.html#ga0ff0ab27c63416b49278b0d00c5981f4">Vc::versionNumber()</a>. </p>

</div>
</div>
<a class="anchor" id="ga2e250b133707bed3fa84d1bb38d4b14e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define VC_VERSION_CHECK</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">major, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">minor, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">patch&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Helper macro to compare against an encoded version number. </p>
<p>Example: </p>
<div class="fragment"><div class="line"><span class="preprocessor">#if VC_VERSION_CHECK(0.5.1) &gt;= VC_VERSION_NUMBER</span></div>
</div><!-- fragment --> 
</div>
</div>
<h2>Enumeration Type Documentation</h2>
<a class="anchor" id="gaebce8b3227fdcca97fba94556a1b2461"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__Utilities.html#gaebce8b3227fdcca97fba94556a1b2461">MallocAlignment</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enum that specifies the alignment and padding restrictions to use for memory allocation with <a class="el" href="group__Utilities.html#ga3ad68314ae283bc298864bf18b3aa8a4" title="Allocates memory on the Heap with alignment and padding suitable for vectorized access.">Vc::malloc</a>. </p>
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="ggaebce8b3227fdcca97fba94556a1b2461aea1085049aede31b7bbb8c5a06815446"></a>AlignOnVector</em>&nbsp;</td><td>
<p>Align on boundary of vector sizes (e.g. </p>
<p>16 Bytes on SSE platforms) and pad to allow vector access to the end. Thus the allocated memory contains a multiple of VectorAlignment bytes. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ggaebce8b3227fdcca97fba94556a1b2461ae5f918b27baba790e8931d2f1173905f"></a>AlignOnCacheline</em>&nbsp;</td><td>
<p>Align on boundary of cache line sizes (e.g. </p>
<p>64 Bytes on x86) and pad to allow full cache line access to the end. Thus the allocated memory contains a multiple of 64 bytes. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ggaebce8b3227fdcca97fba94556a1b2461ae4cff9800dfef630b91432a0eda00f4b"></a>AlignOnPage</em>&nbsp;</td><td>
<p>Align on boundary of page sizes (e.g. </p>
<p>4096 Bytes on x86) and pad to allow full page access to the end. Thus the allocated memory contains a multiple of 4096 bytes. </p>
</td></tr>
</table>
</dd>
</dl>

</div>
</div>
<a class="anchor" id="ga9107acb389f0886054bea6298a73e191"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__Utilities.html#ga9107acb389f0886054bea6298a73e191">Implementation</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enum to identify a certain SIMD instruction set. </p>
<p>You can use <a class="el" href="group__Utilities.html#ga63c9e529b3dce02bcbc2e9f16f86be27">VC_IMPL</a> for the currently active implementation.</p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__Utilities.html#ga89dcaec020724abe1ef7f3d65c7df429" title="The list of available instructions is not easily described by a linear list of instruction sets...">ExtraInstructions</a> </dd></dl>
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="gga9107acb389f0886054bea6298a73e191af8eadb5528c544043ceb2e0bbe1615ac"></a>ScalarImpl</em>&nbsp;</td><td>
<p>uses only fundamental types </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="gga9107acb389f0886054bea6298a73e191a96e70e00d8209faf9f4f5d45d5fb2c91"></a>SSE2Impl</em>&nbsp;</td><td>
<p>x86 SSE + SSE2 </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="gga9107acb389f0886054bea6298a73e191a7d172cb38b02af566e6e256bc3c9fc6f"></a>SSE3Impl</em>&nbsp;</td><td>
<p>x86 SSE + SSE2 + SSE3 </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="gga9107acb389f0886054bea6298a73e191a4f2b8ddd973d24ac7984678bf4a9bf7a"></a>SSSE3Impl</em>&nbsp;</td><td>
<p>x86 SSE + SSE2 + SSE3 + SSSE3 </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="gga9107acb389f0886054bea6298a73e191a42c84ad8cf63407232d74ccef344d1b4"></a>SSE41Impl</em>&nbsp;</td><td>
<p>x86 SSE + SSE2 + SSE3 + SSSE3 + SSE4.1 </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="gga9107acb389f0886054bea6298a73e191a9ebefe4bccb3fb7ae762b9513f7d1f3e"></a>SSE42Impl</em>&nbsp;</td><td>
<p>x86 SSE + SSE2 + SSE3 + SSSE3 + SSE4.1 + SSE4.2 </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="gga9107acb389f0886054bea6298a73e191a43a1748f49066bcfb077da5844e5ac19"></a>AVXImpl</em>&nbsp;</td><td>
<p>x86 AVX </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="gga9107acb389f0886054bea6298a73e191a0ec1beefc339f966fe6bc79f29157417"></a>AVX2Impl</em>&nbsp;</td><td>
<p>x86 AVX + AVX2 </p>
</td></tr>
</table>
</dd>
</dl>

</div>
</div>
<a class="anchor" id="ga89dcaec020724abe1ef7f3d65c7df429"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__Utilities.html#ga89dcaec020724abe1ef7f3d65c7df429">ExtraInstructions</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The list of available instructions is not easily described by a linear list of instruction sets. </p>
<p>On x86 the following instruction sets always include their predecessors: SSE2, SSE3, SSSE3, SSE4.1, SSE4.2, AVX, AVX2</p>
<p>But there are additional instructions that are not necessarily required by this list. These are covered in this enum. </p>
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="gga89dcaec020724abe1ef7f3d65c7df429acaab28ad7711fd8542454766cef23f2c"></a>Float16cInstructions</em>&nbsp;</td><td>
<p>Support for float16 conversions in hardware. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="gga89dcaec020724abe1ef7f3d65c7df429a785542afdf7805511a1c0d1679a9d6ea"></a>Fma4Instructions</em>&nbsp;</td><td>
<p>Support for FMA4 instructions. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="gga89dcaec020724abe1ef7f3d65c7df429a439e5c3106f696004e78b4f79e5918b6"></a>XopInstructions</em>&nbsp;</td><td>
<p>Support for XOP instructions. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="gga89dcaec020724abe1ef7f3d65c7df429aee6cf7ebb69a99ec4ffbdea63d0d7a76"></a>PopcntInstructions</em>&nbsp;</td><td>
<p>Support for the population count instruction. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="gga89dcaec020724abe1ef7f3d65c7df429af7a4407dc74ee8444bffedca74ca942d"></a>Sse4aInstructions</em>&nbsp;</td><td>
<p>Support for SSE4a instructions. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="gga89dcaec020724abe1ef7f3d65c7df429a84146480ab7df66c222fdda2f7a513da"></a>FmaInstructions</em>&nbsp;</td><td>
<p>Support for FMA instructions (3 operand variant) </p>
</td></tr>
</table>
</dd>
</dl>

</div>
</div>
<h2>Function Documentation</h2>
<a class="anchor" id="ga382d9c155a283ee6e0b6db203f563ed0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int Vc::extraInstructionsSupported </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines the extra instructions supported by the current CPU. </p>
<dl class="section return"><dt>Returns</dt><dd>A combination of flags from Vc::ExtraInstructions that the current CPU supports. </dd></dl>

</div>
</div>
<a class="anchor" id="ga85daae7f9fd2e0509b317bbaaade7d90"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Vc::isImplementationSupported </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__Utilities.html#ga9107acb389f0886054bea6298a73e191">Vc::Implementation</a>&#160;</td>
          <td class="paramname"><em>impl</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tests whether the given implementation is supported by the system the code is executing on. </p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the OS and hardware support execution of instructions defined by <code>impl</code>. </dd>
<dd>
<code>false</code> otherwise</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">impl</td><td>The SIMD target to test for. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga4bd9588ab59f9c0316f73c4de8b328a4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__Utilities.html#ga9107acb389f0886054bea6298a73e191">Vc::Implementation</a> Vc::bestImplementationSupported </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines the best supported implementation for the current system. </p>
<dl class="section return"><dt>Returns</dt><dd>The enum value for the best implementation. </dd></dl>

</div>
</div>
<a class="anchor" id="gaf6a7f1d58808117b81cac7dcd054895e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Vc::currentImplementationSupported </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tests that the CPU and Operating System support the vector unit which was compiled for. </p>
<p>This function should be called before any other <a class="el" href="namespaceVc.html" title="Vector Classes Namespace.">Vc</a> functionality is used. It checks whether the program will work. If this function returns <code>false</code> then the program should exit with a useful error message before the OS has to kill it because of an invalid instruction exception.</p>
<p>If the program continues and makes use of any vector features not supported by hard- or software then the program will crash.</p>
<p>Example: </p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> main()</div>
<div class="line">{</div>
<div class="line">  <span class="keywordflow">if</span> (!<a class="code" href="group__Utilities.html#gaf6a7f1d58808117b81cac7dcd054895e" title="Tests that the CPU and Operating System support the vector unit which was compiled for...">Vc::currentImplementationSupported</a>()) {</div>
<div class="line">    std::cerr &lt;&lt; <span class="stringliteral">&quot;CPU or OS requirements not met for the compiled in vector unit!\n&quot;</span>;</div>
<div class="line">    exit -1;</div>
<div class="line">  }</div>
<div class="line">  ...</div>
<div class="line">}</div>
</div><!-- fragment --><dl class="section return"><dt>Returns</dt><dd><code>true</code> if the OS and hardware support execution of the currently selected SIMD instructions. </dd>
<dd>
<code>false</code> otherwise </dd></dl>

</div>
</div>
<a class="anchor" id="gabfd2bbd2ca053de313afe500a540a1e1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Vc::forceToRegisters </td>
          <td>(</td>
          <td class="paramtype">const vec &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Force the vectors passed to the function into registers. </p>
<p>This can be useful after looking at the emitted assembly to force the compiler to optimize properly.</p>
<dl class="section note"><dt>Note</dt><dd>Currently only has an effect for SSE vectors. </dd>
<dd>
MSVC does not support this function at all.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Be careful with this function, especially since it can render the compiler unable to compile for 32 bit systems if it forces more than 8 vectors in registers. </dd></dl>

</div>
</div>
<a class="anchor" id="ga455ba5c796b6a7ea10b4637b5f91fd21"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classVc_1_1MemoryBase.html">Vc::MemoryBase</a>&lt; V, Parent, Dimension, RM &gt; &amp;&#160;</td>
          <td class="paramname"><em>m</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Prints the contents of a Memory object into a stream object. </p>
<div class="fragment"><div class="line"><a class="code" href="classVc_1_1Memory.html" title="A helper class for fixed-size two-dimensional arrays.">Vc::Memory&lt;int_v, 10&gt;</a> m;</div>
<div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; m.<a class="code" href="classVc_1_1Memory.html#ad3794ce9fa973092ec199c51f75d2806">entriesCount</a>(); ++i) {</div>
<div class="line">  m[i] = i;</div>
<div class="line">}</div>
<div class="line">std::cout &lt;&lt; m &lt;&lt; std::endl;</div>
</div><!-- fragment --><p> will output (with SSE): </p>
<pre class="fragment">{[0, 1, 2, 3] [4, 5, 6, 7] [8, 9, 0, 0]}
</pre><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>Any standard C++ ostream object. For example std::cout or a std::stringstream object. </td></tr>
    <tr><td class="paramname">m</td><td>Any <a class="el" href="classVc_1_1Memory.html" title="A helper class for fixed-size two-dimensional arrays.">Vc::Memory</a> object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The ostream object: to chain multiple stream operations.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>With the GNU standard library this function will check, whether the output stream is a tty. In that case it will colorize the output.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Please do not forget that printing a large memory object can take a long time. </dd></dl>

</div>
</div>
<a class="anchor" id="ga5f60d3eac127759ab0725a07a27d564a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* Vc::versionString </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the version string of the Vc headers.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>There exists a built-in check that ensures on application startup that the Vc version of the library (link time) and the headers (compile time) are equal. A mismatch between headers and library could lead to errors that are very hard to debug. </dd>
<dd>
If you need to disable the check (it costs a very small amount of application startup time) you can define VC_NO_VERSION_CHECK at compile time. </dd></dl>

</div>
</div>
<a class="anchor" id="ga0ff0ab27c63416b49278b0d00c5981f4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int Vc::versionNumber </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the version of the Vc headers encoded in an integer. </dd></dl>

</div>
</div>
<a class="anchor" id="ga3ad68314ae283bc298864bf18b3aa8a4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">T* Vc::malloc </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocates memory on the Heap with alignment and padding suitable for vectorized access. </p>
<p><a class="el" href="classVc_1_1Memory.html" title="A helper class for fixed-size two-dimensional arrays.">Memory</a> that was allocated with this function must be released with <a class="el" href="group__Utilities.html#gaee7f695ddd66d27230262733d9727435" title="Frees memory that was allocated with Vc::malloc.">Vc::free</a>! Other methods might work but are not portable.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>Specifies the number of objects the allocated memory must be able to store. </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type of the allocated memory. Note, that the constructor is not called. </td></tr>
    <tr><td class="paramname">A</td><td>Determines the alignment of the memory. See <a class="el" href="group__Utilities.html#gaebce8b3227fdcca97fba94556a1b2461">Vc::MallocAlignment</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to memory of the requested type, or 0 on error. The allocated memory is padded at the end to be a multiple of the requested alignment <code>A</code>. Thus if you request memory for 21 int objects, aligned via Vc::AlignOnCacheline, you can safely read a full cacheline until the end of the array, without generating an out-of-bounds access. For a cacheline size of 64 Bytes and an int size of 4 Bytes you would thus get an array of 128 Bytes to work with.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd><ul>
<li>The standard malloc function specifies the number of Bytes to allocate whereas this function specifies the number of values, thus differing in a factor of sizeof(T). </li>
<li>This function is mainly meant for use with builtin types. If you use a custom type with a sizeof that is not a multiple of 2 the results might not be what you expect. </li>
<li>The constructor of T is not called. You can make up for this: <div class="fragment"><div class="line">SomeType *array = <span class="keyword">new</span>(Vc::malloc&lt;SomeType, Vc::AlignOnCacheline&gt;(N)) SomeType[N];</div>
</div><!-- fragment --></li>
</ul>
</dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__Utilities.html#gaee7f695ddd66d27230262733d9727435" title="Frees memory that was allocated with Vc::malloc.">Vc::free</a> </dd></dl>

</div>
</div>
<a class="anchor" id="gaee7f695ddd66d27230262733d9727435"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Vc::free </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Frees memory that was allocated with <a class="el" href="group__Utilities.html#ga3ad68314ae283bc298864bf18b3aa8a4" title="Allocates memory on the Heap with alignment and padding suitable for vectorized access.">Vc::malloc</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>The pointer to the memory to be freed.</td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type of the allocated memory.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>The destructor of T is not called. If needed, you can call the destructor before calling free: <div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; N; ++i) {</div>
<div class="line">  p[i].~T();</div>
<div class="line">}</div>
<div class="line"><a class="code" href="group__Utilities.html#gaee7f695ddd66d27230262733d9727435" title="Frees memory that was allocated with Vc::malloc.">Vc::free</a>(p);</div>
</div><!-- fragment --></dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__Utilities.html#ga3ad68314ae283bc298864bf18b3aa8a4" title="Allocates memory on the Heap with alignment and padding suitable for vectorized access.">Vc::malloc</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga750e7279ea163a807f12ca559c86b8be"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Vc::prefetchForOneRead </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>addr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Prefetch the cacheline containing <code>addr</code> for a single read access. </p>
<p>This prefetch completely bypasses the cache, not evicting any other data.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">addr</td><td>The cacheline containing <code>addr</code> will be prefetched. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga66e169340ecf92fea214f0c11f2bada7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Vc::prefetchForModify </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>addr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Prefetch the cacheline containing <code>addr</code> for modification. </p>
<p>This prefetch evicts data from the cache. So use it only for data you really will use. When the target system supports it the cacheline will be marked as modified while prefetching, saving work later on.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">addr</td><td>The cacheline containing <code>addr</code> will be prefetched. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga251e2a042b8723d9a272e40730b775c4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Vc::prefetchClose </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>addr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Prefetch the cacheline containing <code>addr</code> to L1 cache. </p>
<p>This prefetch evicts data from the cache. So use it only for data you really will use.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">addr</td><td>The cacheline containing <code>addr</code> will be prefetched. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gabac2858df65bd48aad8268073c23a975"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Vc::prefetchMid </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>addr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Prefetch the cacheline containing <code>addr</code> to L2 cache. </p>
<p>This prefetch evicts data from the cache. So use it only for data you really will use.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">addr</td><td>The cacheline containing <code>addr</code> will be prefetched. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga7294a2e0deacbb4773f4f2d0722861c9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Vc::prefetchFar </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>addr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Prefetch the cacheline containing <code>addr</code> to L3 cache. </p>
<p>This prefetch evicts data from the cache. So use it only for data you really will use.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">addr</td><td>The cacheline containing <code>addr</code> will be prefetched. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.1.2 </li>
  </ul>
</div>
</body>
</html>
