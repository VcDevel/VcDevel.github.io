<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>Vc: Polar Coordinates</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() {
    if ($('.searchresults').length > 0) { searchBox.DOMSearchField().focus(); }
  });
</script>
<link rel="search" href="search-opensearch.php?v=opensearch.xml" type="application/opensearchdescription+xml" title="Vc"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo_small.png"/></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">Vc
   &#160;<span id="projectnumber">0.7.5-dev</span>
   </div>
   <div id="projectbrief">SIMD Vector Classes for C++</div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
          <div class="left">
            <form id="FSearchBox" action="search.php" method="get">
              <img id="MSearchSelect" src="search/mag.png" alt=""/>
              <input type="text" id="MSearchField" name="query" value="Search" size="20" accesskey="S" 
                     onfocus="searchBox.OnSearchFieldFocus(true)" 
                     onblur="searchBox.OnSearchFieldFocus(false)"/>
            </form>
          </div><div class="right"></div>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.1.2 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('ex-polarcoord.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="headertitle">
<div class="title">Polar Coordinates </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>The <code>polarcoord</code> example generates 1000 random Cartesian 2D coordinates that are then converted to polar coordinates and printed to the terminal.</p>
<p>This is a very simple example but shows the concept of vertical versus horizontal vectorization quite nicely.</p>
<h1><a class="anchor" id="ex_polarcoord_background"></a>
Background</h1>
<p>In our problem we start with the allocation and random initialization of 1000 Cartesian 2D coordinates. Thus every coordinate consists of two floating-point values (x and y). </p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>CartesianCoordinate</div>
<div class="line">{</div>
<div class="line">  <span class="keywordtype">float</span> x, y;</div>
<div class="line">};</div>
<div class="line">CartesianCoordinate input[1000];</div>
</div><!-- fragment --> <div class="image">
<img src="polarcoord-cartesian.png" alt="polarcoord-cartesian.png"/>
<div class="caption">
Cartesian coordinate</div></div>
<p> We want to convert them to 1000 polar coordinates. </p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>PolarCoordinate</div>
<div class="line">{</div>
<div class="line">  <span class="keywordtype">float</span> r, phi;</div>
<div class="line">};</div>
<div class="line">PolarCoordinate output[1000];</div>
</div><!-- fragment --> <div class="image">
<img src="polarcoord-polar.png" alt="polarcoord-polar.png"/>
<div class="caption">
Polar coordinate</div></div>
<p> Recall that: </p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ r^2 = x^2 + y^2 \]" src="form_0.png"/>
</p>
 <p class="formulaDsp">
<img class="formulaDsp" alt="\[ \tan\phi = y/x \]" src="form_1.png"/>
</p>
<p> (One typically uses <code>atan2</code> to calculate <code>phi</code> efficiently.)</p>
<h1><a class="anchor" id="ex_polarcoord_vectorization"></a>
Identify Vectorizable Parts</h1>
<p>When you look into vectorization of your application/algorithm, the first task is to identify the data parallelism to use for vectorization. A scalar implementation of our problem could look like this: </p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; ArraySize; ++i) {</div>
<div class="line">  <span class="keyword">const</span> <span class="keywordtype">float</span> x = input[i].x;</div>
<div class="line">  <span class="keyword">const</span> <span class="keywordtype">float</span> y = input[i].y;</div>
<div class="line">  output[i].r = <a class="code" href="group__Math.html#ga68be745cb2c851120683a05c252bea7b" title="Returns the square root of v.">std::sqrt</a>(x * x + y * y);</div>
<div class="line">  output[i].phi = <a class="code" href="group__Math.html#ga6a4a05a0f3ec225d2596dd612ec4f2e4" title="Returns the arctangent of x / y.">std::atan2</a>(y, x) * 57.295780181884765625f; <span class="comment">// 180/pi</span></div>
<div class="line">  <span class="keywordflow">if</span> (output[i].phi &lt; 0.f) {</div>
<div class="line">    output[i].phi += 360.f;</div>
<div class="line">  }</div>
<div class="line">}</div>
</div><!-- fragment --><p> The data parallelism inside the loop is minimal. It basically consists of two multiplications that can be executed in parallel. This kind of parallelism is already exploited by all modern processors via pipelining, which is one form of instruction level parallelism (ILP). Thus, if one were to put the x and y values into a SIMD vector, this one multiplication could be executed with just a single SIMD instruction. This vectorization is called <em>vertical</em> vectorization, because the vector is placed vertically into the object.</p>
<p>There is much more data parallelism in this code snippet, though. The different iteration steps are all independent, which means that subsequent steps do not depend on results of the preceding steps. Therefore, several steps of the loop can be executed in parallel. This is the most straightforward vectorization strategy for our problem: From a loop, always execute N steps in parallel, where N is the number of entries in the SIMD vector. The input values to the loop need to be placed into a vector. Then all intermediate values and results are also vectors. Using the Vc datatypes a single loop step would then look like this: </p>
<div class="fragment"><div class="line"><span class="comment">// x and y are of type float_v</span></div>
<div class="line">float_v r = <a class="code" href="group__Math.html#ga68be745cb2c851120683a05c252bea7b" title="Returns the square root of v.">Vc::sqrt</a>(x * x + y * y);</div>
<div class="line">float_v phi = <a class="code" href="group__Math.html#ga6a4a05a0f3ec225d2596dd612ec4f2e4" title="Returns the arctangent of x / y.">Vc::atan2</a>(y, x) * 57.295780181884765625f; <span class="comment">// 180/pi</span></div>
<div class="line">phi(output[i].phi &lt; 0.f) += 360.f;</div>
</div><!-- fragment --><p> This vectorization is called <em>horizontal</em> vectorization, because the vector is placed horizontally over several objects.</p>
<h1><a class="anchor" id="ex_polarcoord_data"></a>
Data Structures</h1>
<p>To form the <code>x</code> vector from the previously used storage format, one would thus write: </p>
<div class="fragment"><div class="line">float_v x;</div>
<div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; float_v::Size; ++i) {</div>
<div class="line">  x[i] = input[offset + i].x;</div>
<div class="line">}</div>
</div><!-- fragment --><p> Notice how the memory access is rather inefficient.</p>
<h2><a class="anchor" id="ex_polarcoord_data_aos"></a>
Array of Structs (AoS)</h2>
<p>The data was originally stored as array of structs (<em>AoS</em>). Another way to call it is <em>interleaved</em> storage. That's because the entries of the <code>x</code> and <code>y</code> vectors are interleaved in memory. Let us assume the storage format is given and we cannot change it. We would rather not load and store all our vectors entry by entry as this would lead to inefficient code, which mainly occupies the load/store ports of the processor. Instead, we can use a little helper function Vc provides to load the data as vectors with subsequent deinterleaving: </p>
<div class="fragment"><div class="line"><a class="code" href="classVc_1_1float__v.html" title="SIMD Vector of single precision floats.">Vc::float_v</a> x, y;</div>
<div class="line"><a class="code" href="group__Vectors.html#ga3b78255a0fcbb76664c20b56ffe85d77">Vc::deinterleave</a>(&amp;x, &amp;y, &amp;input[i], <a class="code" href="group__Vectors.html#gga9157aa15b51290e8511edf1e7172513bad5380ca00f3d74b38593adf8a0d06d3e" title="Tells Vc that the load/store can expect a memory address that is aligned on the correct boundary...">Vc::Aligned</a>);</div>
</div><!-- fragment --><p> This pattern can be very efficient if the interleaved data members are always accessed together. This optimizes for data locality and thus cache usage.</p>
<h2><a class="anchor" id="ex_polarcoord_data_vectors"></a>
Interleaved Vectors</h2>
<p>If you can change the data structures, it might be a good option to store interleaved vectors: </p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>CartesianCoordinate</div>
<div class="line">{</div>
<div class="line">  <a class="code" href="classVc_1_1float__v.html" title="SIMD Vector of single precision floats.">Vc::float_v</a> x, y;</div>
<div class="line">};</div>
<div class="line">CartesianCoordinate input[(1000 + <a class="code" href="classVc_1_1float__v.html#adf764cbdea00d65edcd07bb9953ad2b7aff9abf2b1a689f70a77a18da50c01d9f" title="The size of the vector.">Vc::float_v::Size</a> - 1) / <a class="code" href="classVc_1_1float__v.html#adf764cbdea00d65edcd07bb9953ad2b7aff9abf2b1a689f70a77a18da50c01d9f" title="The size of the vector.">Vc::float_v::Size</a>];</div>
</div><!-- fragment --><p> Accessing vectors of <code>x</code> and <code>y</code> is then as simple as accessing the members of a <code>CartesianCoordinate</code> object. This can be slightly more efficient than the previous method because the deinterleaving step is not required anymore. On the downside your data structure now depends on the target architecture, which can be a portability concern. In short, the <code>sizeof</code> operator returns different values depending on <a class="el" href="classVc_1_1float__v.html#adf764cbdea00d65edcd07bb9953ad2b7aff9abf2b1a689f70a77a18da50c01d9f" title="The size of the vector.">Vc::float_v::Size</a>. Thus, you would have to ensure correct conversion to target independent data formats for any data exchange (storage, network). (But if you are really careful about portable data exchange, you already have to handle endian conversion anyway.)</p>
<p>Note the unfortunate complication of determining the size of the array. In order to fit 1000 scalar values into the array, the number of vectors times the vector size must be greater or equal than 1000. But integer division truncates.</p>
<p>Sadly, there is one last issue with alignment. If the <code>CartesianCoordinate</code> object is allocated on the stack everything is fine (because the compiler knows about the alignment restrictions of <code>x</code> and <code>y</code> and thus of <code>CartesianCoordinate</code>). But if <code>CartesianCoordinate</code> is allocated on the heap (with <code>new</code> or inside an STL container), the correct alignment is not ensured. Vc provides <a class="el" href="classVc_1_1VectorAlignedBase.html" title="Helper class to ensure proper alignment.">Vc::VectorAlignedBase</a>, which contains the correct reimplementations of the <code>new</code> and <code>delete</code> operators: </p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>CartesianCoordinate : <span class="keyword">public</span> <a class="code" href="classVc_1_1VectorAlignedBase.html" title="Helper class to ensure proper alignment.">Vc::VectorAlignedBase</a></div>
<div class="line">{</div>
<div class="line">  <a class="code" href="classVc_1_1float__v.html" title="SIMD Vector of single precision floats.">Vc::float_v</a> x, y;</div>
<div class="line">}</div>
<div class="line">CartesianCoordinate *input = <span class="keyword">new</span> CartesianCoordinate[(1000 + <a class="code" href="classVc_1_1float__v.html#adf764cbdea00d65edcd07bb9953ad2b7aff9abf2b1a689f70a77a18da50c01d9f" title="The size of the vector.">Vc::float_v::Size</a> - 1) / <a class="code" href="classVc_1_1float__v.html#adf764cbdea00d65edcd07bb9953ad2b7aff9abf2b1a689f70a77a18da50c01d9f" title="The size of the vector.">Vc::float_v::Size</a>];</div>
</div><!-- fragment --><p> To ensure correctly aligned storage with STL containers you can use <a class="el" href="classVc_1_1Allocator.html" title="An allocator that uses global new and supports over-aligned types, as per [C++11 20.6.9].">Vc::Allocator</a>: </p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>CartesianCoordinate</div>
<div class="line">{</div>
<div class="line">  <a class="code" href="classVc_1_1float__v.html" title="SIMD Vector of single precision floats.">Vc::float_v</a> x, y;</div>
<div class="line">}</div>
<div class="line"><a class="code" href="group__Utilities.html#ga0d6b1a2931c3ae6e7897f6f2ebe737ee" title="Convenience macro to set the default allocator for a given Type to Vc::Allocator.">VC_DECLARE_ALLOCATOR</a>(CartesianCoordinate)</div>
<div class="line">std::vector&lt;CartesianCoordinate&gt; input((1000 + Vc::float_v::Size - 1) / Vc::float_v::Size);</div>
</div><!-- fragment --><p>For a thorough discussion of alignment see <a class="el" href="intro.html#intro_alignment">Alignment</a>.</p>
<h2><a class="anchor" id="ex_polarcoord_data_soa"></a>
Struct of Arrays (SoA)</h2>
<p>A third option is storage in the form of a single struct instance that contains arrays of the data members: </p>
<div class="fragment"><div class="line"><span class="keyword">template</span>&lt;<span class="keywordtype">size_t</span> Size&gt; <span class="keyword">struct </span>CartesianCoordinate</div>
<div class="line">{</div>
<div class="line">  <span class="keywordtype">float</span> x[Size], y[Size];</div>
<div class="line">}</div>
<div class="line">CartesianCoordinate&lt;1000&gt; input;</div>
</div><!-- fragment --><p> Now all <code>x</code> values are adjacent in memory and thus can easily be loaded and stored as vectors. Well, two problems remain: 1. The alignment of <code>x</code> and <code>y</code> is not defined and therefore not guaranteed. Vector loads and stores thus must assume unaligned pointers, which is bad for performance. Even worse, if an instruction that expects an aligned pointer is executed with an unaligned address the program will crash. 2. The size of the <code>x</code> and <code>y</code> arrays is not guaranteed to be large enough to allow the last values in the arrays to be loaded/stored as vectors.</p>
<p>Vc provides the <a class="el" href="classVc_1_1Memory.html" title="A helper class for fixed-size two-dimensional arrays.">Vc::Memory</a> class to solve both issues: </p>
<div class="fragment"><div class="line"><span class="keyword">template</span>&lt;<span class="keywordtype">size_t</span> Size&gt; <span class="keyword">struct </span>CartesianCoordinate</div>
<div class="line">{</div>
<div class="line">  <a class="code" href="classVc_1_1Memory.html" title="A helper class for fixed-size two-dimensional arrays.">Vc::Memory&lt;float_v, Size&gt;</a> x, y;</div>
<div class="line">}</div>
<div class="line">CartesianCoordinate&lt;1000&gt; input;</div>
</div><!-- fragment --><h1><a class="anchor" id="ex_polarcoord_complete"></a>
The Complete Example</h1>
<p>Now that we have covered the background and know what we need - let us take a look at the complete example code.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;Vc/Vc&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;iomanip&gt;</span></div>
<div class="line"></div>
<div class="line"><span class="keyword">using</span> <a class="code" href="classVc_1_1float__v.html" title="SIMD Vector of single precision floats.">Vc::float_v</a>;</div>
</div><!-- fragment --><p>The example starts with the main include directive to use for Vc: <code>#include</code> <code>&lt;Vc/Vc&gt;</code>. The remaining includes are required for terminal output. Note that we include <a class="el" href="classVc_1_1float__v.html" title="SIMD Vector of single precision floats.">Vc::float_v</a> into the global namespace. It is not recommended to include the whole Vc namespace into the global namespace except maybe inside a function scope.</p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> main()</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// allocate memory for our initial x and y coordinates. Note that you can also put it into a</span></div>
<div class="line">    <span class="comment">// normal float C-array but that you then must ensure alignment to Vc::VectorAlignment!</span></div>
<div class="line">    <a class="code" href="classVc_1_1Memory.html" title="A helper class for fixed-size two-dimensional arrays.">Vc::Memory&lt;float_v, 1000&gt;</a> x_mem;</div>
<div class="line">    <a class="code" href="classVc_1_1Memory.html" title="A helper class for fixed-size two-dimensional arrays.">Vc::Memory&lt;float_v, 1000&gt;</a> y_mem;</div>
<div class="line">    <a class="code" href="classVc_1_1Memory.html" title="A helper class for fixed-size two-dimensional arrays.">Vc::Memory&lt;float_v, 1000&gt;</a> r_mem;</div>
<div class="line">    <a class="code" href="classVc_1_1Memory.html" title="A helper class for fixed-size two-dimensional arrays.">Vc::Memory&lt;float_v, 1000&gt;</a> phi_mem;</div>
</div><!-- fragment --><p>At the start of the program, the input and output memory is allocated. Of course, you can abstract these variables into structs/classes for Cartesian and polar coordinates. The <a class="el" href="classVc_1_1Memory.html" title="A helper class for fixed-size two-dimensional arrays.">Vc::Memory</a> class can be used to allocate memory on the stack or on the heap. In this case the memory is allocated on the stack, since the size of the memory is given at compile time. The first <code>float</code> value of <a class="el" href="classVc_1_1Memory.html" title="A helper class for fixed-size two-dimensional arrays.">Vc::Memory</a> (e.g. x_mem[0]) is guaranteed to be aligned to the natural SIMD vector alignment. Also, the size of the allocated memory may be padded at the end to allow access to the last <code>float</code> value (e.g. x_mem[999]) with a SIMD vector. Thus, if this example is compiled for a target with a vector width (<code><a class="el" href="classVc_1_1float__v.html#adf764cbdea00d65edcd07bb9953ad2b7aff9abf2b1a689f70a77a18da50c01d9f" title="The size of the vector.">Vc::float_v::Size</a></code>) of 16 entries, the four arrays would internally be allocated as size 1008 (63 vectors with 16 entries = 1008 entries).</p>
<div class="fragment"><div class="line">    <span class="comment">// fill the memory with values from -1.f to 1.f</span></div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; x_mem.<a class="code" href="classVc_1_1Memory.html#a829bc7313783d55ab26c689c05033c27">vectorsCount</a>(); ++i) {</div>
<div class="line">        x_mem.<a class="code" href="classVc_1_1MemoryBase.html#a1d35d22f3851bdf4ba5edebdd883db64">vector</a>(i) = float_v::Random() * 2.f - 1.f;</div>
<div class="line">        y_mem.<a class="code" href="classVc_1_1MemoryBase.html#a1d35d22f3851bdf4ba5edebdd883db64">vector</a>(i) = float_v::Random() * 2.f - 1.f;</div>
<div class="line">    }</div>
</div><!-- fragment --><p>Next the x and y values are initialized with random numbers. Vc includes a simple vectorized random number generator. The floating point RNGs in Vc produce values in the range from 0 to 1. Thus the value has to be scaled and subtracted to get into the desired range of -1 to 1. The iteration over the memory goes from 0 (no surprise) to a value determined by the <a class="el" href="classVc_1_1Memory.html" title="A helper class for fixed-size two-dimensional arrays.">Vc::Memory</a> class. In the case of fixed-size allocation, this number is also available to the compiler as a compile time constant. <a class="el" href="classVc_1_1Memory.html" title="A helper class for fixed-size two-dimensional arrays.">Vc::Memory</a> has two functions to use as upper bound for iterations: <a class="el" href="classVc_1_1Memory.html#ad3794ce9fa973092ec199c51f75d2806">Vc::Memory::entriesCount</a> and <a class="el" href="classVc_1_1Memory.html#a829bc7313783d55ab26c689c05033c27">Vc::Memory::vectorsCount</a>. The former returns the same number as was used for allocation. The latter returns the number of SIMD vectors that fit into the (padded) allocated memory. Thus, if <a class="el" href="classVc_1_1float__v.html#adf764cbdea00d65edcd07bb9953ad2b7aff9abf2b1a689f70a77a18da50c01d9f" title="The size of the vector.">Vc::float_v::Size</a> were 16, <code>x_mem.vectorsCount()</code> would expand to 63. Inside the loop, the memory i-th vector is then set to a random value.</p>
<dl class="section warning"><dt>Warning</dt><dd>Please do not use this RNG until you have read its documentation. It may not be as random as you need it to be.</dd></dl>
<div class="fragment"><div class="line">    <span class="comment">// calculate the polar coordinates for all coordinates and overwrite the euclidian coordinates</span></div>
<div class="line">    <span class="comment">// with the result</span></div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; x_mem.<a class="code" href="classVc_1_1Memory.html#a829bc7313783d55ab26c689c05033c27">vectorsCount</a>(); ++i) {</div>
<div class="line">        <span class="keyword">const</span> float_v x = x_mem.<a class="code" href="classVc_1_1MemoryBase.html#a1d35d22f3851bdf4ba5edebdd883db64">vector</a>(i);</div>
<div class="line">        <span class="keyword">const</span> float_v y = y_mem.<a class="code" href="classVc_1_1MemoryBase.html#a1d35d22f3851bdf4ba5edebdd883db64">vector</a>(i);</div>
<div class="line"></div>
<div class="line">        r_mem.<a class="code" href="classVc_1_1MemoryBase.html#a1d35d22f3851bdf4ba5edebdd883db64">vector</a>(i) = <a class="code" href="group__Math.html#ga68be745cb2c851120683a05c252bea7b" title="Returns the square root of v.">Vc::sqrt</a>(x * x + y * y);</div>
<div class="line">        float_v phi = <a class="code" href="group__Math.html#ga6a4a05a0f3ec225d2596dd612ec4f2e4" title="Returns the arctangent of x / y.">Vc::atan2</a>(y, x) * 57.295780181884765625f; <span class="comment">// 180/pi</span></div>
<div class="line">        phi(phi &lt; 0.f) += 360.f;</div>
<div class="line">        phi_mem.<a class="code" href="classVc_1_1MemoryBase.html#a1d35d22f3851bdf4ba5edebdd883db64">vector</a>(i) = phi;</div>
<div class="line">    }</div>
</div><!-- fragment --><p>Finally we arrive at the conversion of the Cartesian coordinates to polar coordinates. The for loop is equivalent to the one above.</p>
<p>Inside the loop we first assign the x and y values to local variables. This is not necessary; but it can help the compiler with optimization. The issue is that when you access values from some memory area, the compiler cannot always be sure that the pointers to memory do not alias (i.e. point to the same location). Thus, the compiler might rather take the safe way out and load the value from memory more often than necessary. By using local variables, the compiler has an easy task to prove that the value does not change and can be cached in a register. This is a general issue, and not a special issue with SIMD. In this case mainly serves to make the following code more readable.</p>
<div class="fragment"><div class="line">    <span class="comment">// print the results</span></div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; x_mem.<a class="code" href="classVc_1_1Memory.html#ad3794ce9fa973092ec199c51f75d2806">entriesCount</a>(); ++i) {</div>
<div class="line">        std::cout &lt;&lt; std::setw(3) &lt;&lt; i &lt;&lt; <span class="stringliteral">&quot;: &quot;</span>;</div>
<div class="line">        std::cout &lt;&lt; std::setw(10) &lt;&lt; x_mem[i] &lt;&lt; <span class="stringliteral">&quot;, &quot;</span> &lt;&lt; std::setw(10) &lt;&lt; y_mem[i] &lt;&lt; <span class="stringliteral">&quot; -&gt; &quot;</span>;</div>
<div class="line">        std::cout &lt;&lt; std::setw(10) &lt;&lt; r_mem[i] &lt;&lt; <span class="stringliteral">&quot;, &quot;</span> &lt;&lt; std::setw(10) &lt;&lt; phi_mem[i] &lt;&lt; <span class="charliteral">&#39;\n&#39;</span>;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
</div><!-- fragment --></div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.1.2 </li>
  </ul>
</div>
</body>
</html>
