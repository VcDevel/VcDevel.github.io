<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.9.1"/>
<title>Vc: SIMD Array</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() {
    if ($('.searchresults').length > 0) { searchBox.DOMSearchField().focus(); }
  });
</script>
<link rel="search" href="search_opensearch.php?v=opensearch.xml" type="application/opensearchdescription+xml" title="Vc"/>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo_small.png"/></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">Vc
   &#160;<span id="projectnumber">1.2.0</span>
   </div>
   <div id="projectbrief">SIMD Vector Classes for C++</div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
          <div class="left">
            <form id="FSearchBox" action="search.php" method="get">
              <img id="MSearchSelect" src="search/mag.png" alt=""/>
              <input type="text" id="MSearchField" name="query" value="Search" size="20" accesskey="S" 
                     onfocus="searchBox.OnSearchFieldFocus(true)" 
                     onblur="searchBox.OnSearchFieldFocus(false)"/>
            </form>
          </div><div class="right"></div>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.9.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('group__SimdArray.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">SIMD Array</div>  </div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>This set of class templates and associated functions and operators enables data-parallel algorithms and data structures requiring a user-defined number of elements (fixed at compile time, in contrast to <code>std::valarray</code> where the number of elements is only determined at run time). The main motivation for a user-defined number of elements is the need for type conversion and thus a guaranteed equal number of elements in data-parallel vectors for e.g. <code>float</code> and <code>int</code>. A typical pattern looks like this: </p><div class="fragment"><div class="line"><span class="keyword">using</span> floatv = <a class="code" href="group__Vectors.html#ga5cf7c5a0dadbbbbcb9b69c5e42ee0528">Vc::float_v</a>;</div>
<div class="line"><span class="keyword">using</span> doublev = <a class="code" href="classVc_1_1SimdArray.html">Vc::SimdArray&lt;double, floatv::size()&gt;</a>;</div>
<div class="line"><span class="keyword">using</span> intv = <a class="code" href="classVc_1_1SimdArray.html">Vc::SimdArray&lt;int, floatv::size()&gt;</a>;</div>
<div class="line"><span class="keyword">using</span> uintv = <a class="code" href="classVc_1_1SimdArray.html">Vc::SimdArray&lt;unsigned int, floatv::size()&gt;</a>;</div>
</div><!-- fragment --><p>The second motivation for a user-defined number of elements is that many vertical vectorizations require a fixed number of elements (i.e. number known at development time and not chosen at compile time). The implementation can then choose how to support this number most efficiently with the available hardware resources. Consider, for example, a need for processing 12 values in parallel. On x86 with AVX, the implementation could build such a type from one AVX and one SSE register.</p>
<p>In contrast to <code>std::array</code> the types behave like the <a class="el" href="classVc_1_1Vector.html" title="The main vector class for expressing data parallelism. ">Vc::Vector</a> types, implementing the same operators and functions. The semantics with regard to implicit conversions differ slightly: The <a class="el" href="classVc_1_1Vector.html" title="The main vector class for expressing data parallelism. ">Vc::Vector</a> conversion rules are safer with regard to source compatibility. The <a class="el" href="classVc_1_1SimdArray.html" title="Data-parallel arithmetic type with user-defined number of elements. ">Vc::SimdArray</a> conversion rules are less strict and could potentially lead to portability issues. Therefore, it is best to stick to the pattern of type aliases shown above. </p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVc_1_1SimdArray.html">SimdArray&lt; T, N, V, Wt &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Data-parallel arithmetic type with user-defined number of elements.  <a href="classVc_1_1SimdArray.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVc_1_1SimdMaskArray.html">SimdMaskArray&lt; T, N, V, Wt &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Data-parallel mask type with user-defined number of boolean elements.  <a href="classVc_1_1SimdMaskArray.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:gaac286912729d28478c8c9a1ac97a92ac"><td class="memItemLeft" align="right" valign="top">static constexpr std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__SimdArray.html#gaac286912729d28478c8c9a1ac97a92ac">MemoryAlignment</a></td></tr>
<tr class="memdesc:gaac286912729d28478c8c9a1ac97a92ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specifies the alignment requirement for aligned load and store calls for objects of this vector type.  <a href="#gaac286912729d28478c8c9a1ac97a92ac">More...</a><br /></td></tr>
<tr class="separator:gaac286912729d28478c8c9a1ac97a92ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad550c4cd366024e9b37c4a7c7c9b96ff"><td class="memItemLeft" align="right" valign="top">static constexpr std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__SimdArray.html#gad550c4cd366024e9b37c4a7c7c9b96ff">Size</a> = size()</td></tr>
<tr class="memdesc:gad550c4cd366024e9b37c4a7c7c9b96ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of boolean components ( \(\mathcal{W}_\mathtt{T}\)) in a mask of this type.  <a href="#gad550c4cd366024e9b37c4a7c7c9b96ff">More...</a><br /></td></tr>
<tr class="separator:gad550c4cd366024e9b37c4a7c7c9b96ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaac286912729d28478c8c9a1ac97a92ac"><td class="memItemLeft" align="right" valign="top">static constexpr std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__SimdArray.html#gaac286912729d28478c8c9a1ac97a92ac">MemoryAlignment</a></td></tr>
<tr class="memdesc:gaac286912729d28478c8c9a1ac97a92ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specifies the alignment requirement for aligned load and store calls for objects of this mask type.  <a href="#gaac286912729d28478c8c9a1ac97a92ac">More...</a><br /></td></tr>
<tr class="separator:gaac286912729d28478c8c9a1ac97a92ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Arithmetic and Bitwise Operators</h2></td></tr>
<tr><td class="ititle" colspan="2"><p><a class="anchor" id="amgrp639d18286cf4aa387e43ef9e253fe1cc"></a>Applies the operator component-wise and concurrently on <code>lhs</code> and <code>rhs</code> and returns a new <a class="el" href="classVc_1_1SimdArray.html" title="Data-parallel arithmetic type with user-defined number of elements. ">SimdArray</a> object containing the result values.</p>
<p>This operator only participates in overload resolution if: </p><ul>
<li>At least one of the template parameters <code>L</code> or <code>R</code> is a <a class="el" href="classVc_1_1SimdArray.html" title="Data-parallel arithmetic type with user-defined number of elements. ">SimdArray</a> type. </li>
<li>Either <code>L</code> or <code>R</code> is a fundamental arithmetic type but not an integral type larger than <code>int</code> <br />
 or <br />
 <code>L</code> or <code>R</code> is a <a class="el" href="classVc_1_1Vector.html" title="The main vector class for expressing data parallelism. ">Vc::Vector</a> type with equal number of elements (<a class="el" href="classVc_1_1Vector.html#a1b5d7e2e663d7997796fd9f72b8af75a" title="Returns the number of scalar components ( ) in a vector of this type. ">Vector::size()</a> == <a class="el" href="classVc_1_1SimdArray.html#a5e99fb015bfbc024a4b785135b34dee7" title="Returns N, the number of scalar components in an object of this type. ">SimdArray::size()</a>).</li>
</ul>
<p>The return type of the operator is a <a class="el" href="classVc_1_1SimdArray.html" title="Data-parallel arithmetic type with user-defined number of elements. ">SimdArray</a> type using the more precise EntryType of <code>L</code> or <code>R</code> and the same number of elements as the <a class="el" href="classVc_1_1SimdArray.html" title="Data-parallel arithmetic type with user-defined number of elements. ">SimdArray</a> argument(s). </p>
</td></tr>
<tr class="memitem:ga44ad1a978cb7403c99e30a9603c3cbf8"><td class="memTemplParams" colspan="2"><a class="anchor" id="ga44ad1a978cb7403c99e30a9603c3cbf8"></a>
template&lt;typename L , typename R &gt; </td></tr>
<tr class="memitem:ga44ad1a978cb7403c99e30a9603c3cbf8"><td class="memTemplItemLeft" align="right" valign="top">result_vector_type&lt; L, R &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__SimdArray.html#ga44ad1a978cb7403c99e30a9603c3cbf8">operator+</a> (L &amp;&amp;lhs, R &amp;&amp;rhs)</td></tr>
<tr class="memdesc:ga44ad1a978cb7403c99e30a9603c3cbf8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies + component-wise and concurrently. <br /></td></tr>
<tr class="separator:ga44ad1a978cb7403c99e30a9603c3cbf8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac21a224a42178602234ea9e4a5a25c29"><td class="memTemplParams" colspan="2"><a class="anchor" id="gac21a224a42178602234ea9e4a5a25c29"></a>
template&lt;typename L , typename R &gt; </td></tr>
<tr class="memitem:gac21a224a42178602234ea9e4a5a25c29"><td class="memTemplItemLeft" align="right" valign="top">result_vector_type&lt; L, R &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__SimdArray.html#gac21a224a42178602234ea9e4a5a25c29">operator-</a> (L &amp;&amp;lhs, R &amp;&amp;rhs)</td></tr>
<tr class="memdesc:gac21a224a42178602234ea9e4a5a25c29"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies - component-wise and concurrently. <br /></td></tr>
<tr class="separator:gac21a224a42178602234ea9e4a5a25c29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf9fd9ddfee22a39aba4aff656c991392"><td class="memTemplParams" colspan="2"><a class="anchor" id="gaf9fd9ddfee22a39aba4aff656c991392"></a>
template&lt;typename L , typename R &gt; </td></tr>
<tr class="memitem:gaf9fd9ddfee22a39aba4aff656c991392"><td class="memTemplItemLeft" align="right" valign="top">result_vector_type&lt; L, R &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__SimdArray.html#gaf9fd9ddfee22a39aba4aff656c991392">operator*</a> (L &amp;&amp;lhs, R &amp;&amp;rhs)</td></tr>
<tr class="memdesc:gaf9fd9ddfee22a39aba4aff656c991392"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies * component-wise and concurrently. <br /></td></tr>
<tr class="separator:gaf9fd9ddfee22a39aba4aff656c991392"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7e6b9b75b0e360dd2870a97eea1ce584"><td class="memTemplParams" colspan="2"><a class="anchor" id="ga7e6b9b75b0e360dd2870a97eea1ce584"></a>
template&lt;typename L , typename R &gt; </td></tr>
<tr class="memitem:ga7e6b9b75b0e360dd2870a97eea1ce584"><td class="memTemplItemLeft" align="right" valign="top">result_vector_type&lt; L, R &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__SimdArray.html#ga7e6b9b75b0e360dd2870a97eea1ce584">operator/</a> (L &amp;&amp;lhs, R &amp;&amp;rhs)</td></tr>
<tr class="memdesc:ga7e6b9b75b0e360dd2870a97eea1ce584"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies / component-wise and concurrently. <br /></td></tr>
<tr class="separator:ga7e6b9b75b0e360dd2870a97eea1ce584"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa381024280b357bc45ac5c3393fc0022"><td class="memTemplParams" colspan="2"><a class="anchor" id="gaa381024280b357bc45ac5c3393fc0022"></a>
template&lt;typename L , typename R &gt; </td></tr>
<tr class="memitem:gaa381024280b357bc45ac5c3393fc0022"><td class="memTemplItemLeft" align="right" valign="top">result_vector_type&lt; L, R &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__SimdArray.html#gaa381024280b357bc45ac5c3393fc0022">operator%</a> (L &amp;&amp;lhs, R &amp;&amp;rhs)</td></tr>
<tr class="memdesc:gaa381024280b357bc45ac5c3393fc0022"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies % component-wise and concurrently. <br /></td></tr>
<tr class="separator:gaa381024280b357bc45ac5c3393fc0022"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1edb0cad0c29ca82c58bf9325d3ee12a"><td class="memTemplParams" colspan="2"><a class="anchor" id="ga1edb0cad0c29ca82c58bf9325d3ee12a"></a>
template&lt;typename L , typename R &gt; </td></tr>
<tr class="memitem:ga1edb0cad0c29ca82c58bf9325d3ee12a"><td class="memTemplItemLeft" align="right" valign="top">result_vector_type&lt; L, R &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__SimdArray.html#ga1edb0cad0c29ca82c58bf9325d3ee12a">operator|</a> (L &amp;&amp;lhs, R &amp;&amp;rhs)</td></tr>
<tr class="memdesc:ga1edb0cad0c29ca82c58bf9325d3ee12a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies | component-wise and concurrently. <br /></td></tr>
<tr class="separator:ga1edb0cad0c29ca82c58bf9325d3ee12a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa73cd786e8a21b6bbcf1f31aec7e1a1f"><td class="memTemplParams" colspan="2"><a class="anchor" id="gaa73cd786e8a21b6bbcf1f31aec7e1a1f"></a>
template&lt;typename L , typename R &gt; </td></tr>
<tr class="memitem:gaa73cd786e8a21b6bbcf1f31aec7e1a1f"><td class="memTemplItemLeft" align="right" valign="top">result_vector_type&lt; L, R &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__SimdArray.html#gaa73cd786e8a21b6bbcf1f31aec7e1a1f">operator&amp;</a> (L &amp;&amp;lhs, R &amp;&amp;rhs)</td></tr>
<tr class="memdesc:gaa73cd786e8a21b6bbcf1f31aec7e1a1f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies &amp; component-wise and concurrently. <br /></td></tr>
<tr class="separator:gaa73cd786e8a21b6bbcf1f31aec7e1a1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaff5b099251465e654b1823ffbf79f631"><td class="memTemplParams" colspan="2"><a class="anchor" id="gaff5b099251465e654b1823ffbf79f631"></a>
template&lt;typename L , typename R &gt; </td></tr>
<tr class="memitem:gaff5b099251465e654b1823ffbf79f631"><td class="memTemplItemLeft" align="right" valign="top">result_vector_type&lt; L, R &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__SimdArray.html#gaff5b099251465e654b1823ffbf79f631">operator^</a> (L &amp;&amp;lhs, R &amp;&amp;rhs)</td></tr>
<tr class="memdesc:gaff5b099251465e654b1823ffbf79f631"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies ^ component-wise and concurrently. <br /></td></tr>
<tr class="separator:gaff5b099251465e654b1823ffbf79f631"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Compare Operators</h2></td></tr>
<tr><td class="ititle" colspan="2"><p><a class="anchor" id="amgrp2a9ef827f281fe598e520d48579285c2"></a>Applies the operator component-wise and concurrently on <code>lhs</code> and <code>rhs</code> and returns a new <a class="el" href="classVc_1_1SimdMaskArray.html" title="Data-parallel mask type with user-defined number of boolean elements. ">SimdMaskArray</a> object containing the result values.</p>
<p>This operator only participates in overload resolution if (same rules as above): </p><ul>
<li>At least one of the template parameters <code>L</code> or <code>R</code> is a <a class="el" href="classVc_1_1SimdArray.html" title="Data-parallel arithmetic type with user-defined number of elements. ">SimdArray</a> type. </li>
<li>Either <code>L</code> or <code>R</code> is a fundamental arithmetic type but not an integral type larger than <code>int</code> <br />
 or <br />
 <code>L</code> or <code>R</code> is a <a class="el" href="classVc_1_1Vector.html" title="The main vector class for expressing data parallelism. ">Vc::Vector</a> type with equal number of elements (<a class="el" href="classVc_1_1Vector.html#a1b5d7e2e663d7997796fd9f72b8af75a" title="Returns the number of scalar components ( ) in a vector of this type. ">Vector::size()</a> == <a class="el" href="classVc_1_1SimdArray.html#a5e99fb015bfbc024a4b785135b34dee7" title="Returns N, the number of scalar components in an object of this type. ">SimdArray::size()</a>).</li>
</ul>
<p>The return type of the operator is a <a class="el" href="classVc_1_1SimdMaskArray.html" title="Data-parallel mask type with user-defined number of boolean elements. ">SimdMaskArray</a> type using the more precise EntryType of <code>L</code> or <code>R</code> and the same number of elements as the <a class="el" href="classVc_1_1SimdArray.html" title="Data-parallel arithmetic type with user-defined number of elements. ">SimdArray</a> argument(s). </p>
</td></tr>
<tr class="memitem:gadf80a87e185730c114ec7053fb770b5b"><td class="memTemplParams" colspan="2"><a class="anchor" id="gadf80a87e185730c114ec7053fb770b5b"></a>
template&lt;typename L , typename R &gt; </td></tr>
<tr class="memitem:gadf80a87e185730c114ec7053fb770b5b"><td class="memTemplItemLeft" align="right" valign="top">result_vector_type&lt; L, R &gt;::mask_type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__SimdArray.html#gadf80a87e185730c114ec7053fb770b5b">operator==</a> (L &amp;&amp;lhs, R &amp;&amp;rhs)</td></tr>
<tr class="memdesc:gadf80a87e185730c114ec7053fb770b5b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies == component-wise and concurrently. <br /></td></tr>
<tr class="separator:gadf80a87e185730c114ec7053fb770b5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7e06e1b9d3afe2f426c84f7c118ed0bb"><td class="memTemplParams" colspan="2"><a class="anchor" id="ga7e06e1b9d3afe2f426c84f7c118ed0bb"></a>
template&lt;typename L , typename R &gt; </td></tr>
<tr class="memitem:ga7e06e1b9d3afe2f426c84f7c118ed0bb"><td class="memTemplItemLeft" align="right" valign="top">result_vector_type&lt; L, R &gt;::mask_type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__SimdArray.html#ga7e06e1b9d3afe2f426c84f7c118ed0bb">operator!=</a> (L &amp;&amp;lhs, R &amp;&amp;rhs)</td></tr>
<tr class="memdesc:ga7e06e1b9d3afe2f426c84f7c118ed0bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies != component-wise and concurrently. <br /></td></tr>
<tr class="separator:ga7e06e1b9d3afe2f426c84f7c118ed0bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa3745538a664644c14f4a27b4e9f4238"><td class="memTemplParams" colspan="2"><a class="anchor" id="gaa3745538a664644c14f4a27b4e9f4238"></a>
template&lt;typename L , typename R &gt; </td></tr>
<tr class="memitem:gaa3745538a664644c14f4a27b4e9f4238"><td class="memTemplItemLeft" align="right" valign="top">result_vector_type&lt; L, R &gt;::mask_type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__SimdArray.html#gaa3745538a664644c14f4a27b4e9f4238">operator&lt;=</a> (L &amp;&amp;lhs, R &amp;&amp;rhs)</td></tr>
<tr class="memdesc:gaa3745538a664644c14f4a27b4e9f4238"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies &lt;= component-wise and concurrently. <br /></td></tr>
<tr class="separator:gaa3745538a664644c14f4a27b4e9f4238"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga198cbd2ca4f3de75efd9dcaf4fb9ee08"><td class="memTemplParams" colspan="2"><a class="anchor" id="ga198cbd2ca4f3de75efd9dcaf4fb9ee08"></a>
template&lt;typename L , typename R &gt; </td></tr>
<tr class="memitem:ga198cbd2ca4f3de75efd9dcaf4fb9ee08"><td class="memTemplItemLeft" align="right" valign="top">result_vector_type&lt; L, R &gt;::mask_type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__SimdArray.html#ga198cbd2ca4f3de75efd9dcaf4fb9ee08">operator&gt;=</a> (L &amp;&amp;lhs, R &amp;&amp;rhs)</td></tr>
<tr class="memdesc:ga198cbd2ca4f3de75efd9dcaf4fb9ee08"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies &gt;= component-wise and concurrently. <br /></td></tr>
<tr class="separator:ga198cbd2ca4f3de75efd9dcaf4fb9ee08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9e055e35447acfbcbc53948132aeef58"><td class="memTemplParams" colspan="2"><a class="anchor" id="ga9e055e35447acfbcbc53948132aeef58"></a>
template&lt;typename L , typename R &gt; </td></tr>
<tr class="memitem:ga9e055e35447acfbcbc53948132aeef58"><td class="memTemplItemLeft" align="right" valign="top">result_vector_type&lt; L, R &gt;::mask_type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__SimdArray.html#ga9e055e35447acfbcbc53948132aeef58">operator&lt;</a> (L &amp;&amp;lhs, R &amp;&amp;rhs)</td></tr>
<tr class="memdesc:ga9e055e35447acfbcbc53948132aeef58"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies &lt; component-wise and concurrently. <br /></td></tr>
<tr class="separator:ga9e055e35447acfbcbc53948132aeef58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga69acacfd02bca93d1e5dc537fe7d76bf"><td class="memTemplParams" colspan="2"><a class="anchor" id="ga69acacfd02bca93d1e5dc537fe7d76bf"></a>
template&lt;typename L , typename R &gt; </td></tr>
<tr class="memitem:ga69acacfd02bca93d1e5dc537fe7d76bf"><td class="memTemplItemLeft" align="right" valign="top">result_vector_type&lt; L, R &gt;::mask_type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__SimdArray.html#ga69acacfd02bca93d1e5dc537fe7d76bf">operator&gt;</a> (L &amp;&amp;lhs, R &amp;&amp;rhs)</td></tr>
<tr class="memdesc:ga69acacfd02bca93d1e5dc537fe7d76bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies &gt; component-wise and concurrently. <br /></td></tr>
<tr class="separator:ga69acacfd02bca93d1e5dc537fe7d76bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Math functions</h2></td></tr>
<tr><td class="ititle" colspan="2"><p><a class="anchor" id="amgrp6da9e6e15ed23e812a71d127b2d24dad"></a>These functions evaluate the </p>
</td></tr>
<tr class="memitem:ga59599be1f025c93b66f9b4c982b8bd90"><td class="memTemplParams" colspan="2"><a class="anchor" id="ga59599be1f025c93b66f9b4c982b8bd90"></a>
template&lt;typename T , std::size_t N, typename V , std::size_t M&gt; </td></tr>
<tr class="memitem:ga59599be1f025c93b66f9b4c982b8bd90"><td class="memTemplItemLeft" align="right" valign="top">SimdArray&lt; T, N, V, M &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__SimdArray.html#ga59599be1f025c93b66f9b4c982b8bd90">abs</a> (const SimdArray&lt; T, N, V, M &gt; &amp;x)</td></tr>
<tr class="memdesc:ga59599be1f025c93b66f9b4c982b8bd90"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the std:: abs function component-wise and concurrently. <br /></td></tr>
<tr class="separator:ga59599be1f025c93b66f9b4c982b8bd90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab22c24ad680e7ef50bbc431b95c36eb9"><td class="memTemplParams" colspan="2"><a class="anchor" id="gab22c24ad680e7ef50bbc431b95c36eb9"></a>
template&lt;typename T , std::size_t N, typename V , std::size_t M&gt; </td></tr>
<tr class="memitem:gab22c24ad680e7ef50bbc431b95c36eb9"><td class="memTemplItemLeft" align="right" valign="top">SimdArray&lt; T, N, V, M &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__SimdArray.html#gab22c24ad680e7ef50bbc431b95c36eb9">asin</a> (const SimdArray&lt; T, N, V, M &gt; &amp;x)</td></tr>
<tr class="memdesc:gab22c24ad680e7ef50bbc431b95c36eb9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the std:: asin function component-wise and concurrently. <br /></td></tr>
<tr class="separator:gab22c24ad680e7ef50bbc431b95c36eb9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab8251f5a1d26f60a73e047b63b4350d0"><td class="memTemplParams" colspan="2"><a class="anchor" id="gab8251f5a1d26f60a73e047b63b4350d0"></a>
template&lt;typename T , std::size_t N, typename V , std::size_t M&gt; </td></tr>
<tr class="memitem:gab8251f5a1d26f60a73e047b63b4350d0"><td class="memTemplItemLeft" align="right" valign="top">SimdArray&lt; T, N, V, M &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__SimdArray.html#gab8251f5a1d26f60a73e047b63b4350d0">atan</a> (const SimdArray&lt; T, N, V, M &gt; &amp;x)</td></tr>
<tr class="memdesc:gab8251f5a1d26f60a73e047b63b4350d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the std:: atan function component-wise and concurrently. <br /></td></tr>
<tr class="separator:gab8251f5a1d26f60a73e047b63b4350d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga59db0cc8843ec4c377b97d03c2545749"><td class="memTemplParams" colspan="2"><a class="anchor" id="ga59db0cc8843ec4c377b97d03c2545749"></a>
template&lt;typename T , std::size_t N, typename V , std::size_t M&gt; </td></tr>
<tr class="memitem:ga59db0cc8843ec4c377b97d03c2545749"><td class="memTemplItemLeft" align="right" valign="top">SimdArray&lt; T, N, V, M &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__SimdArray.html#ga59db0cc8843ec4c377b97d03c2545749">atan2</a> (const SimdArray&lt; T, N, V, M &gt; &amp;x, const SimdArray&lt; T, N, V, M &gt; &amp;y)</td></tr>
<tr class="memdesc:ga59db0cc8843ec4c377b97d03c2545749"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the std:: atan2 function component-wise and concurrently. <br /></td></tr>
<tr class="separator:ga59db0cc8843ec4c377b97d03c2545749"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga82224eb7d91ce23e72009d033d48deb5"><td class="memTemplParams" colspan="2"><a class="anchor" id="ga82224eb7d91ce23e72009d033d48deb5"></a>
template&lt;typename T , std::size_t N, typename V , std::size_t M&gt; </td></tr>
<tr class="memitem:ga82224eb7d91ce23e72009d033d48deb5"><td class="memTemplItemLeft" align="right" valign="top">SimdArray&lt; T, N, V, M &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__SimdArray.html#ga82224eb7d91ce23e72009d033d48deb5">ceil</a> (const SimdArray&lt; T, N, V, M &gt; &amp;x)</td></tr>
<tr class="memdesc:ga82224eb7d91ce23e72009d033d48deb5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the std:: ceil function component-wise and concurrently. <br /></td></tr>
<tr class="separator:ga82224eb7d91ce23e72009d033d48deb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad34671db81c39d19c831bd1ef55ec22f"><td class="memTemplParams" colspan="2"><a class="anchor" id="gad34671db81c39d19c831bd1ef55ec22f"></a>
template&lt;typename T , std::size_t N, typename V , std::size_t M&gt; </td></tr>
<tr class="memitem:gad34671db81c39d19c831bd1ef55ec22f"><td class="memTemplItemLeft" align="right" valign="top">SimdArray&lt; T, N, V, M &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__SimdArray.html#gad34671db81c39d19c831bd1ef55ec22f">copysign</a> (const SimdArray&lt; T, N, V, M &gt; &amp;x, const SimdArray&lt; T, N, V, M &gt; &amp;y)</td></tr>
<tr class="memdesc:gad34671db81c39d19c831bd1ef55ec22f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the std:: copysign function component-wise and concurrently. <br /></td></tr>
<tr class="separator:gad34671db81c39d19c831bd1ef55ec22f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa2ccbed667e352fd7648d9e55e846ec2"><td class="memTemplParams" colspan="2"><a class="anchor" id="gaa2ccbed667e352fd7648d9e55e846ec2"></a>
template&lt;typename T , std::size_t N, typename V , std::size_t M&gt; </td></tr>
<tr class="memitem:gaa2ccbed667e352fd7648d9e55e846ec2"><td class="memTemplItemLeft" align="right" valign="top">SimdArray&lt; T, N, V, M &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__SimdArray.html#gaa2ccbed667e352fd7648d9e55e846ec2">cos</a> (const SimdArray&lt; T, N, V, M &gt; &amp;x)</td></tr>
<tr class="memdesc:gaa2ccbed667e352fd7648d9e55e846ec2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the std:: cos function component-wise and concurrently. <br /></td></tr>
<tr class="separator:gaa2ccbed667e352fd7648d9e55e846ec2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1f55653a26a334db8e5efae19791d227"><td class="memTemplParams" colspan="2"><a class="anchor" id="ga1f55653a26a334db8e5efae19791d227"></a>
template&lt;typename T , std::size_t N, typename V , std::size_t M&gt; </td></tr>
<tr class="memitem:ga1f55653a26a334db8e5efae19791d227"><td class="memTemplItemLeft" align="right" valign="top">SimdArray&lt; T, N, V, M &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__SimdArray.html#ga1f55653a26a334db8e5efae19791d227">exp</a> (const SimdArray&lt; T, N, V, M &gt; &amp;x)</td></tr>
<tr class="memdesc:ga1f55653a26a334db8e5efae19791d227"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the std:: exp function component-wise and concurrently. <br /></td></tr>
<tr class="separator:ga1f55653a26a334db8e5efae19791d227"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae35147ca0930dd1963bb751bf7a3d098"><td class="memTemplParams" colspan="2"><a class="anchor" id="gae35147ca0930dd1963bb751bf7a3d098"></a>
template&lt;typename T , std::size_t N, typename V , std::size_t M&gt; </td></tr>
<tr class="memitem:gae35147ca0930dd1963bb751bf7a3d098"><td class="memTemplItemLeft" align="right" valign="top">SimdArray&lt; T, N, V, M &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__SimdArray.html#gae35147ca0930dd1963bb751bf7a3d098">exponent</a> (const SimdArray&lt; T, N, V, M &gt; &amp;x)</td></tr>
<tr class="memdesc:gae35147ca0930dd1963bb751bf7a3d098"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the std:: exponent function component-wise and concurrently. <br /></td></tr>
<tr class="separator:gae35147ca0930dd1963bb751bf7a3d098"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga92ce5286f5f104e17d7e89d3ab10068f"><td class="memTemplParams" colspan="2"><a class="anchor" id="ga92ce5286f5f104e17d7e89d3ab10068f"></a>
template&lt;typename T , std::size_t N, typename V , std::size_t M&gt; </td></tr>
<tr class="memitem:ga92ce5286f5f104e17d7e89d3ab10068f"><td class="memTemplItemLeft" align="right" valign="top">SimdArray&lt; T, N, V, M &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__SimdArray.html#ga92ce5286f5f104e17d7e89d3ab10068f">floor</a> (const SimdArray&lt; T, N, V, M &gt; &amp;x)</td></tr>
<tr class="memdesc:ga92ce5286f5f104e17d7e89d3ab10068f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the std:: floor function component-wise and concurrently. <br /></td></tr>
<tr class="separator:ga92ce5286f5f104e17d7e89d3ab10068f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga97439099223fd29fa42541f7aa04a7cc"><td class="memTemplParams" colspan="2"><a class="anchor" id="ga97439099223fd29fa42541f7aa04a7cc"></a>
template&lt;typename T , std::size_t N&gt; </td></tr>
<tr class="memitem:ga97439099223fd29fa42541f7aa04a7cc"><td class="memTemplItemLeft" align="right" valign="top">SimdArray&lt; T, N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__SimdArray.html#ga97439099223fd29fa42541f7aa04a7cc">fma</a> (const SimdArray&lt; T, N &gt; &amp;a, const SimdArray&lt; T, N &gt; &amp;b, const SimdArray&lt; T, N &gt; &amp;c)</td></tr>
<tr class="memdesc:ga97439099223fd29fa42541f7aa04a7cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the std::fma function component-wise and concurrently. <br /></td></tr>
<tr class="separator:ga97439099223fd29fa42541f7aa04a7cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafeaa7c2aab6114e03701d408a964b798"><td class="memTemplParams" colspan="2"><a class="anchor" id="gafeaa7c2aab6114e03701d408a964b798"></a>
template&lt;typename T , std::size_t N, typename V , std::size_t M&gt; </td></tr>
<tr class="memitem:gafeaa7c2aab6114e03701d408a964b798"><td class="memTemplItemLeft" align="right" valign="top">SimdMaskArray&lt; T, N, V, M &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__SimdArray.html#gafeaa7c2aab6114e03701d408a964b798">isfinite</a> (const SimdArray&lt; T, N, V, M &gt; &amp;x)</td></tr>
<tr class="memdesc:gafeaa7c2aab6114e03701d408a964b798"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the std:: isfinite function component-wise and concurrently. <br /></td></tr>
<tr class="separator:gafeaa7c2aab6114e03701d408a964b798"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4e45591f421c29983a9c849468c9497b"><td class="memTemplParams" colspan="2"><a class="anchor" id="ga4e45591f421c29983a9c849468c9497b"></a>
template&lt;typename T , std::size_t N, typename V , std::size_t M&gt; </td></tr>
<tr class="memitem:ga4e45591f421c29983a9c849468c9497b"><td class="memTemplItemLeft" align="right" valign="top">SimdMaskArray&lt; T, N, V, M &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__SimdArray.html#ga4e45591f421c29983a9c849468c9497b">isinf</a> (const SimdArray&lt; T, N, V, M &gt; &amp;x)</td></tr>
<tr class="memdesc:ga4e45591f421c29983a9c849468c9497b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the std:: isinf function component-wise and concurrently. <br /></td></tr>
<tr class="separator:ga4e45591f421c29983a9c849468c9497b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3a8f83043c013591f220cc99c8372c83"><td class="memTemplParams" colspan="2"><a class="anchor" id="ga3a8f83043c013591f220cc99c8372c83"></a>
template&lt;typename T , std::size_t N, typename V , std::size_t M&gt; </td></tr>
<tr class="memitem:ga3a8f83043c013591f220cc99c8372c83"><td class="memTemplItemLeft" align="right" valign="top">SimdMaskArray&lt; T, N, V, M &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__SimdArray.html#ga3a8f83043c013591f220cc99c8372c83">isnan</a> (const SimdArray&lt; T, N, V, M &gt; &amp;x)</td></tr>
<tr class="memdesc:ga3a8f83043c013591f220cc99c8372c83"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the std:: isnan function component-wise and concurrently. <br /></td></tr>
<tr class="separator:ga3a8f83043c013591f220cc99c8372c83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2bbbde31371490c3600d9d301f22b9a6"><td class="memTemplParams" colspan="2"><a class="anchor" id="ga2bbbde31371490c3600d9d301f22b9a6"></a>
template&lt;typename T , std::size_t N, typename V , std::size_t M&gt; </td></tr>
<tr class="memitem:ga2bbbde31371490c3600d9d301f22b9a6"><td class="memTemplItemLeft" align="right" valign="top">SimdMaskArray&lt; T, N, V, M &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__SimdArray.html#ga2bbbde31371490c3600d9d301f22b9a6">isnegative</a> (const SimdArray&lt; T, N, V, M &gt; &amp;x)</td></tr>
<tr class="memdesc:ga2bbbde31371490c3600d9d301f22b9a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the std:: isnegative function component-wise and concurrently. <br /></td></tr>
<tr class="separator:ga2bbbde31371490c3600d9d301f22b9a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa7da8e46d071738215ad0c1be86a53e5"><td class="memTemplParams" colspan="2"><a class="anchor" id="gaa7da8e46d071738215ad0c1be86a53e5"></a>
template&lt;typename T , std::size_t N&gt; </td></tr>
<tr class="memitem:gaa7da8e46d071738215ad0c1be86a53e5"><td class="memTemplItemLeft" align="right" valign="top">SimdArray&lt; T, N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__SimdArray.html#gaa7da8e46d071738215ad0c1be86a53e5">frexp</a> (const SimdArray&lt; T, N &gt; &amp;x, SimdArray&lt; int, N &gt; *e)</td></tr>
<tr class="memdesc:gaa7da8e46d071738215ad0c1be86a53e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the std::frexp function component-wise and concurrently. <br /></td></tr>
<tr class="separator:gaa7da8e46d071738215ad0c1be86a53e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaac3a233b72277a553a087e17d290afa6"><td class="memTemplParams" colspan="2"><a class="anchor" id="gaac3a233b72277a553a087e17d290afa6"></a>
template&lt;typename T , std::size_t N&gt; </td></tr>
<tr class="memitem:gaac3a233b72277a553a087e17d290afa6"><td class="memTemplItemLeft" align="right" valign="top">SimdArray&lt; T, N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__SimdArray.html#gaac3a233b72277a553a087e17d290afa6">ldexp</a> (const SimdArray&lt; T, N &gt; &amp;x, const SimdArray&lt; int, N &gt; &amp;e)</td></tr>
<tr class="memdesc:gaac3a233b72277a553a087e17d290afa6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the std::ldexp function component-wise and concurrently. <br /></td></tr>
<tr class="separator:gaac3a233b72277a553a087e17d290afa6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa6ba2215c36a8b8146fade991f39a3ca"><td class="memTemplParams" colspan="2"><a class="anchor" id="gaa6ba2215c36a8b8146fade991f39a3ca"></a>
template&lt;typename T , std::size_t N, typename V , std::size_t M&gt; </td></tr>
<tr class="memitem:gaa6ba2215c36a8b8146fade991f39a3ca"><td class="memTemplItemLeft" align="right" valign="top">SimdArray&lt; T, N, V, M &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__SimdArray.html#gaa6ba2215c36a8b8146fade991f39a3ca">log</a> (const SimdArray&lt; T, N, V, M &gt; &amp;x)</td></tr>
<tr class="memdesc:gaa6ba2215c36a8b8146fade991f39a3ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the std:: log function component-wise and concurrently. <br /></td></tr>
<tr class="separator:gaa6ba2215c36a8b8146fade991f39a3ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1c7aa866df9bd09e2bba4c80fbaf4872"><td class="memTemplParams" colspan="2"><a class="anchor" id="ga1c7aa866df9bd09e2bba4c80fbaf4872"></a>
template&lt;typename T , std::size_t N, typename V , std::size_t M&gt; </td></tr>
<tr class="memitem:ga1c7aa866df9bd09e2bba4c80fbaf4872"><td class="memTemplItemLeft" align="right" valign="top">SimdArray&lt; T, N, V, M &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__SimdArray.html#ga1c7aa866df9bd09e2bba4c80fbaf4872">log10</a> (const SimdArray&lt; T, N, V, M &gt; &amp;x)</td></tr>
<tr class="memdesc:ga1c7aa866df9bd09e2bba4c80fbaf4872"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the std:: log10 function component-wise and concurrently. <br /></td></tr>
<tr class="separator:ga1c7aa866df9bd09e2bba4c80fbaf4872"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga829e931dc5c0b256ccb5f1eee45c71a8"><td class="memTemplParams" colspan="2"><a class="anchor" id="ga829e931dc5c0b256ccb5f1eee45c71a8"></a>
template&lt;typename T , std::size_t N, typename V , std::size_t M&gt; </td></tr>
<tr class="memitem:ga829e931dc5c0b256ccb5f1eee45c71a8"><td class="memTemplItemLeft" align="right" valign="top">SimdArray&lt; T, N, V, M &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__SimdArray.html#ga829e931dc5c0b256ccb5f1eee45c71a8">log2</a> (const SimdArray&lt; T, N, V, M &gt; &amp;x)</td></tr>
<tr class="memdesc:ga829e931dc5c0b256ccb5f1eee45c71a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the std:: log2 function component-wise and concurrently. <br /></td></tr>
<tr class="separator:ga829e931dc5c0b256ccb5f1eee45c71a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad323d331ea3e0b295ec6c0302d8c07ec"><td class="memTemplParams" colspan="2"><a class="anchor" id="gad323d331ea3e0b295ec6c0302d8c07ec"></a>
template&lt;typename T , std::size_t N, typename V , std::size_t M&gt; </td></tr>
<tr class="memitem:gad323d331ea3e0b295ec6c0302d8c07ec"><td class="memTemplItemLeft" align="right" valign="top">SimdArray&lt; T, N, V, M &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__SimdArray.html#gad323d331ea3e0b295ec6c0302d8c07ec">reciprocal</a> (const SimdArray&lt; T, N, V, M &gt; &amp;x)</td></tr>
<tr class="memdesc:gad323d331ea3e0b295ec6c0302d8c07ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the std:: reciprocal function component-wise and concurrently. <br /></td></tr>
<tr class="separator:gad323d331ea3e0b295ec6c0302d8c07ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8e6483c99554e6b8453f80f4a24fe8a1"><td class="memTemplParams" colspan="2"><a class="anchor" id="ga8e6483c99554e6b8453f80f4a24fe8a1"></a>
template&lt;typename T , std::size_t N, typename V , std::size_t M&gt; </td></tr>
<tr class="memitem:ga8e6483c99554e6b8453f80f4a24fe8a1"><td class="memTemplItemLeft" align="right" valign="top">SimdArray&lt; T, N, V, M &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__SimdArray.html#ga8e6483c99554e6b8453f80f4a24fe8a1">round</a> (const SimdArray&lt; T, N, V, M &gt; &amp;x)</td></tr>
<tr class="memdesc:ga8e6483c99554e6b8453f80f4a24fe8a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the std:: round function component-wise and concurrently. <br /></td></tr>
<tr class="separator:ga8e6483c99554e6b8453f80f4a24fe8a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad3fdb1d2d52e9c1a812283dcb9327ad3"><td class="memTemplParams" colspan="2"><a class="anchor" id="gad3fdb1d2d52e9c1a812283dcb9327ad3"></a>
template&lt;typename T , std::size_t N, typename V , std::size_t M&gt; </td></tr>
<tr class="memitem:gad3fdb1d2d52e9c1a812283dcb9327ad3"><td class="memTemplItemLeft" align="right" valign="top">SimdArray&lt; T, N, V, M &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__SimdArray.html#gad3fdb1d2d52e9c1a812283dcb9327ad3">rsqrt</a> (const SimdArray&lt; T, N, V, M &gt; &amp;x)</td></tr>
<tr class="memdesc:gad3fdb1d2d52e9c1a812283dcb9327ad3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the std:: rsqrt function component-wise and concurrently. <br /></td></tr>
<tr class="separator:gad3fdb1d2d52e9c1a812283dcb9327ad3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5b336e425fc5a80aedf1988d7ff4ff72"><td class="memTemplParams" colspan="2"><a class="anchor" id="ga5b336e425fc5a80aedf1988d7ff4ff72"></a>
template&lt;typename T , std::size_t N, typename V , std::size_t M&gt; </td></tr>
<tr class="memitem:ga5b336e425fc5a80aedf1988d7ff4ff72"><td class="memTemplItemLeft" align="right" valign="top">SimdArray&lt; T, N, V, M &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__SimdArray.html#ga5b336e425fc5a80aedf1988d7ff4ff72">sin</a> (const SimdArray&lt; T, N, V, M &gt; &amp;x)</td></tr>
<tr class="memdesc:ga5b336e425fc5a80aedf1988d7ff4ff72"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the std:: sin function component-wise and concurrently. <br /></td></tr>
<tr class="separator:ga5b336e425fc5a80aedf1988d7ff4ff72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeb11d4042dcea400cd11940af21163c1"><td class="memTemplParams" colspan="2"><a class="anchor" id="gaeb11d4042dcea400cd11940af21163c1"></a>
template&lt;typename T , std::size_t N&gt; </td></tr>
<tr class="memitem:gaeb11d4042dcea400cd11940af21163c1"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__SimdArray.html#gaeb11d4042dcea400cd11940af21163c1">sincos</a> (const SimdArray&lt; T, N &gt; &amp;x, SimdArray&lt; T, N &gt; *sin, SimdArray&lt; T, N &gt; *cos)</td></tr>
<tr class="memdesc:gaeb11d4042dcea400cd11940af21163c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines sine and cosine concurrently and component-wise on <code>x</code>. <br /></td></tr>
<tr class="separator:gaeb11d4042dcea400cd11940af21163c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8a4200f5246664614569c9c721fc174f"><td class="memTemplParams" colspan="2"><a class="anchor" id="ga8a4200f5246664614569c9c721fc174f"></a>
template&lt;typename T , std::size_t N, typename V , std::size_t M&gt; </td></tr>
<tr class="memitem:ga8a4200f5246664614569c9c721fc174f"><td class="memTemplItemLeft" align="right" valign="top">SimdArray&lt; T, N, V, M &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__SimdArray.html#ga8a4200f5246664614569c9c721fc174f">sqrt</a> (const SimdArray&lt; T, N, V, M &gt; &amp;x)</td></tr>
<tr class="memdesc:ga8a4200f5246664614569c9c721fc174f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the std:: sqrt function component-wise and concurrently. <br /></td></tr>
<tr class="separator:ga8a4200f5246664614569c9c721fc174f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae74763eed24e0e462dec7b16d0178970"><td class="memTemplParams" colspan="2"><a class="anchor" id="gae74763eed24e0e462dec7b16d0178970"></a>
template&lt;typename T , std::size_t N, typename V , std::size_t M&gt; </td></tr>
<tr class="memitem:gae74763eed24e0e462dec7b16d0178970"><td class="memTemplItemLeft" align="right" valign="top">SimdArray&lt; T, N, V, M &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__SimdArray.html#gae74763eed24e0e462dec7b16d0178970">trunc</a> (const SimdArray&lt; T, N, V, M &gt; &amp;x)</td></tr>
<tr class="memdesc:gae74763eed24e0e462dec7b16d0178970"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the std:: trunc function component-wise and concurrently. <br /></td></tr>
<tr class="separator:gae74763eed24e0e462dec7b16d0178970"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeebf7baf079ffc700f6c853b17e00ead"><td class="memTemplParams" colspan="2"><a class="anchor" id="gaeebf7baf079ffc700f6c853b17e00ead"></a>
template&lt;typename T , std::size_t N, typename V , std::size_t M&gt; </td></tr>
<tr class="memitem:gaeebf7baf079ffc700f6c853b17e00ead"><td class="memTemplItemLeft" align="right" valign="top">SimdArray&lt; T, N, V, M &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__SimdArray.html#gaeebf7baf079ffc700f6c853b17e00ead">min</a> (const SimdArray&lt; T, N, V, M &gt; &amp;x, const SimdArray&lt; T, N, V, M &gt; &amp;y)</td></tr>
<tr class="memdesc:gaeebf7baf079ffc700f6c853b17e00ead"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the std:: min function component-wise and concurrently. <br /></td></tr>
<tr class="separator:gaeebf7baf079ffc700f6c853b17e00ead"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1117cfb2fa80555a6f5e4a040082c7ce"><td class="memTemplParams" colspan="2"><a class="anchor" id="ga1117cfb2fa80555a6f5e4a040082c7ce"></a>
template&lt;typename T , std::size_t N, typename V , std::size_t M&gt; </td></tr>
<tr class="memitem:ga1117cfb2fa80555a6f5e4a040082c7ce"><td class="memTemplItemLeft" align="right" valign="top">SimdArray&lt; T, N, V, M &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__SimdArray.html#ga1117cfb2fa80555a6f5e4a040082c7ce">max</a> (const SimdArray&lt; T, N, V, M &gt; &amp;x, const SimdArray&lt; T, N, V, M &gt; &amp;y)</td></tr>
<tr class="memdesc:ga1117cfb2fa80555a6f5e4a040082c7ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the std:: max function component-wise and concurrently. <br /></td></tr>
<tr class="separator:ga1117cfb2fa80555a6f5e4a040082c7ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Deprecated Members</h2></td></tr>
<tr class="memitem:gad550c4cd366024e9b37c4a7c7c9b96ff"><td class="memItemLeft" align="right" valign="top">static constexpr std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__SimdArray.html#gad550c4cd366024e9b37c4a7c7c9b96ff">Size</a> = size()</td></tr>
<tr class="memdesc:gad550c4cd366024e9b37c4a7c7c9b96ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>N</code>, the number of scalar components in an object of this type.  <a href="#gad550c4cd366024e9b37c4a7c7c9b96ff">More...</a><br /></td></tr>
<tr class="separator:gad550c4cd366024e9b37c4a7c7c9b96ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6bb8bb8ed9d9e770caa63d8727bef37d"><td class="memTemplParams" colspan="2">template&lt;typename S1 , typename IT &gt; </td></tr>
<tr class="memitem:ga6bb8bb8ed9d9e770caa63d8727bef37d"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__SimdArray.html#ga6bb8bb8ed9d9e770caa63d8727bef37d">SimdArray</a> (const S1 *array, const EntryType S1::*member1, const IT indexes)</td></tr>
<tr class="separator:ga6bb8bb8ed9d9e770caa63d8727bef37d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6ac31568e980e2cc4c06e45faada9b89"><td class="memTemplParams" colspan="2">template&lt;typename S1 , typename IT &gt; </td></tr>
<tr class="memitem:ga6ac31568e980e2cc4c06e45faada9b89"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__SimdArray.html#ga6ac31568e980e2cc4c06e45faada9b89">SimdArray</a> (const S1 *array, const EntryType S1::*member1, const IT indexes, MaskArgument mask)</td></tr>
<tr class="separator:ga6ac31568e980e2cc4c06e45faada9b89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad513a7d557396b174fb428c498aebf62"><td class="memTemplParams" colspan="2">template&lt;typename S1 , typename S2 , typename IT &gt; </td></tr>
<tr class="memitem:gad513a7d557396b174fb428c498aebf62"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__SimdArray.html#gad513a7d557396b174fb428c498aebf62">SimdArray</a> (const S1 *array, const S2 S1::*member1, const EntryType S2::*member2, const IT indexes)</td></tr>
<tr class="separator:gad513a7d557396b174fb428c498aebf62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2b4b808542a17f13237f3698af3cca55"><td class="memTemplParams" colspan="2">template&lt;typename S1 , typename S2 , typename IT &gt; </td></tr>
<tr class="memitem:ga2b4b808542a17f13237f3698af3cca55"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__SimdArray.html#ga2b4b808542a17f13237f3698af3cca55">SimdArray</a> (const S1 *array, const S2 S1::*member1, const EntryType S2::*member2, const IT indexes, MaskArgument mask)</td></tr>
<tr class="separator:ga2b4b808542a17f13237f3698af3cca55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae307029e82d6e9656705e25b202d93c9"><td class="memTemplParams" colspan="2">template&lt;typename S1 , typename IT1 , typename IT2 &gt; </td></tr>
<tr class="memitem:gae307029e82d6e9656705e25b202d93c9"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__SimdArray.html#gae307029e82d6e9656705e25b202d93c9">SimdArray</a> (const S1 *array, const EntryType *const S1::*ptrMember1, const IT1 outerIndexes, const IT2 innerIndexes)</td></tr>
<tr class="separator:gae307029e82d6e9656705e25b202d93c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1f801a6f87d8f208806faeae70456d1c"><td class="memTemplParams" colspan="2">template&lt;typename S1 , typename IT1 , typename IT2 &gt; </td></tr>
<tr class="memitem:ga1f801a6f87d8f208806faeae70456d1c"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__SimdArray.html#ga1f801a6f87d8f208806faeae70456d1c">SimdArray</a> (const S1 *array, const EntryType *const S1::*ptrMember1, const IT1 outerIndexes, const IT2 innerIndexes, MaskArgument mask)</td></tr>
<tr class="separator:ga1f801a6f87d8f208806faeae70456d1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7f8cc8e1e198325fdef564ba8af33c46"><td class="memTemplParams" colspan="2">template&lt;typename S1 , typename IT &gt; </td></tr>
<tr class="memitem:ga7f8cc8e1e198325fdef564ba8af33c46"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__SimdArray.html#ga7f8cc8e1e198325fdef564ba8af33c46">gather</a> (const S1 *array, const EntryType S1::*member1, const IT indexes)</td></tr>
<tr class="separator:ga7f8cc8e1e198325fdef564ba8af33c46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0b246db4487101a46a5e28fcd31377d7"><td class="memTemplParams" colspan="2">template&lt;typename S1 , typename IT &gt; </td></tr>
<tr class="memitem:ga0b246db4487101a46a5e28fcd31377d7"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__SimdArray.html#ga0b246db4487101a46a5e28fcd31377d7">gather</a> (const S1 *array, const EntryType S1::*member1, const IT indexes, MaskArgument mask)</td></tr>
<tr class="separator:ga0b246db4487101a46a5e28fcd31377d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf32aae9abd1ea04aa7e5af3b66782b3b"><td class="memTemplParams" colspan="2">template&lt;typename S1 , typename S2 , typename IT &gt; </td></tr>
<tr class="memitem:gaf32aae9abd1ea04aa7e5af3b66782b3b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__SimdArray.html#gaf32aae9abd1ea04aa7e5af3b66782b3b">gather</a> (const S1 *array, const S2 S1::*member1, const EntryType S2::*member2, const IT indexes)</td></tr>
<tr class="separator:gaf32aae9abd1ea04aa7e5af3b66782b3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga627f4a2af864abae1e7b461672d899a1"><td class="memTemplParams" colspan="2">template&lt;typename S1 , typename S2 , typename IT &gt; </td></tr>
<tr class="memitem:ga627f4a2af864abae1e7b461672d899a1"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__SimdArray.html#ga627f4a2af864abae1e7b461672d899a1">gather</a> (const S1 *array, const S2 S1::*member1, const EntryType S2::*member2, const IT indexes, MaskArgument mask)</td></tr>
<tr class="separator:ga627f4a2af864abae1e7b461672d899a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga265d176e098cc9d3c120ed46b7686de5"><td class="memTemplParams" colspan="2">template&lt;typename S1 , typename IT1 , typename IT2 &gt; </td></tr>
<tr class="memitem:ga265d176e098cc9d3c120ed46b7686de5"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__SimdArray.html#ga265d176e098cc9d3c120ed46b7686de5">gather</a> (const S1 *array, const EntryType *const S1::*ptrMember1, const IT1 outerIndexes, const IT2 innerIndexes)</td></tr>
<tr class="separator:ga265d176e098cc9d3c120ed46b7686de5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3b31d4a0de86e7b6d72f94744b355da6"><td class="memTemplParams" colspan="2">template&lt;typename S1 , typename IT1 , typename IT2 &gt; </td></tr>
<tr class="memitem:ga3b31d4a0de86e7b6d72f94744b355da6"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__SimdArray.html#ga3b31d4a0de86e7b6d72f94744b355da6">gather</a> (const S1 *array, const EntryType *const S1::*ptrMember1, const IT1 outerIndexes, const IT2 innerIndexes, MaskArgument mask)</td></tr>
<tr class="separator:ga3b31d4a0de86e7b6d72f94744b355da6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9efe43b277afc22a8ecf7d1c5c3e2d69"><td class="memItemLeft" align="right" valign="top">SimdArray&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__SimdArray.html#ga9efe43b277afc22a8ecf7d1c5c3e2d69">exponent</a> () const </td></tr>
<tr class="memdesc:ga9efe43b277afc22a8ecf7d1c5c3e2d69"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the exponents of the floating-point values in the vector.  <a href="#ga9efe43b277afc22a8ecf7d1c5c3e2d69">More...</a><br /></td></tr>
<tr class="separator:ga9efe43b277afc22a8ecf7d1c5c3e2d69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae69d39745f8c88369041a693f6e5d0b7"><td class="memItemLeft" align="right" valign="top">MaskType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__SimdArray.html#gae69d39745f8c88369041a693f6e5d0b7">isNegative</a> () const </td></tr>
<tr class="memdesc:gae69d39745f8c88369041a693f6e5d0b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether a value is negative.  <a href="#gae69d39745f8c88369041a693f6e5d0b7">More...</a><br /></td></tr>
<tr class="separator:gae69d39745f8c88369041a693f6e5d0b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafa32a2551d18c3fd8812b9ce7bb7282b"><td class="memItemLeft" align="right" valign="top">SimdArray&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__SimdArray.html#gafa32a2551d18c3fd8812b9ce7bb7282b">copySign</a> (const SimdArray &amp;reference) const </td></tr>
<tr class="memdesc:gafa32a2551d18c3fd8812b9ce7bb7282b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies the signs of the components of <code>reference</code> to the components of the current vector, returning the result.  <a href="#gafa32a2551d18c3fd8812b9ce7bb7282b">More...</a><br /></td></tr>
<tr class="separator:gafa32a2551d18c3fd8812b9ce7bb7282b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="ga6bb8bb8ed9d9e770caa63d8727bef37d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">SimdArray </td>
          <td>(</td>
          <td class="paramtype">const S1 *&#160;</td>
          <td class="paramname"><em>array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classVc_1_1SimdArray.html#ae01209df02a8750be9c3aca4728e056d">EntryType</a> S1::*&#160;</td>
          <td class="paramname"><em>member1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const IT&#160;</td>
          <td class="paramname"><em>indexes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000033">Deprecated:</a></b></dt><dd>Use Vc::array or <a class="el" href="group__Utilities.html#gac1ffd8b29c356abdbb821a7854c53b07" title="An adapted std::vector container with an additional subscript operator which implements gather and sc...">Vc::vector</a> subscripting instead.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">array</td><td>A pointer into memory (without alignment restrictions). </td></tr>
    <tr><td class="paramname">member1</td><td>If <code>array</code> points to a struct, <code>member1</code> determines the member in the struct to be read. Thus the offsets in <code>indexes</code> are relative to the <code>array</code> and not to the size of the gathered type (i.e. array[i].*member1 is accessed instead of (&amp;(array-&gt;*member1))[i]) </td></tr>
    <tr><td class="paramname">indexes</td><td>Determines the offsets into <code>array</code> where the values are gathered from/scattered to. The type of indexes can either be an integer vector or a type that supports operator[] access. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="simdarray_8h_source.html#l00237">237</a> of file <a class="el" href="simdarray_8h_source.html">simdarray.h</a>.</p>

</div>
</div>
<a class="anchor" id="ga6ac31568e980e2cc4c06e45faada9b89"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">SimdArray </td>
          <td>(</td>
          <td class="paramtype">const S1 *&#160;</td>
          <td class="paramname"><em>array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classVc_1_1SimdArray.html#ae01209df02a8750be9c3aca4728e056d">EntryType</a> S1::*&#160;</td>
          <td class="paramname"><em>member1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const IT&#160;</td>
          <td class="paramname"><em>indexes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classVc_1_1SimdMaskArray.html">MaskArgument</a>&#160;</td>
          <td class="paramname"><em>mask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000034">Deprecated:</a></b></dt><dd>Use Vc::array or <a class="el" href="group__Utilities.html#gac1ffd8b29c356abdbb821a7854c53b07" title="An adapted std::vector container with an additional subscript operator which implements gather and sc...">Vc::vector</a> subscripting instead.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">array</td><td>A pointer into memory (without alignment restrictions). </td></tr>
    <tr><td class="paramname">member1</td><td>If <code>array</code> points to a struct, <code>member1</code> determines the member in the struct to be read. Thus the offsets in <code>indexes</code> are relative to the <code>array</code> and not to the size of the gathered type (i.e. array[i].*member1 is accessed instead of (&amp;(array-&gt;*member1))[i]) </td></tr>
    <tr><td class="paramname">indexes</td><td>Determines the offsets into <code>array</code> where the values are gathered from/scattered to. The type of indexes can either be an integer vector or a type that supports operator[] access. </td></tr>
    <tr><td class="paramname">mask</td><td>If a mask is given only the active entries will be gathered/scattered. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="simdarray_8h_source.html#l00260">260</a> of file <a class="el" href="simdarray_8h_source.html">simdarray.h</a>.</p>

</div>
</div>
<a class="anchor" id="gad513a7d557396b174fb428c498aebf62"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">SimdArray </td>
          <td>(</td>
          <td class="paramtype">const S1 *&#160;</td>
          <td class="paramname"><em>array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const S2 S1::*&#160;</td>
          <td class="paramname"><em>member1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classVc_1_1SimdArray.html#ae01209df02a8750be9c3aca4728e056d">EntryType</a> S2::*&#160;</td>
          <td class="paramname"><em>member2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const IT&#160;</td>
          <td class="paramname"><em>indexes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000035">Deprecated:</a></b></dt><dd>Use Vc::array or <a class="el" href="group__Utilities.html#gac1ffd8b29c356abdbb821a7854c53b07" title="An adapted std::vector container with an additional subscript operator which implements gather and sc...">Vc::vector</a> subscripting instead.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">array</td><td>A pointer into memory (without alignment restrictions). </td></tr>
    <tr><td class="paramname">member1</td><td>If <code>array</code> points to a struct, <code>member1</code> determines the member in the struct to be read. Thus the offsets in <code>indexes</code> are relative to the <code>array</code> and not to the size of the gathered type (i.e. array[i].*member1 is accessed instead of (&amp;(array-&gt;*member1))[i]) </td></tr>
    <tr><td class="paramname">member2</td><td>If <code>member1</code> is a struct then <code>member2</code> selects the member to be read from that struct (i.e. array[i].*member1.*member2 is read). </td></tr>
    <tr><td class="paramname">indexes</td><td>Determines the offsets into <code>array</code> where the values are gathered from/scattered to. The type of indexes can either be an integer vector or a type that supports operator[] access. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="simdarray_8h_source.html#l00285">285</a> of file <a class="el" href="simdarray_8h_source.html">simdarray.h</a>.</p>

</div>
</div>
<a class="anchor" id="ga2b4b808542a17f13237f3698af3cca55"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">SimdArray </td>
          <td>(</td>
          <td class="paramtype">const S1 *&#160;</td>
          <td class="paramname"><em>array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const S2 S1::*&#160;</td>
          <td class="paramname"><em>member1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classVc_1_1SimdArray.html#ae01209df02a8750be9c3aca4728e056d">EntryType</a> S2::*&#160;</td>
          <td class="paramname"><em>member2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const IT&#160;</td>
          <td class="paramname"><em>indexes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classVc_1_1SimdMaskArray.html">MaskArgument</a>&#160;</td>
          <td class="paramname"><em>mask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000036">Deprecated:</a></b></dt><dd>Use Vc::array or <a class="el" href="group__Utilities.html#gac1ffd8b29c356abdbb821a7854c53b07" title="An adapted std::vector container with an additional subscript operator which implements gather and sc...">Vc::vector</a> subscripting instead.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">array</td><td>A pointer into memory (without alignment restrictions). </td></tr>
    <tr><td class="paramname">member1</td><td>If <code>array</code> points to a struct, <code>member1</code> determines the member in the struct to be read. Thus the offsets in <code>indexes</code> are relative to the <code>array</code> and not to the size of the gathered type (i.e. array[i].*member1 is accessed instead of (&amp;(array-&gt;*member1))[i]) </td></tr>
    <tr><td class="paramname">member2</td><td>If <code>member1</code> is a struct then <code>member2</code> selects the member to be read from that struct (i.e. array[i].*member1.*member2 is read). </td></tr>
    <tr><td class="paramname">indexes</td><td>Determines the offsets into <code>array</code> where the values are gathered from/scattered to. The type of indexes can either be an integer vector or a type that supports operator[] access. </td></tr>
    <tr><td class="paramname">mask</td><td>If a mask is given only the active entries will be gathered/scattered. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="simdarray_8h_source.html#l00311">311</a> of file <a class="el" href="simdarray_8h_source.html">simdarray.h</a>.</p>

</div>
</div>
<a class="anchor" id="gae307029e82d6e9656705e25b202d93c9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">SimdArray </td>
          <td>(</td>
          <td class="paramtype">const S1 *&#160;</td>
          <td class="paramname"><em>array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classVc_1_1SimdArray.html#ae01209df02a8750be9c3aca4728e056d">EntryType</a> *const S1::*&#160;</td>
          <td class="paramname"><em>ptrMember1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const IT1&#160;</td>
          <td class="paramname"><em>outerIndexes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const IT2&#160;</td>
          <td class="paramname"><em>innerIndexes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000037">Deprecated:</a></b></dt><dd>Use Vc::array or <a class="el" href="group__Utilities.html#gac1ffd8b29c356abdbb821a7854c53b07" title="An adapted std::vector container with an additional subscript operator which implements gather and sc...">Vc::vector</a> subscripting instead.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">array</td><td>A pointer into memory (without alignment restrictions). </td></tr>
    <tr><td class="paramname">ptrMember1</td><td>If <code>array</code> points to a struct, <code>member1</code> determines the member in the struct to be read. Thus the offsets in <code>indexes</code> are relative to the <code>array</code> and not to the size of the gathered type (i.e. array[i].*member1 is accessed instead of (&amp;(array-&gt;*member1))[i]) </td></tr>
    <tr><td class="paramname">outerIndexes</td><td></td></tr>
    <tr><td class="paramname">innerIndexes</td><td></td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="simdarray_8h_source.html#l00334">334</a> of file <a class="el" href="simdarray_8h_source.html">simdarray.h</a>.</p>

</div>
</div>
<a class="anchor" id="ga1f801a6f87d8f208806faeae70456d1c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">SimdArray </td>
          <td>(</td>
          <td class="paramtype">const S1 *&#160;</td>
          <td class="paramname"><em>array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classVc_1_1SimdArray.html#ae01209df02a8750be9c3aca4728e056d">EntryType</a> *const S1::*&#160;</td>
          <td class="paramname"><em>ptrMember1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const IT1&#160;</td>
          <td class="paramname"><em>outerIndexes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const IT2&#160;</td>
          <td class="paramname"><em>innerIndexes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classVc_1_1SimdMaskArray.html">MaskArgument</a>&#160;</td>
          <td class="paramname"><em>mask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000038">Deprecated:</a></b></dt><dd>Use Vc::array or <a class="el" href="group__Utilities.html#gac1ffd8b29c356abdbb821a7854c53b07" title="An adapted std::vector container with an additional subscript operator which implements gather and sc...">Vc::vector</a> subscripting instead.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">array</td><td>A pointer into memory (without alignment restrictions). </td></tr>
    <tr><td class="paramname">ptrMember1</td><td>If <code>array</code> points to a struct, <code>member1</code> determines the member in the struct to be read. Thus the offsets in <code>indexes</code> are relative to the <code>array</code> and not to the size of the gathered type (i.e. array[i].*member1 is accessed instead of (&amp;(array-&gt;*member1))[i]) </td></tr>
    <tr><td class="paramname">outerIndexes</td><td></td></tr>
    <tr><td class="paramname">innerIndexes</td><td></td></tr>
    <tr><td class="paramname">mask</td><td>If a mask is given only the active entries will be gathered/scattered. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="simdarray_8h_source.html#l00357">357</a> of file <a class="el" href="simdarray_8h_source.html">simdarray.h</a>.</p>

</div>
</div>
<a class="anchor" id="ga7f8cc8e1e198325fdef564ba8af33c46"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void gather </td>
          <td>(</td>
          <td class="paramtype">const S1 *&#160;</td>
          <td class="paramname"><em>array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classVc_1_1SimdArray.html#ae01209df02a8750be9c3aca4728e056d">EntryType</a> S1::*&#160;</td>
          <td class="paramname"><em>member1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const IT&#160;</td>
          <td class="paramname"><em>indexes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000039">Deprecated:</a></b></dt><dd>Use Vc::array or <a class="el" href="group__Utilities.html#gac1ffd8b29c356abdbb821a7854c53b07" title="An adapted std::vector container with an additional subscript operator which implements gather and sc...">Vc::vector</a> subscripting instead.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">array</td><td>A pointer into memory (without alignment restrictions). </td></tr>
    <tr><td class="paramname">member1</td><td>If <code>array</code> points to a struct, <code>member1</code> determines the member in the struct to be read. Thus the offsets in <code>indexes</code> are relative to the <code>array</code> and not to the size of the gathered type (i.e. array[i].*member1 is accessed instead of (&amp;(array-&gt;*member1))[i]) </td></tr>
    <tr><td class="paramname">indexes</td><td>Determines the offsets into <code>array</code> where the values are gathered from/scattered to. The type of indexes can either be an integer vector or a type that supports operator[] access. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="simdarray_8h_source.html#l00381">381</a> of file <a class="el" href="simdarray_8h_source.html">simdarray.h</a>.</p>

</div>
</div>
<a class="anchor" id="ga0b246db4487101a46a5e28fcd31377d7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void gather </td>
          <td>(</td>
          <td class="paramtype">const S1 *&#160;</td>
          <td class="paramname"><em>array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classVc_1_1SimdArray.html#ae01209df02a8750be9c3aca4728e056d">EntryType</a> S1::*&#160;</td>
          <td class="paramname"><em>member1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const IT&#160;</td>
          <td class="paramname"><em>indexes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classVc_1_1SimdMaskArray.html">MaskArgument</a>&#160;</td>
          <td class="paramname"><em>mask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000040">Deprecated:</a></b></dt><dd>Use Vc::array or <a class="el" href="group__Utilities.html#gac1ffd8b29c356abdbb821a7854c53b07" title="An adapted std::vector container with an additional subscript operator which implements gather and sc...">Vc::vector</a> subscripting instead.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">array</td><td>A pointer into memory (without alignment restrictions). </td></tr>
    <tr><td class="paramname">member1</td><td>If <code>array</code> points to a struct, <code>member1</code> determines the member in the struct to be read. Thus the offsets in <code>indexes</code> are relative to the <code>array</code> and not to the size of the gathered type (i.e. array[i].*member1 is accessed instead of (&amp;(array-&gt;*member1))[i]) </td></tr>
    <tr><td class="paramname">indexes</td><td>Determines the offsets into <code>array</code> where the values are gathered from/scattered to. The type of indexes can either be an integer vector or a type that supports operator[] access. </td></tr>
    <tr><td class="paramname">mask</td><td>If a mask is given only the active entries will be gathered/scattered. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="simdarray_8h_source.html#l00405">405</a> of file <a class="el" href="simdarray_8h_source.html">simdarray.h</a>.</p>

</div>
</div>
<a class="anchor" id="gaf32aae9abd1ea04aa7e5af3b66782b3b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void gather </td>
          <td>(</td>
          <td class="paramtype">const S1 *&#160;</td>
          <td class="paramname"><em>array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const S2 S1::*&#160;</td>
          <td class="paramname"><em>member1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classVc_1_1SimdArray.html#ae01209df02a8750be9c3aca4728e056d">EntryType</a> S2::*&#160;</td>
          <td class="paramname"><em>member2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const IT&#160;</td>
          <td class="paramname"><em>indexes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000041">Deprecated:</a></b></dt><dd>Use Vc::array or <a class="el" href="group__Utilities.html#gac1ffd8b29c356abdbb821a7854c53b07" title="An adapted std::vector container with an additional subscript operator which implements gather and sc...">Vc::vector</a> subscripting instead.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">array</td><td>A pointer into memory (without alignment restrictions). </td></tr>
    <tr><td class="paramname">member1</td><td>If <code>array</code> points to a struct, <code>member1</code> determines the member in the struct to be read. Thus the offsets in <code>indexes</code> are relative to the <code>array</code> and not to the size of the gathered type (i.e. array[i].*member1 is accessed instead of (&amp;(array-&gt;*member1))[i]) </td></tr>
    <tr><td class="paramname">member2</td><td>If <code>member1</code> is a struct then <code>member2</code> selects the member to be read from that struct (i.e. array[i].*member1.*member2 is read). </td></tr>
    <tr><td class="paramname">indexes</td><td>Determines the offsets into <code>array</code> where the values are gathered from/scattered to. The type of indexes can either be an integer vector or a type that supports operator[] access. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="simdarray_8h_source.html#l00432">432</a> of file <a class="el" href="simdarray_8h_source.html">simdarray.h</a>.</p>

</div>
</div>
<a class="anchor" id="ga627f4a2af864abae1e7b461672d899a1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void gather </td>
          <td>(</td>
          <td class="paramtype">const S1 *&#160;</td>
          <td class="paramname"><em>array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const S2 S1::*&#160;</td>
          <td class="paramname"><em>member1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classVc_1_1SimdArray.html#ae01209df02a8750be9c3aca4728e056d">EntryType</a> S2::*&#160;</td>
          <td class="paramname"><em>member2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const IT&#160;</td>
          <td class="paramname"><em>indexes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classVc_1_1SimdMaskArray.html">MaskArgument</a>&#160;</td>
          <td class="paramname"><em>mask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000042">Deprecated:</a></b></dt><dd>Use Vc::array or <a class="el" href="group__Utilities.html#gac1ffd8b29c356abdbb821a7854c53b07" title="An adapted std::vector container with an additional subscript operator which implements gather and sc...">Vc::vector</a> subscripting instead.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">array</td><td>A pointer into memory (without alignment restrictions). </td></tr>
    <tr><td class="paramname">member1</td><td>If <code>array</code> points to a struct, <code>member1</code> determines the member in the struct to be read. Thus the offsets in <code>indexes</code> are relative to the <code>array</code> and not to the size of the gathered type (i.e. array[i].*member1 is accessed instead of (&amp;(array-&gt;*member1))[i]) </td></tr>
    <tr><td class="paramname">member2</td><td>If <code>member1</code> is a struct then <code>member2</code> selects the member to be read from that struct (i.e. array[i].*member1.*member2 is read). </td></tr>
    <tr><td class="paramname">indexes</td><td>Determines the offsets into <code>array</code> where the values are gathered from/scattered to. The type of indexes can either be an integer vector or a type that supports operator[] access. </td></tr>
    <tr><td class="paramname">mask</td><td>If a mask is given only the active entries will be gathered/scattered. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="simdarray_8h_source.html#l00458">458</a> of file <a class="el" href="simdarray_8h_source.html">simdarray.h</a>.</p>

</div>
</div>
<a class="anchor" id="ga265d176e098cc9d3c120ed46b7686de5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void gather </td>
          <td>(</td>
          <td class="paramtype">const S1 *&#160;</td>
          <td class="paramname"><em>array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classVc_1_1SimdArray.html#ae01209df02a8750be9c3aca4728e056d">EntryType</a> *const S1::*&#160;</td>
          <td class="paramname"><em>ptrMember1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const IT1&#160;</td>
          <td class="paramname"><em>outerIndexes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const IT2&#160;</td>
          <td class="paramname"><em>innerIndexes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000043">Deprecated:</a></b></dt><dd>Use Vc::array or <a class="el" href="group__Utilities.html#gac1ffd8b29c356abdbb821a7854c53b07" title="An adapted std::vector container with an additional subscript operator which implements gather and sc...">Vc::vector</a> subscripting instead.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">array</td><td>A pointer into memory (without alignment restrictions). </td></tr>
    <tr><td class="paramname">ptrMember1</td><td>If <code>array</code> points to a struct, <code>member1</code> determines the member in the struct to be read. Thus the offsets in <code>indexes</code> are relative to the <code>array</code> and not to the size of the gathered type (i.e. array[i].*member1 is accessed instead of (&amp;(array-&gt;*member1))[i]) </td></tr>
    <tr><td class="paramname">outerIndexes</td><td></td></tr>
    <tr><td class="paramname">innerIndexes</td><td></td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="simdarray_8h_source.html#l00482">482</a> of file <a class="el" href="simdarray_8h_source.html">simdarray.h</a>.</p>

</div>
</div>
<a class="anchor" id="ga3b31d4a0de86e7b6d72f94744b355da6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void gather </td>
          <td>(</td>
          <td class="paramtype">const S1 *&#160;</td>
          <td class="paramname"><em>array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classVc_1_1SimdArray.html#ae01209df02a8750be9c3aca4728e056d">EntryType</a> *const S1::*&#160;</td>
          <td class="paramname"><em>ptrMember1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const IT1&#160;</td>
          <td class="paramname"><em>outerIndexes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const IT2&#160;</td>
          <td class="paramname"><em>innerIndexes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classVc_1_1SimdMaskArray.html">MaskArgument</a>&#160;</td>
          <td class="paramname"><em>mask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000044">Deprecated:</a></b></dt><dd>Use Vc::array or <a class="el" href="group__Utilities.html#gac1ffd8b29c356abdbb821a7854c53b07" title="An adapted std::vector container with an additional subscript operator which implements gather and sc...">Vc::vector</a> subscripting instead.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">array</td><td>A pointer into memory (without alignment restrictions). </td></tr>
    <tr><td class="paramname">ptrMember1</td><td>If <code>array</code> points to a struct, <code>member1</code> determines the member in the struct to be read. Thus the offsets in <code>indexes</code> are relative to the <code>array</code> and not to the size of the gathered type (i.e. array[i].*member1 is accessed instead of (&amp;(array-&gt;*member1))[i]) </td></tr>
    <tr><td class="paramname">outerIndexes</td><td></td></tr>
    <tr><td class="paramname">innerIndexes</td><td></td></tr>
    <tr><td class="paramname">mask</td><td>If a mask is given only the active entries will be gathered/scattered. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="simdarray_8h_source.html#l00506">506</a> of file <a class="el" href="simdarray_8h_source.html">simdarray.h</a>.</p>

</div>
</div>
<a class="anchor" id="ga9efe43b277afc22a8ecf7d1c5c3e2d69"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">SimdArray exponent </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the exponents of the floating-point values in the vector. </p>
<dl class="section return"><dt>Returns</dt><dd>A new vector object of the same type containing the exponents.</dd></dl>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000064">Deprecated:</a></b></dt><dd>use <a class="el" href="group__SimdArray.html#gae35147ca0930dd1963bb751bf7a3d098" title="Applies the std:: exponent function component-wise and concurrently. ">Vc::exponent</a> instead. </dd></dl>

<p>Definition at line <a class="el" href="simdarray_8h_source.html#l01245">1245</a> of file <a class="el" href="simdarray_8h_source.html">simdarray.h</a>.</p>

</div>
</div>
<a class="anchor" id="gae69d39745f8c88369041a693f6e5d0b7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">MaskType isNegative </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns whether a value is negative. </p>
<dl class="section return"><dt>Returns</dt><dd>A new mask object indicating the sign of each vector element.</dd></dl>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000065">Deprecated:</a></b></dt><dd>use <a class="el" href="group__SimdArray.html#ga2bbbde31371490c3600d9d301f22b9a6" title="Applies the std:: isnegative function component-wise and concurrently. ">Vc::isnegative</a> instead. </dd></dl>

<p>Definition at line <a class="el" href="simdarray_8h_source.html#l01251">1251</a> of file <a class="el" href="simdarray_8h_source.html">simdarray.h</a>.</p>

</div>
</div>
<a class="anchor" id="gafa32a2551d18c3fd8812b9ce7bb7282b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">SimdArray copySign </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classVc_1_1SimdArray.html">SimdArray</a>&lt; T, N, V, Wt &gt; &amp;&#160;</td>
          <td class="paramname"><em>reference</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies the signs of the components of <code>reference</code> to the components of the current vector, returning the result. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">reference</td><td>A vector object that determines the sign of the the result. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A new vector with sign taken from <code>reference</code> and absolute value taken from the current vector object.</dd></dl>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000069">Deprecated:</a></b></dt><dd>Use <a class="el" href="group__SimdArray.html#gad34671db81c39d19c831bd1ef55ec22f" title="Applies the std:: copysign function component-wise and concurrently. ">Vc::copysign</a> instead. </dd></dl>

<p>Definition at line <a class="el" href="simdarray_8h_source.html#l01258">1258</a> of file <a class="el" href="simdarray_8h_source.html">simdarray.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a class="anchor" id="gad550c4cd366024e9b37c4a7c7c9b96ff"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr std::size_t Size = size()</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns <code>N</code>, the number of scalar components in an object of this type. </p>
<p>The size of the <a class="el" href="classVc_1_1SimdArray.html" title="Data-parallel arithmetic type with user-defined number of elements. ">SimdArray</a>, i.e. the number of scalar elements in the vector. In contrast to <a class="el" href="classVc_1_1Vector.html#a1b5d7e2e663d7997796fd9f72b8af75a" title="Returns the number of scalar components ( ) in a vector of this type. ">Vector::size()</a> you have control over this value via the <code>N</code> template parameter of the <a class="el" href="classVc_1_1SimdArray.html" title="Data-parallel arithmetic type with user-defined number of elements. ">SimdArray</a> class template.</p>
<dl class="section return"><dt>Returns</dt><dd>The number of scalar values stored and manipulated concurrently by objects of this type. </dd></dl>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000045">Deprecated:</a></b></dt><dd>Use <a class="el" href="classVc_1_1SimdArray.html#a5e99fb015bfbc024a4b785135b34dee7" title="Returns N, the number of scalar components in an object of this type. ">size()</a> instead. </dd></dl>

<p>Definition at line <a class="el" href="simdarray_8h_source.html#l01242">1242</a> of file <a class="el" href="simdarray_8h_source.html">simdarray.h</a>.</p>

</div>
</div>
<a class="anchor" id="gaac286912729d28478c8c9a1ac97a92ac"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr std::size_t MemoryAlignment</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div>
<div class="line">        <a class="code" href="group__Vectors.html#gaac286912729d28478c8c9a1ac97a92ac">storage_type0::MemoryAlignment</a> &gt; <a class="code" href="group__Vectors.html#gaac286912729d28478c8c9a1ac97a92ac">storage_type1::MemoryAlignment</a></div>
<div class="line">            ? <a class="code" href="group__Vectors.html#gaac286912729d28478c8c9a1ac97a92ac">storage_type0::MemoryAlignment</a></div>
<div class="line">            : <a class="code" href="group__Vectors.html#gaac286912729d28478c8c9a1ac97a92ac">storage_type1::MemoryAlignment</a></div>
</div><!-- fragment -->
<p>Specifies the alignment requirement for aligned load and store calls for objects of this vector type. </p>

<p>Definition at line <a class="el" href="simdarray_8h_source.html#l00575">575</a> of file <a class="el" href="simdarray_8h_source.html">simdarray.h</a>.</p>

</div>
</div>
<a class="anchor" id="gad550c4cd366024e9b37c4a7c7c9b96ff"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr std::size_t Size = size()</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of boolean components ( \(\mathcal{W}_\mathtt{T}\)) in a mask of this type. </p>
<p>The size of the mask. I.e. the number of boolean entries in the mask. Do not make any assumptions about the size of masks.</p>
<p>In addition, you can easily use if clauses that compare sizes. The compiler can statically evaluate and fully optimize dead code away (very much like #ifdef, but with syntax checking).</p>
<dl class="section return"><dt>Returns</dt><dd>The number of components (i.e. \(\mathcal{W}_\mathtt{T}\)) objects of this mask type store and manipulate. </dd></dl>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000014">Deprecated:</a></b></dt><dd>Use <a class="el" href="classVc_1_1Mask.html#a1b5d7e2e663d7997796fd9f72b8af75a" title="Returns the number of boolean components ( ) in a mask of this type. ">Vc::Mask::size</a> instead. </dd></dl>

<p>Definition at line <a class="el" href="simdmaskarray_8h_source.html#l00309">309</a> of file <a class="el" href="simdmaskarray_8h_source.html">simdmaskarray.h</a>.</p>

</div>
</div>
<a class="anchor" id="gaac286912729d28478c8c9a1ac97a92ac"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr std::size_t MemoryAlignment</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div>
<div class="line">        <a class="code" href="group__SimdArray.html#gaac286912729d28478c8c9a1ac97a92ac">storage_type0::MemoryAlignment</a> &gt; <a class="code" href="group__SimdArray.html#gaac286912729d28478c8c9a1ac97a92ac">storage_type1::MemoryAlignment</a></div>
<div class="line">            ? <a class="code" href="group__SimdArray.html#gaac286912729d28478c8c9a1ac97a92ac">storage_type0::MemoryAlignment</a></div>
<div class="line">            : <a class="code" href="group__SimdArray.html#gaac286912729d28478c8c9a1ac97a92ac">storage_type1::MemoryAlignment</a></div>
</div><!-- fragment -->
<p>Specifies the alignment requirement for aligned load and store calls for objects of this mask type. </p>

<p>Definition at line <a class="el" href="simdmaskarray_8h_source.html#l00311">311</a> of file <a class="el" href="simdmaskarray_8h_source.html">simdmaskarray.h</a>.</p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.9.1 </li>
  </ul>
</div>
</body>
</html>
