<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>Vc: SimdMaskArray&lt; T, N, V, Wt &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() {
    if ($('.searchresults').length > 0) { searchBox.DOMSearchField().focus(); }
  });
</script>
<link rel="search" href="search_opensearch.php?v=opensearch.xml" type="application/opensearchdescription+xml" title="Vc"/>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo_small.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Vc
   &#160;<span id="projectnumber">1.3.3-dev</span>
   </div>
   <div id="projectbrief">SIMD Vector Classes for C++</div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
          <div class="left">
            <form id="FSearchBox" action="search.php" method="get">
              <img id="MSearchSelect" src="search/mag.png" alt=""/>
              <input type="text" id="MSearchField" name="query" value="Search" size="20" accesskey="S" 
                     onfocus="searchBox.OnSearchFieldFocus(true)" 
                     onblur="searchBox.OnSearchFieldFocus(false)"/>
            </form>
          </div><div class="right"></div>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('classVc_1_1SimdMaskArray.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="classVc_1_1SimdMaskArray-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">SimdMaskArray&lt; T, N, V, Wt &gt; Class Template Reference<div class="ingroups"><a class="el" href="group__SimdArray.html">SIMD Array</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename T, size_t N, typename V, size_t Wt&gt;<br />
class Vc::SimdMaskArray&lt; T, N, V, Wt &gt;</h3>

<p>Data-parallel mask type with user-defined number of boolean elements. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The value type of the corresponding <a class="el" href="classVc_1_1SimdArray.html" title="Data-parallel arithmetic type with user-defined number of elements. ">SimdArray</a>. Depending on the target platform this type determines a different bit representation to work most efficient with <a class="el" href="classVc_1_1SimdArray.html" title="Data-parallel arithmetic type with user-defined number of elements. ">SimdArray</a> types instantiated for <code>T</code>.</td></tr>
    <tr><td class="paramname">N</td><td>The number of boolean elements to store and process concurrently. You can choose an arbitrary number, though not every number is a good idea. Generally, a power of two value or the sum of two power of two values might work efficiently, though this depends a lot on the target system.</td></tr>
    <tr><td class="paramname">V</td><td>Don't change the default value unless you really know what you are doing. This type is set to the underlying native <a class="el" href="classVc_1_1Vector.html" title="The main vector class for expressing data parallelism. ">Vc::Vector</a> type used in the implementation of the type. Having it as part of the type name guards against some cases of ODR violations (i.e. linking incompatible translation units / libraries).</td></tr>
    <tr><td class="paramname">Wt</td><td>Don't ever change the default value. This parameter is an unfortunate implementation detail shining through. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="simdarrayfwd_8h_source.html#l00121">121</a> of file <a class="el" href="simdarrayfwd_8h_source.html">simdarrayfwd.h</a>.</p>
</div>
<p><code>#include &lt;<a class="el" href="simdmaskarray_8h_source.html">Vc/SimdArray</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a1361e8e9cce10205928db7c5d49c76dc"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVc_1_1SimdMaskArray.html#a1361e8e9cce10205928db7c5d49c76dc">value_type</a> = typename <a class="el" href="classVc_1_1SimdMaskArray.html#ae01209df02a8750be9c3aca4728e056d">storage_type0::EntryType</a></td></tr>
<tr class="memdesc:a1361e8e9cce10205928db7c5d49c76dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <code>EntryType</code> of masks is always <code>bool</code>, independent of <code>T</code>.  <a href="#a1361e8e9cce10205928db7c5d49c76dc">More...</a><br /></td></tr>
<tr class="separator:a1361e8e9cce10205928db7c5d49c76dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a197e6d613393324683e71a9bbc4b1d36"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVc_1_1SimdMaskArray.html#a197e6d613393324683e71a9bbc4b1d36">MaskType</a> = <a class="el" href="classVc_1_1SimdMaskArray.html">mask_type</a></td></tr>
<tr class="memdesc:a197e6d613393324683e71a9bbc4b1d36"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a zero-initialized vector object.  <a href="#a197e6d613393324683e71a9bbc4b1d36">More...</a><br /></td></tr>
<tr class="separator:a197e6d613393324683e71a9bbc4b1d36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54e5ed8e98d92aac3ac40647db1c17bf"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVc_1_1SimdMaskArray.html#a54e5ed8e98d92aac3ac40647db1c17bf">VectorEntryType</a> = vectorentry_type</td></tr>
<tr class="memdesc:a54e5ed8e98d92aac3ac40647db1c17bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <code>VectorEntryType</code>, in contrast to <code>EntryType</code>, reveals information about the SIMD implementation.  <a href="#a54e5ed8e98d92aac3ac40647db1c17bf">More...</a><br /></td></tr>
<tr class="separator:a54e5ed8e98d92aac3ac40647db1c17bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae01209df02a8750be9c3aca4728e056d"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVc_1_1SimdMaskArray.html#ae01209df02a8750be9c3aca4728e056d">EntryType</a> = <a class="el" href="classVc_1_1SimdMaskArray.html#a1361e8e9cce10205928db7c5d49c76dc">value_type</a></td></tr>
<tr class="memdesc:ae01209df02a8750be9c3aca4728e056d"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <code>EntryType</code> of masks is always <code>bool</code>, independent of <code>T</code>.  <a href="#ae01209df02a8750be9c3aca4728e056d">More...</a><br /></td></tr>
<tr class="separator:ae01209df02a8750be9c3aca4728e056d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a841b1b3a66f9457f3161e9b171af29f4"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVc_1_1SimdMaskArray.html#a841b1b3a66f9457f3161e9b171af29f4">EntryReference</a> = Vc::Detail::ElementReference&lt; <a class="el" href="classVc_1_1SimdMaskArray.html">SimdMaskArray</a> &gt;</td></tr>
<tr class="memdesc:a841b1b3a66f9457f3161e9b171af29f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">The reference wrapper type used for accessing individual mask components.  <a href="#a841b1b3a66f9457f3161e9b171af29f4">More...</a><br /></td></tr>
<tr class="separator:a841b1b3a66f9457f3161e9b171af29f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add4ea9e1b88b554bd681cdd65387fb4d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="add4ea9e1b88b554bd681cdd65387fb4d"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVc_1_1SimdMaskArray.html#add4ea9e1b88b554bd681cdd65387fb4d">Vector</a> = <a class="el" href="classVc_1_1SimdArray.html">SimdArray</a>&lt; T, N, V, V::Size &gt;</td></tr>
<tr class="memdesc:add4ea9e1b88b554bd681cdd65387fb4d"><td class="mdescLeft">&#160;</td><td class="mdescRight">An alias for the corresponding <a class="el" href="classVc_1_1SimdArray.html" title="Data-parallel arithmetic type with user-defined number of elements. ">SimdArray</a> type. <br /></td></tr>
<tr class="separator:add4ea9e1b88b554bd681cdd65387fb4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ac3726a8e8149927942c1a1dcee279597"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVc_1_1SimdMaskArray.html#ac3726a8e8149927942c1a1dcee279597">SimdMaskArray</a> ()=default</td></tr>
<tr class="memdesc:ac3726a8e8149927942c1a1dcee279597"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a zero-initialized vector object.  <a href="#ac3726a8e8149927942c1a1dcee279597">More...</a><br /></td></tr>
<tr class="separator:ac3726a8e8149927942c1a1dcee279597"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7cb2c66758351e600a2b63a6447bdd17"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7cb2c66758351e600a2b63a6447bdd17"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVc_1_1SimdMaskArray.html#a7cb2c66758351e600a2b63a6447bdd17">SimdMaskArray</a> (VectorSpecialInitializerOne one)</td></tr>
<tr class="memdesc:a7cb2c66758351e600a2b63a6447bdd17"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize the new mask object to one (<code>true</code>). <br /></td></tr>
<tr class="separator:a7cb2c66758351e600a2b63a6447bdd17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af532e5e145f96b14e411852b7491cbdb"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af532e5e145f96b14e411852b7491cbdb"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVc_1_1SimdMaskArray.html#af532e5e145f96b14e411852b7491cbdb">SimdMaskArray</a> (VectorSpecialInitializerZero zero)</td></tr>
<tr class="memdesc:af532e5e145f96b14e411852b7491cbdb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Zero-initialize the new mask object (<code>false</code>). <br /></td></tr>
<tr class="separator:af532e5e145f96b14e411852b7491cbdb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0558e628a2e7e2511b250e724a5a82bc"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVc_1_1SimdMaskArray.html#a0558e628a2e7e2511b250e724a5a82bc">SimdMaskArray</a> (bool b)</td></tr>
<tr class="memdesc:a0558e628a2e7e2511b250e724a5a82bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Broadcast constructor.  <a href="#a0558e628a2e7e2511b250e724a5a82bc">More...</a><br /></td></tr>
<tr class="separator:a0558e628a2e7e2511b250e724a5a82bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79e163ca8f685a0e69494c6dfbae7015"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVc_1_1SimdMaskArray.html#a79e163ca8f685a0e69494c6dfbae7015">operator==</a> (const <a class="el" href="classVc_1_1SimdMaskArray.html">SimdMaskArray</a> &amp;mask) const </td></tr>
<tr class="memdesc:a79e163ca8f685a0e69494c6dfbae7015"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether the two masks are equal in all components.  <a href="#a79e163ca8f685a0e69494c6dfbae7015">More...</a><br /></td></tr>
<tr class="separator:a79e163ca8f685a0e69494c6dfbae7015"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a80ae6f62487ae5dab5e51843528feb"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVc_1_1SimdMaskArray.html#a1a80ae6f62487ae5dab5e51843528feb">operator!=</a> (const <a class="el" href="classVc_1_1SimdMaskArray.html">SimdMaskArray</a> &amp;mask) const </td></tr>
<tr class="memdesc:a1a80ae6f62487ae5dab5e51843528feb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether the two masks are different in at least one component.  <a href="#a1a80ae6f62487ae5dab5e51843528feb">More...</a><br /></td></tr>
<tr class="separator:a1a80ae6f62487ae5dab5e51843528feb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24b3eaf2e8037bb616cc51c8a4a2bcf9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a24b3eaf2e8037bb616cc51c8a4a2bcf9"></a>
<a class="el" href="classVc_1_1SimdMaskArray.html">SimdMaskArray</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVc_1_1SimdMaskArray.html#a24b3eaf2e8037bb616cc51c8a4a2bcf9">operator!</a> () const </td></tr>
<tr class="memdesc:a24b3eaf2e8037bb616cc51c8a4a2bcf9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a mask with inverted components. <br /></td></tr>
<tr class="separator:a24b3eaf2e8037bb616cc51c8a4a2bcf9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5719b457b48f6647abb477ac6acf505a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5719b457b48f6647abb477ac6acf505a"></a>
<a class="el" href="classVc_1_1SimdMaskArray.html">SimdMaskArray</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVc_1_1SimdMaskArray.html#a5719b457b48f6647abb477ac6acf505a">operator&amp;=</a> (const <a class="el" href="classVc_1_1SimdMaskArray.html">SimdMaskArray</a> &amp;rhs)</td></tr>
<tr class="memdesc:a5719b457b48f6647abb477ac6acf505a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Modifies the mask using an <code>AND</code> operation with <code>mask</code>. <br /></td></tr>
<tr class="separator:a5719b457b48f6647abb477ac6acf505a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7085bb8610e51146c27d4f5b55d322e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa7085bb8610e51146c27d4f5b55d322e"></a>
<a class="el" href="classVc_1_1SimdMaskArray.html">SimdMaskArray</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVc_1_1SimdMaskArray.html#aa7085bb8610e51146c27d4f5b55d322e">operator|=</a> (const <a class="el" href="classVc_1_1SimdMaskArray.html">SimdMaskArray</a> &amp;rhs)</td></tr>
<tr class="memdesc:aa7085bb8610e51146c27d4f5b55d322e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Modifies the mask using an <code>OR</code> operation with <code>mask</code>. <br /></td></tr>
<tr class="separator:aa7085bb8610e51146c27d4f5b55d322e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06bbf0d05099cf4b363e283b35359df2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a06bbf0d05099cf4b363e283b35359df2"></a>
<a class="el" href="classVc_1_1SimdMaskArray.html">SimdMaskArray</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVc_1_1SimdMaskArray.html#a06bbf0d05099cf4b363e283b35359df2">operator^=</a> (const <a class="el" href="classVc_1_1SimdMaskArray.html">SimdMaskArray</a> &amp;rhs)</td></tr>
<tr class="memdesc:a06bbf0d05099cf4b363e283b35359df2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Modifies the mask using an <code>XOR</code> operation with <code>mask</code>. <br /></td></tr>
<tr class="separator:a06bbf0d05099cf4b363e283b35359df2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40539d4e9e343a175d9ad596d9f2f4c4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a40539d4e9e343a175d9ad596d9f2f4c4"></a>
<a class="el" href="classVc_1_1SimdMaskArray.html">SimdMaskArray</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVc_1_1SimdMaskArray.html#a40539d4e9e343a175d9ad596d9f2f4c4">operator&amp;</a> (const <a class="el" href="classVc_1_1SimdMaskArray.html">SimdMaskArray</a> &amp;rhs) const </td></tr>
<tr class="memdesc:a40539d4e9e343a175d9ad596d9f2f4c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the component-wise application of a binary <code>AND</code> to <code>mask</code>. <br /></td></tr>
<tr class="separator:a40539d4e9e343a175d9ad596d9f2f4c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56b047ee657e01784277033737fdcd23"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a56b047ee657e01784277033737fdcd23"></a>
<a class="el" href="classVc_1_1SimdMaskArray.html">SimdMaskArray</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVc_1_1SimdMaskArray.html#a56b047ee657e01784277033737fdcd23">operator|</a> (const <a class="el" href="classVc_1_1SimdMaskArray.html">SimdMaskArray</a> &amp;rhs) const </td></tr>
<tr class="memdesc:a56b047ee657e01784277033737fdcd23"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the component-wise application of a binary <code>OR</code> to <code>mask</code>. <br /></td></tr>
<tr class="separator:a56b047ee657e01784277033737fdcd23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ea1d560c87f837cdc33e7c456483145"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4ea1d560c87f837cdc33e7c456483145"></a>
<a class="el" href="classVc_1_1SimdMaskArray.html">SimdMaskArray</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVc_1_1SimdMaskArray.html#a4ea1d560c87f837cdc33e7c456483145">operator^</a> (const <a class="el" href="classVc_1_1SimdMaskArray.html">SimdMaskArray</a> &amp;rhs) const </td></tr>
<tr class="memdesc:a4ea1d560c87f837cdc33e7c456483145"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the component-wise application of a binary <code>XOR</code> to <code>mask</code>. <br /></td></tr>
<tr class="separator:a4ea1d560c87f837cdc33e7c456483145"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c427b2b469e158445460346e30b580c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4c427b2b469e158445460346e30b580c"></a>
<a class="el" href="classVc_1_1SimdMaskArray.html">SimdMaskArray</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVc_1_1SimdMaskArray.html#a4c427b2b469e158445460346e30b580c">operator&amp;&amp;</a> (const <a class="el" href="classVc_1_1SimdMaskArray.html">SimdMaskArray</a> &amp;rhs) const </td></tr>
<tr class="memdesc:a4c427b2b469e158445460346e30b580c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the component-wise application of a logical <code>AND</code> to <code>mask</code>. <br /></td></tr>
<tr class="separator:a4c427b2b469e158445460346e30b580c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19307a4e239ef9eb0cd81da3207394d3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a19307a4e239ef9eb0cd81da3207394d3"></a>
<a class="el" href="classVc_1_1SimdMaskArray.html">SimdMaskArray</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVc_1_1SimdMaskArray.html#a19307a4e239ef9eb0cd81da3207394d3">operator||</a> (const <a class="el" href="classVc_1_1SimdMaskArray.html">SimdMaskArray</a> &amp;rhs) const </td></tr>
<tr class="memdesc:a19307a4e239ef9eb0cd81da3207394d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the component-wise application of a logical <code>OR</code> to <code>mask</code>. <br /></td></tr>
<tr class="separator:a19307a4e239ef9eb0cd81da3207394d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ffe8a6212a0eb3fc7bbc8e9bc51dfcd"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7ffe8a6212a0eb3fc7bbc8e9bc51dfcd"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVc_1_1SimdMaskArray.html#a7ffe8a6212a0eb3fc7bbc8e9bc51dfcd">isFull</a> () const </td></tr>
<tr class="memdesc:a7ffe8a6212a0eb3fc7bbc8e9bc51dfcd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a logical <code>AND</code> of all components. <br /></td></tr>
<tr class="separator:a7ffe8a6212a0eb3fc7bbc8e9bc51dfcd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac568746e2ae1664e31c42d4762abd391"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac568746e2ae1664e31c42d4762abd391"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVc_1_1SimdMaskArray.html#ac568746e2ae1664e31c42d4762abd391">isNotEmpty</a> () const </td></tr>
<tr class="memdesc:ac568746e2ae1664e31c42d4762abd391"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a logical <code>OR</code> of all components. <br /></td></tr>
<tr class="separator:ac568746e2ae1664e31c42d4762abd391"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a479432127ee77145cc19d6a2d1590821"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a479432127ee77145cc19d6a2d1590821"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVc_1_1SimdMaskArray.html#a479432127ee77145cc19d6a2d1590821">isEmpty</a> () const </td></tr>
<tr class="memdesc:a479432127ee77145cc19d6a2d1590821"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>true</code> if components are <code>false</code>, <code>false</code> otherwise. <br /></td></tr>
<tr class="separator:a479432127ee77145cc19d6a2d1590821"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62c98c8dfec1d613c4852926e9b787e9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a62c98c8dfec1d613c4852926e9b787e9"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVc_1_1SimdMaskArray.html#a62c98c8dfec1d613c4852926e9b787e9">isMix</a> () const </td></tr>
<tr class="memdesc:a62c98c8dfec1d613c4852926e9b787e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>!isFull() &amp;&amp; !isEmpty()</code>. <br /></td></tr>
<tr class="separator:a62c98c8dfec1d613c4852926e9b787e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7a5586bcba0f228f5acb3b37ebae263"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVc_1_1SimdMaskArray.html#af7a5586bcba0f228f5acb3b37ebae263">toInt</a> () const </td></tr>
<tr class="memdesc:af7a5586bcba0f228f5acb3b37ebae263"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert the boolean components of the mask into bits of an integer.  <a href="#af7a5586bcba0f228f5acb3b37ebae263">More...</a><br /></td></tr>
<tr class="separator:af7a5586bcba0f228f5acb3b37ebae263"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9490a1dfe9ab280829a12edea2a858b"><td class="memItemLeft" align="right" valign="top">reference&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVc_1_1SimdMaskArray.html#ad9490a1dfe9ab280829a12edea2a858b">operator[]</a> (size_t index) noexcept</td></tr>
<tr class="memdesc:ad9490a1dfe9ab280829a12edea2a858b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a smart reference to the boolean element at index <code>index</code>.  <a href="#ad9490a1dfe9ab280829a12edea2a858b">More...</a><br /></td></tr>
<tr class="separator:ad9490a1dfe9ab280829a12edea2a858b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7941a8bfa6845a198bda7038a39e18f0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classVc_1_1SimdMaskArray.html#a1361e8e9cce10205928db7c5d49c76dc">value_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVc_1_1SimdMaskArray.html#a7941a8bfa6845a198bda7038a39e18f0">operator[]</a> (size_t index) const noexcept</td></tr>
<tr class="memdesc:a7941a8bfa6845a198bda7038a39e18f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a copy of the boolean element at index <code>index</code>.  <a href="#a7941a8bfa6845a198bda7038a39e18f0">More...</a><br /></td></tr>
<tr class="separator:a7941a8bfa6845a198bda7038a39e18f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0745638c9967e2ed90bc96c012288c55"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0745638c9967e2ed90bc96c012288c55"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVc_1_1SimdMaskArray.html#a0745638c9967e2ed90bc96c012288c55">count</a> () const </td></tr>
<tr class="memdesc:a0745638c9967e2ed90bc96c012288c55"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns how many components of the mask are <code>true</code>. <br /></td></tr>
<tr class="separator:a0745638c9967e2ed90bc96c012288c55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adafff7979b5d1d4924e5a4fb4365a5e6"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVc_1_1SimdMaskArray.html#adafff7979b5d1d4924e5a4fb4365a5e6">firstOne</a> () const </td></tr>
<tr class="memdesc:adafff7979b5d1d4924e5a4fb4365a5e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the index of the first one in the mask.  <a href="#adafff7979b5d1d4924e5a4fb4365a5e6">More...</a><br /></td></tr>
<tr class="separator:adafff7979b5d1d4924e5a4fb4365a5e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add79ba61aa7522e0d012b6b115da7080"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="add79ba61aa7522e0d012b6b115da7080"></a>
<a class="el" href="classVc_1_1SimdMaskArray.html">SimdMaskArray</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVc_1_1SimdMaskArray.html#add79ba61aa7522e0d012b6b115da7080">shifted</a> (int amount) const </td></tr>
<tr class="memdesc:add79ba61aa7522e0d012b6b115da7080"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a mask with components shifted by <code>amount</code> places. <br /></td></tr>
<tr class="separator:add79ba61aa7522e0d012b6b115da7080"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">new/delete overloads for correct alignment</div></td></tr>
<tr class="memitem:a205ed048fdf5259c2e8e0cb60ee8f719"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a205ed048fdf5259c2e8e0cb60ee8f719"></a>
void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVc_1_1SimdMaskArray.html#a205ed048fdf5259c2e8e0cb60ee8f719">operator new</a> (size_t <a class="el" href="classVc_1_1SimdMaskArray.html#a5e99fb015bfbc024a4b785135b34dee7">size</a>)</td></tr>
<tr class="memdesc:a205ed048fdf5259c2e8e0cb60ee8f719"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocates correctly aligned memory. <br /></td></tr>
<tr class="separator:a205ed048fdf5259c2e8e0cb60ee8f719"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a32ddebc54410cf59dec423c0b0791b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0a32ddebc54410cf59dec423c0b0791b"></a>
void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVc_1_1SimdMaskArray.html#a0a32ddebc54410cf59dec423c0b0791b">operator new</a> (size_t, void *p)</td></tr>
<tr class="memdesc:a0a32ddebc54410cf59dec423c0b0791b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>p</code>. <br /></td></tr>
<tr class="separator:a0a32ddebc54410cf59dec423c0b0791b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63ce4f64887b9307317aee5baae6b18f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a63ce4f64887b9307317aee5baae6b18f"></a>
void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVc_1_1SimdMaskArray.html#a63ce4f64887b9307317aee5baae6b18f">operator new[]</a> (size_t <a class="el" href="classVc_1_1SimdMaskArray.html#a5e99fb015bfbc024a4b785135b34dee7">size</a>)</td></tr>
<tr class="memdesc:a63ce4f64887b9307317aee5baae6b18f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocates correctly aligned memory. <br /></td></tr>
<tr class="separator:a63ce4f64887b9307317aee5baae6b18f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f5a0f061d65c77264411a2914503659"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7f5a0f061d65c77264411a2914503659"></a>
void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVc_1_1SimdMaskArray.html#a7f5a0f061d65c77264411a2914503659">operator new[]</a> (size_t, void *p)</td></tr>
<tr class="memdesc:a7f5a0f061d65c77264411a2914503659"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>p</code>. <br /></td></tr>
<tr class="separator:a7f5a0f061d65c77264411a2914503659"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22999735d5b1e1cb645614d22f108611"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a22999735d5b1e1cb645614d22f108611"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVc_1_1SimdMaskArray.html#a22999735d5b1e1cb645614d22f108611">operator delete</a> (void *ptr, size_t)</td></tr>
<tr class="memdesc:a22999735d5b1e1cb645614d22f108611"><td class="mdescLeft">&#160;</td><td class="mdescRight">Frees aligned memory. <br /></td></tr>
<tr class="separator:a22999735d5b1e1cb645614d22f108611"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41d83e8020f1d841b254be6ebeda92d2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a41d83e8020f1d841b254be6ebeda92d2"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVc_1_1SimdMaskArray.html#a41d83e8020f1d841b254be6ebeda92d2">operator delete</a> (void *, void *)</td></tr>
<tr class="memdesc:a41d83e8020f1d841b254be6ebeda92d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Does nothing. <br /></td></tr>
<tr class="separator:a41d83e8020f1d841b254be6ebeda92d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abefd12c9bd2fa9cd4a27cdabf64b03f8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abefd12c9bd2fa9cd4a27cdabf64b03f8"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVc_1_1SimdMaskArray.html#abefd12c9bd2fa9cd4a27cdabf64b03f8">operator delete[]</a> (void *ptr, size_t)</td></tr>
<tr class="memdesc:abefd12c9bd2fa9cd4a27cdabf64b03f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Frees aligned memory. <br /></td></tr>
<tr class="separator:abefd12c9bd2fa9cd4a27cdabf64b03f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afea8decef8f286c8d73c89a1a81d4555"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afea8decef8f286c8d73c89a1a81d4555"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVc_1_1SimdMaskArray.html#afea8decef8f286c8d73c89a1a81d4555">operator delete[]</a> (void *, void *)</td></tr>
<tr class="memdesc:afea8decef8f286c8d73c89a1a81d4555"><td class="mdescLeft">&#160;</td><td class="mdescRight">Does nothing. <br /></td></tr>
<tr class="separator:afea8decef8f286c8d73c89a1a81d4555"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Loads &amp; Stores</div></td></tr>
<tr class="memitem:a5b4dace4dd70d203e3304e8dbe6c1d2e"><td class="memTemplParams" colspan="2">template&lt;typename Flags  = DefaultLoadTag&gt; </td></tr>
<tr class="memitem:a5b4dace4dd70d203e3304e8dbe6c1d2e"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classVc_1_1SimdMaskArray.html#a5b4dace4dd70d203e3304e8dbe6c1d2e">SimdMaskArray</a> (const bool *mem, Flags f=Flags())</td></tr>
<tr class="memdesc:a5b4dace4dd70d203e3304e8dbe6c1d2e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load N boolean values from the consecutive addresses starting at <code>mem</code>.  <a href="#a5b4dace4dd70d203e3304e8dbe6c1d2e">More...</a><br /></td></tr>
<tr class="separator:a5b4dace4dd70d203e3304e8dbe6c1d2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a587a49eeafeaca6d87eddd82401a9770"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVc_1_1SimdMaskArray.html#a587a49eeafeaca6d87eddd82401a9770">load</a> (const bool *mem)</td></tr>
<tr class="memdesc:a587a49eeafeaca6d87eddd82401a9770"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load N boolean values from the consecutive addresses starting at <code>mem</code>.  <a href="#a587a49eeafeaca6d87eddd82401a9770">More...</a><br /></td></tr>
<tr class="separator:a587a49eeafeaca6d87eddd82401a9770"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abaa2275c0ae29230ea9131bd69a0b180"><td class="memTemplParams" colspan="2">template&lt;typename Flags &gt; </td></tr>
<tr class="memitem:abaa2275c0ae29230ea9131bd69a0b180"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classVc_1_1SimdMaskArray.html#abaa2275c0ae29230ea9131bd69a0b180">load</a> (const bool *mem, Flags f)</td></tr>
<tr class="memdesc:abaa2275c0ae29230ea9131bd69a0b180"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load N boolean values from the consecutive addresses starting at <code>mem</code>.  <a href="#abaa2275c0ae29230ea9131bd69a0b180">More...</a><br /></td></tr>
<tr class="separator:abaa2275c0ae29230ea9131bd69a0b180"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d92871e55fa3993d9e319ba5d17edba"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVc_1_1SimdMaskArray.html#a9d92871e55fa3993d9e319ba5d17edba">store</a> (bool *mem) const </td></tr>
<tr class="memdesc:a9d92871e55fa3993d9e319ba5d17edba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Store N boolean values to the consecutive addresses starting at <code>mem</code>.  <a href="#a9d92871e55fa3993d9e319ba5d17edba">More...</a><br /></td></tr>
<tr class="separator:a9d92871e55fa3993d9e319ba5d17edba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50cbd0d318d94b1c6f53d7603d9448f9"><td class="memTemplParams" colspan="2">template&lt;typename Flags &gt; </td></tr>
<tr class="memitem:a50cbd0d318d94b1c6f53d7603d9448f9"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classVc_1_1SimdMaskArray.html#a50cbd0d318d94b1c6f53d7603d9448f9">store</a> (bool *mem, Flags f) const </td></tr>
<tr class="memdesc:a50cbd0d318d94b1c6f53d7603d9448f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Store N boolean values to the consecutive addresses starting at <code>mem</code>.  <a href="#a50cbd0d318d94b1c6f53d7603d9448f9">More...</a><br /></td></tr>
<tr class="separator:a50cbd0d318d94b1c6f53d7603d9448f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a5e99fb015bfbc024a4b785135b34dee7"><td class="memItemLeft" align="right" valign="top">static constexpr std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVc_1_1SimdMaskArray.html#a5e99fb015bfbc024a4b785135b34dee7">size</a> ()</td></tr>
<tr class="memdesc:a5e99fb015bfbc024a4b785135b34dee7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of boolean components ( \(\mathcal{W}_\mathtt{T}\)) in a mask of this type.  <a href="#a5e99fb015bfbc024a4b785135b34dee7">More...</a><br /></td></tr>
<tr class="separator:a5e99fb015bfbc024a4b785135b34dee7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac86cfb582b96697d48de0fda624505b2"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classVc_1_1SimdMaskArray.html">SimdMaskArray</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVc_1_1SimdMaskArray.html#ac86cfb582b96697d48de0fda624505b2">Zero</a> ()</td></tr>
<tr class="memdesc:ac86cfb582b96697d48de0fda624505b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new mask object initialized to zero/<code>false</code>.  <a href="#ac86cfb582b96697d48de0fda624505b2">More...</a><br /></td></tr>
<tr class="separator:ac86cfb582b96697d48de0fda624505b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81cdcea5492655320443fd461bd5465d"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classVc_1_1SimdMaskArray.html">SimdMaskArray</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVc_1_1SimdMaskArray.html#a81cdcea5492655320443fd461bd5465d">One</a> ()</td></tr>
<tr class="memdesc:a81cdcea5492655320443fd461bd5465d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a mask object initialized to one/<code>true</code>.  <a href="#a81cdcea5492655320443fd461bd5465d">More...</a><br /></td></tr>
<tr class="separator:a81cdcea5492655320443fd461bd5465d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4e0cd3c613bb3dcedf7850e547e135a"><td class="memTemplParams" colspan="2"><a class="anchor" id="ae4e0cd3c613bb3dcedf7850e547e135a"></a>
template&lt;typename G &gt; </td></tr>
<tr class="memitem:ae4e0cd3c613bb3dcedf7850e547e135a"><td class="memTemplItemLeft" align="right" valign="top">static <a class="el" href="classVc_1_1SimdMaskArray.html">SimdMaskArray</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classVc_1_1SimdMaskArray.html#ae4e0cd3c613bb3dcedf7850e547e135a">generate</a> (const G &amp;gen)</td></tr>
<tr class="memdesc:ae4e0cd3c613bb3dcedf7850e547e135a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate a mask object from booleans returned from the function <code>gen</code>. <br /></td></tr>
<tr class="separator:ae4e0cd3c613bb3dcedf7850e547e135a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:gad550c4cd366024e9b37c4a7c7c9b96ff"><td class="memItemLeft" align="right" valign="top">static constexpr std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__SimdArray.html#gad550c4cd366024e9b37c4a7c7c9b96ff">Size</a> = <a class="el" href="classVc_1_1SimdMaskArray.html#a5e99fb015bfbc024a4b785135b34dee7">size</a>()</td></tr>
<tr class="memdesc:gad550c4cd366024e9b37c4a7c7c9b96ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of boolean components ( \(\mathcal{W}_\mathtt{T}\)) in a mask of this type.  <a href="group__SimdArray.html#gad550c4cd366024e9b37c4a7c7c9b96ff">More...</a><br /></td></tr>
<tr class="separator:gad550c4cd366024e9b37c4a7c7c9b96ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaac286912729d28478c8c9a1ac97a92ac"><td class="memItemLeft" align="right" valign="top">static constexpr std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__SimdArray.html#gaac286912729d28478c8c9a1ac97a92ac">MemoryAlignment</a></td></tr>
<tr class="memdesc:gaac286912729d28478c8c9a1ac97a92ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specifies the alignment requirement for aligned load and store calls for objects of this mask type.  <a href="group__SimdArray.html#gaac286912729d28478c8c9a1ac97a92ac">More...</a><br /></td></tr>
<tr class="separator:gaac286912729d28478c8c9a1ac97a92ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Member Typedef Documentation</h2>
<a class="anchor" id="a1361e8e9cce10205928db7c5d49c76dc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classVc_1_1SimdMaskArray.html#a1361e8e9cce10205928db7c5d49c76dc">value_type</a> =  typename <a class="el" href="classVc_1_1SimdMaskArray.html#ae01209df02a8750be9c3aca4728e056d">storage_type0::EntryType</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The <code>EntryType</code> of masks is always <code>bool</code>, independent of <code>T</code>. </p>

<p>Definition at line <a class="el" href="simdmaskarray_8h_source.html#l00340">340</a> of file <a class="el" href="simdmaskarray_8h_source.html">simdmaskarray.h</a>.</p>

</div>
</div>
<a class="anchor" id="a197e6d613393324683e71a9bbc4b1d36"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classVc_1_1SimdMaskArray.html#a197e6d613393324683e71a9bbc4b1d36">MaskType</a> =  <a class="el" href="classVc_1_1SimdMaskArray.html">mask_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct a zero-initialized vector object. </p>
<p>This constructor follows the behavior of the underlying <code>bool</code> type in that the expression <code>bool()</code> zero-initializes the object (to <code>false</code>). On the other hand the variable <code>x</code> in <code>bool x;</code> is uninitialized. Since, for class types, both expressions call the default constructor <code><a class="el" href="classVc_1_1Mask.html" title="The main SIMD mask class. ">Mask</a>&lt;T&gt; x</code> must zero-initialize <code>x</code> as well. </p>

<p>Definition at line <a class="el" href="simdmaskarray_8h_source.html#l00342">342</a> of file <a class="el" href="simdmaskarray_8h_source.html">simdmaskarray.h</a>.</p>

</div>
</div>
<a class="anchor" id="a54e5ed8e98d92aac3ac40647db1c17bf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classVc_1_1SimdMaskArray.html#a54e5ed8e98d92aac3ac40647db1c17bf">VectorEntryType</a> =  vectorentry_type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The <code>VectorEntryType</code>, in contrast to <code>EntryType</code>, reveals information about the SIMD implementation. </p>
<p>This type is useful for the <code>sizeof</code> operator in generic functions. </p>

<p>Definition at line <a class="el" href="simdmaskarray_8h_source.html#l00344">344</a> of file <a class="el" href="simdmaskarray_8h_source.html">simdmaskarray.h</a>.</p>

</div>
</div>
<a class="anchor" id="ae01209df02a8750be9c3aca4728e056d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classVc_1_1SimdMaskArray.html#ae01209df02a8750be9c3aca4728e056d">EntryType</a> =  <a class="el" href="classVc_1_1SimdMaskArray.html#a1361e8e9cce10205928db7c5d49c76dc">value_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The <code>EntryType</code> of masks is always <code>bool</code>, independent of <code>T</code>. </p>

<p>Definition at line <a class="el" href="simdmaskarray_8h_source.html#l00346">346</a> of file <a class="el" href="simdmaskarray_8h_source.html">simdmaskarray.h</a>.</p>

</div>
</div>
<a class="anchor" id="a841b1b3a66f9457f3161e9b171af29f4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classVc_1_1SimdMaskArray.html#a841b1b3a66f9457f3161e9b171af29f4">EntryReference</a> =  Vc::Detail::ElementReference&lt;<a class="el" href="classVc_1_1SimdMaskArray.html">SimdMaskArray</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The reference wrapper type used for accessing individual mask components. </p>

<p>Definition at line <a class="el" href="simdmaskarray_8h_source.html#l00348">348</a> of file <a class="el" href="simdmaskarray_8h_source.html">simdmaskarray.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="ac3726a8e8149927942c1a1dcee279597"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVc_1_1SimdMaskArray.html">SimdMaskArray</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct a zero-initialized vector object. </p>
<p>This constructor follows the behavior of the underlying <code>bool</code> type in that the expression <code>bool()</code> zero-initializes the object (to <code>false</code>). On the other hand the variable <code>x</code> in <code>bool x;</code> is uninitialized. Since, for class types, both expressions call the default constructor <code><a class="el" href="classVc_1_1Mask.html" title="The main SIMD mask class. ">Mask</a>&lt;T&gt; x</code> must zero-initialize <code>x</code> as well. </p>

</div>
</div>
<a class="anchor" id="a0558e628a2e7e2511b250e724a5a82bc"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVc_1_1SimdMaskArray.html">SimdMaskArray</a> </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>b</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Broadcast constructor. </p>
<p>Set all components of the new mask object to <code>b</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">b</td><td>Determines the initial state of the mask. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="simdmaskarray_8h_source.html#l00409">409</a> of file <a class="el" href="simdmaskarray_8h_source.html">simdmaskarray.h</a>.</p>

</div>
</div>
<a class="anchor" id="a5b4dace4dd70d203e3304e8dbe6c1d2e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVc_1_1SimdMaskArray.html">SimdMaskArray</a> </td>
          <td>(</td>
          <td class="paramtype">const bool *&#160;</td>
          <td class="paramname"><em>mem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Flags&#160;</td>
          <td class="paramname"><em>f</em> = <code>Flags()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Load N boolean values from the consecutive addresses starting at <code>mem</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mem</td><td>A pointer to an array of booleans. </td></tr>
    <tr><td class="paramname">f</td><td>A combination of flags to modify specific behavior of the load. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="simdmaskarray_8h_source.html#l00426">426</a> of file <a class="el" href="simdmaskarray_8h_source.html">simdmaskarray.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a5e99fb015bfbc024a4b785135b34dee7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr std::size_t size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of boolean components ( \(\mathcal{W}_\mathtt{T}\)) in a mask of this type. </p>
<p>The size of the mask. I.e. the number of boolean entries in the mask. Do not make any assumptions about the size of masks.</p>
<p>In addition, you can easily use if clauses that compare sizes. The compiler can statically evaluate and fully optimize dead code away (very much like #ifdef, but with syntax checking).</p>
<dl class="section return"><dt>Returns</dt><dd>The number of components (i.e. \(\mathcal{W}_\mathtt{T}\)) objects of this mask type store and manipulate. </dd></dl>

<p>Definition at line <a class="el" href="simdmaskarray_8h_source.html#l00326">326</a> of file <a class="el" href="simdmaskarray_8h_source.html">simdmaskarray.h</a>.</p>

</div>
</div>
<a class="anchor" id="ac86cfb582b96697d48de0fda624505b2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classVc_1_1SimdMaskArray.html">SimdMaskArray</a> Zero </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new mask object initialized to zero/<code>false</code>. </p>
<dl class="section return"><dt>Returns</dt><dd>A mask object with zero-initialized components. </dd></dl>

<p>Definition at line <a class="el" href="simdmaskarray_8h_source.html#l00412">412</a> of file <a class="el" href="simdmaskarray_8h_source.html">simdmaskarray.h</a>.</p>

</div>
</div>
<a class="anchor" id="a81cdcea5492655320443fd461bd5465d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classVc_1_1SimdMaskArray.html">SimdMaskArray</a> One </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a mask object initialized to one/<code>true</code>. </p>
<dl class="section return"><dt>Returns</dt><dd>A mask object with components initialized to <code>true</code>. </dd></dl>

<p>Definition at line <a class="el" href="simdmaskarray_8h_source.html#l00414">414</a> of file <a class="el" href="simdmaskarray_8h_source.html">simdmaskarray.h</a>.</p>

</div>
</div>
<a class="anchor" id="a587a49eeafeaca6d87eddd82401a9770"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void load </td>
          <td>(</td>
          <td class="paramtype">const bool *&#160;</td>
          <td class="paramname"><em>mem</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Load N boolean values from the consecutive addresses starting at <code>mem</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mem</td><td>A pointer to an array of booleans. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="simdmaskarray_8h_source.html#l00436">436</a> of file <a class="el" href="simdmaskarray_8h_source.html">simdmaskarray.h</a>.</p>

</div>
</div>
<a class="anchor" id="abaa2275c0ae29230ea9131bd69a0b180"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void load </td>
          <td>(</td>
          <td class="paramtype">const bool *&#160;</td>
          <td class="paramname"><em>mem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Flags&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Load N boolean values from the consecutive addresses starting at <code>mem</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mem</td><td>A pointer to an array of booleans. </td></tr>
    <tr><td class="paramname">f</td><td>A combination of flags to modify specific behavior of the load. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="simdmaskarray_8h_source.html#l00448">448</a> of file <a class="el" href="simdmaskarray_8h_source.html">simdmaskarray.h</a>.</p>

</div>
</div>
<a class="anchor" id="a9d92871e55fa3993d9e319ba5d17edba"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void store </td>
          <td>(</td>
          <td class="paramtype">bool *&#160;</td>
          <td class="paramname"><em>mem</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Store N boolean values to the consecutive addresses starting at <code>mem</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mem</td><td>A pointer to an array of booleans. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="simdmaskarray_8h_source.html#l00459">459</a> of file <a class="el" href="simdmaskarray_8h_source.html">simdmaskarray.h</a>.</p>

</div>
</div>
<a class="anchor" id="a50cbd0d318d94b1c6f53d7603d9448f9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void store </td>
          <td>(</td>
          <td class="paramtype">bool *&#160;</td>
          <td class="paramname"><em>mem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Flags&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Store N boolean values to the consecutive addresses starting at <code>mem</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mem</td><td>A pointer to an array of booleans. </td></tr>
    <tr><td class="paramname">f</td><td>A combination of flags to modify specific behavior of the load. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="simdmaskarray_8h_source.html#l00471">471</a> of file <a class="el" href="simdmaskarray_8h_source.html">simdmaskarray.h</a>.</p>

</div>
</div>
<a class="anchor" id="a79e163ca8f685a0e69494c6dfbae7015"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classVc_1_1SimdMaskArray.html">SimdMaskArray</a>&lt; T, N, V, Wt &gt; &amp;&#160;</td>
          <td class="paramname"><em>mask</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns whether the two masks are equal in all components. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mask</td><td>The other mask to compare against. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A scalar boolean value that says whether all components of the two masks are equal.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>If you expected a behavior similar to the compare operator of <a class="el" href="classVc_1_1Vector.html" title="The main vector class for expressing data parallelism. ">Vc::Vector</a>, consider that the bitwise operators already implement such functionality. There is little use, typically, in having <code>a == b</code> return the same as <code>a ^ b</code>. In general, it is more useful to query <code>all_of(a ^ b)</code> which is the same as this equality operator. </dd></dl>

<p>Definition at line <a class="el" href="simdmaskarray_8h_source.html#l00479">479</a> of file <a class="el" href="simdmaskarray_8h_source.html">simdmaskarray.h</a>.</p>

</div>
</div>
<a class="anchor" id="a1a80ae6f62487ae5dab5e51843528feb"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classVc_1_1SimdMaskArray.html#a24b3eaf2e8037bb616cc51c8a4a2bcf9">operator!</a>= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classVc_1_1SimdMaskArray.html">SimdMaskArray</a>&lt; T, N, V, Wt &gt; &amp;&#160;</td>
          <td class="paramname"><em>mask</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns whether the two masks are different in at least one component. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mask</td><td>The other mask to compare against. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A scalar boolean value that says whether at least one component of the two masks is different.</dd></dl>
<dl class="section note"><dt>Note</dt><dd><code>(a == b) == !(a != b)</code> holds </dd></dl>
<dl class="section see"><dt>See also</dt><dd>Mask::operator==(const Mask &amp;) </dd></dl>

<p>Definition at line <a class="el" href="simdmaskarray_8h_source.html#l00484">484</a> of file <a class="el" href="simdmaskarray_8h_source.html">simdmaskarray.h</a>.</p>

</div>
</div>
<a class="anchor" id="af7a5586bcba0f228f5acb3b37ebae263"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int toInt </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert the boolean components of the mask into bits of an integer. </p>
<dl class="section return"><dt>Returns</dt><dd>An <code>int</code> where each bit corresponds to the boolean value in the mask.</dd></dl>
<p>For example, the mask <code>[true, false, false, true]</code> results in a <code>9</code> (in binary: <code>1001</code>). </p>

<p>Definition at line <a class="el" href="simdmaskarray_8h_source.html#l00554">554</a> of file <a class="el" href="simdmaskarray_8h_source.html">simdmaskarray.h</a>.</p>

</div>
</div>
<a class="anchor" id="ad9490a1dfe9ab280829a12edea2a858b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">reference operator[] </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a smart reference to the boolean element at index <code>index</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The element index to be accessed.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A temporary smart reference object which acts as much as an lvalue reference as possible. </dd></dl>

<p>Definition at line <a class="el" href="simdmaskarray_8h_source.html#l00590">590</a> of file <a class="el" href="simdmaskarray_8h_source.html">simdmaskarray.h</a>.</p>

</div>
</div>
<a class="anchor" id="a7941a8bfa6845a198bda7038a39e18f0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVc_1_1SimdMaskArray.html#a1361e8e9cce10205928db7c5d49c76dc">value_type</a> operator[] </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a copy of the boolean element at index <code>index</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The element index to be accessed.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A temporary boolean object with the value of the element at index <code>index</code>. </dd></dl>

<p>Definition at line <a class="el" href="simdmaskarray_8h_source.html#l00602">602</a> of file <a class="el" href="simdmaskarray_8h_source.html">simdmaskarray.h</a>.</p>

</div>
</div>
<a class="anchor" id="adafff7979b5d1d4924e5a4fb4365a5e6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int firstOne </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the index of the first one in the mask. </p>
<dl class="section return"><dt>Returns</dt><dd>the index of the first component that is <code>true</code>.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>The return value is undefined if the mask is empty.</dd></dl>
<p>Thus, unless <code>none_of(mask)</code>, <code>mask[mask.firstOne()] == true</code> holds and <code>mask[i] == false</code> for all <code>i &lt; mask.firstOne()</code>. </p>

<p>Definition at line <a class="el" href="simdmaskarray_8h_source.html#l00611">611</a> of file <a class="el" href="simdmaskarray_8h_source.html">simdmaskarray.h</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>/home/mkretz/src/Vc-1.3/common/<a class="el" href="simdarrayfwd_8h_source.html">simdarrayfwd.h</a></li>
<li>/home/mkretz/src/Vc-1.3/common/<a class="el" href="simdmaskarray_8h_source.html">simdmaskarray.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespaceVc.html">Vc</a></li><li class="navelem"><a class="el" href="classVc_1_1SimdMaskArray.html">SimdMaskArray</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.11 </li>
  </ul>
</div>
</body>
</html>
