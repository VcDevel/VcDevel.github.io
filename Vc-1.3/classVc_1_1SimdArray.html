<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>Vc: SimdArray&lt; T, N, V, Wt &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() {
    if ($('.searchresults').length > 0) { searchBox.DOMSearchField().focus(); }
  });
</script>
<link rel="search" href="search_opensearch.php?v=opensearch.xml" type="application/opensearchdescription+xml" title="Vc"/>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo_small.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Vc
   &#160;<span id="projectnumber">1.3.3-dev</span>
   </div>
   <div id="projectbrief">SIMD Vector Classes for C++</div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
          <div class="left">
            <form id="FSearchBox" action="search.php" method="get">
              <img id="MSearchSelect" src="search/mag.png" alt=""/>
              <input type="text" id="MSearchField" name="query" value="Search" size="20" accesskey="S" 
                     onfocus="searchBox.OnSearchFieldFocus(true)" 
                     onblur="searchBox.OnSearchFieldFocus(false)"/>
            </form>
          </div><div class="right"></div>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('classVc_1_1SimdArray.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="classVc_1_1SimdArray-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">SimdArray&lt; T, N, V, Wt &gt; Class Template Reference<div class="ingroups"><a class="el" href="group__SimdArray.html">SIMD Array</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename T, size_t N, typename V, size_t Wt&gt;<br />
class Vc::SimdArray&lt; T, N, V, Wt &gt;</h3>

<p>Data-parallel arithmetic type with user-defined number of elements. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type of the vector's elements. The supported types currently are limited to the types supported by Vc::Vector&lt;T&gt;.</td></tr>
    <tr><td class="paramname">N</td><td>The number of elements to store and process concurrently. You can choose an arbitrary number, though not every number is a good idea. Generally, a power of two value or the sum of two power of two values might work efficiently, though this depends a lot on the target system.</td></tr>
    <tr><td class="paramname">V</td><td>Don't change the default value unless you really know what you are doing. This type is set to the underlying native <a class="el" href="classVc_1_1Vector.html" title="The main vector class for expressing data parallelism. ">Vc::Vector</a> type used in the implementation of the type. Having it as part of the type name guards against some cases of ODR violations (i.e. linking incompatible translation units / libraries).</td></tr>
    <tr><td class="paramname">Wt</td><td>Don't ever change the default value. This parameter is an unfortunate implementation detail shining through.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>Choosing <code>N</code> too large (what “too large” means depends on the target) will result in excessive compilation times and high (or too high) register pressure, thus potentially negating the improvement from concurrent execution. As a rule of thumb, keep <code>N</code> less or equal to <code>2 * <a class="el" href="classVc_1_1Vector.html#a1b5d7e2e663d7997796fd9f72b8af75a" title="Returns the number of scalar components ( ) in a vector of this type. ">float_v::size()</a></code>.</dd>
<dd>
A special portability concern arises from a current limitation in the MIC implementation (Intel Knights Corner), where <a class="el" href="classVc_1_1SimdArray.html" title="Data-parallel arithmetic type with user-defined number of elements. ">SimdArray</a> types with <code>T</code> = <code></code>(u)short require an <code>N</code> either less than <a class="el" href="classVc_1_1Vector.html#a1b5d7e2e663d7997796fd9f72b8af75a" title="Returns the number of scalar components ( ) in a vector of this type. ">short_v::size()</a> or a multiple of <a class="el" href="classVc_1_1Vector.html#a1b5d7e2e663d7997796fd9f72b8af75a" title="Returns the number of scalar components ( ) in a vector of this type. ">short_v::size()</a>. </dd></dl>

<p>Definition at line <a class="el" href="simdarray_8h_source.html#l00565">565</a> of file <a class="el" href="simdarray_8h_source.html">simdarray.h</a>.</p>
</div>
<p><code>#include &lt;<a class="el" href="simdarray_8h_source.html">Vc/SimdArray</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:afb9ded5f49336ae503bb9f2035ea902b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afb9ded5f49336ae503bb9f2035ea902b"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVc_1_1SimdArray.html#afb9ded5f49336ae503bb9f2035ea902b">value_type</a> = T</td></tr>
<tr class="memdesc:afb9ded5f49336ae503bb9f2035ea902b"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type of the elements (i.e. <code>T</code>) <br /></td></tr>
<tr class="separator:afb9ded5f49336ae503bb9f2035ea902b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa717de258d14cb1066a39ae88bc5d46c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa717de258d14cb1066a39ae88bc5d46c"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVc_1_1SimdArray.html#aa717de258d14cb1066a39ae88bc5d46c">mask_type</a> = <a class="el" href="classVc_1_1SimdMaskArray.html">SimdMaskArray</a>&lt; T, N, vector_type &gt;</td></tr>
<tr class="memdesc:aa717de258d14cb1066a39ae88bc5d46c"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type of the mask used for masked operations and returned from comparisons. <br /></td></tr>
<tr class="separator:aa717de258d14cb1066a39ae88bc5d46c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d2b0c15739451a17d861f9b3421e1c6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0d2b0c15739451a17d861f9b3421e1c6"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVc_1_1SimdArray.html#a0d2b0c15739451a17d861f9b3421e1c6">index_type</a> = <a class="el" href="classVc_1_1SimdArray.html">SimdArray</a>&lt; int, N &gt;</td></tr>
<tr class="memdesc:a0d2b0c15739451a17d861f9b3421e1c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type of the vector used for indexes in gather and scatter operations. <br /></td></tr>
<tr class="separator:a0d2b0c15739451a17d861f9b3421e1c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae18e3a1c00f24f46c0654059d58661a2"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVc_1_1SimdArray.html#ae18e3a1c00f24f46c0654059d58661a2">Mask</a> = <a class="el" href="classVc_1_1SimdArray.html#aa717de258d14cb1066a39ae88bc5d46c">mask_type</a></td></tr>
<tr class="memdesc:ae18e3a1c00f24f46c0654059d58661a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type of the mask used for masked operations and returned from comparisons.  <a href="#ae18e3a1c00f24f46c0654059d58661a2">More...</a><br /></td></tr>
<tr class="separator:ae18e3a1c00f24f46c0654059d58661a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2fd4547d07b041a214d9e5002ef0e7c2"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVc_1_1SimdArray.html#a2fd4547d07b041a214d9e5002ef0e7c2">MaskType</a> = <a class="el" href="classVc_1_1SimdArray.html#ae18e3a1c00f24f46c0654059d58661a2">Mask</a></td></tr>
<tr class="memdesc:a2fd4547d07b041a214d9e5002ef0e7c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type of the mask used for masked operations and returned from comparisons.  <a href="#a2fd4547d07b041a214d9e5002ef0e7c2">More...</a><br /></td></tr>
<tr class="separator:a2fd4547d07b041a214d9e5002ef0e7c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae01209df02a8750be9c3aca4728e056d"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVc_1_1SimdArray.html#ae01209df02a8750be9c3aca4728e056d">EntryType</a> = <a class="el" href="classVc_1_1SimdArray.html#afb9ded5f49336ae503bb9f2035ea902b">value_type</a></td></tr>
<tr class="memdesc:ae01209df02a8750be9c3aca4728e056d"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type of the elements (i.e. <code>T</code>)  <a href="#ae01209df02a8750be9c3aca4728e056d">More...</a><br /></td></tr>
<tr class="separator:ae01209df02a8750be9c3aca4728e056d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a205d97a77f849945d9d0b65835d68695"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVc_1_1SimdArray.html#a205d97a77f849945d9d0b65835d68695">IndexType</a> = <a class="el" href="classVc_1_1SimdArray.html#a0d2b0c15739451a17d861f9b3421e1c6">index_type</a></td></tr>
<tr class="memdesc:a205d97a77f849945d9d0b65835d68695"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type of the vector used for indexes in gather and scatter operations.  <a href="#a205d97a77f849945d9d0b65835d68695">More...</a><br /></td></tr>
<tr class="separator:a205d97a77f849945d9d0b65835d68695"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a6d8044f26c806a7624fa609bd012e17d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6d8044f26c806a7624fa609bd012e17d"></a>
<a class="el" href="classVc_1_1SimdArray.html">SimdArray</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVc_1_1SimdArray.html#a6d8044f26c806a7624fa609bd012e17d">operator+</a> () const </td></tr>
<tr class="memdesc:a6d8044f26c806a7624fa609bd012e17d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a copy of itself. <br /></td></tr>
<tr class="separator:a6d8044f26c806a7624fa609bd012e17d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d3569d32ca32737aa11b255cfb64a9f"><td class="memItemLeft" align="right" valign="top">Common::WriteMaskedVector&lt; <a class="el" href="classVc_1_1SimdArray.html">SimdArray</a>, <a class="el" href="classVc_1_1SimdArray.html#aa717de258d14cb1066a39ae88bc5d46c">mask_type</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVc_1_1SimdArray.html#a8d3569d32ca32737aa11b255cfb64a9f">operator()</a> (const <a class="el" href="classVc_1_1SimdArray.html#aa717de258d14cb1066a39ae88bc5d46c">mask_type</a> &amp;mask)</td></tr>
<tr class="memdesc:a8d3569d32ca32737aa11b255cfb64a9f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writemask the vector before an assignment.  <a href="#a8d3569d32ca32737aa11b255cfb64a9f">More...</a><br /></td></tr>
<tr class="separator:a8d3569d32ca32737aa11b255cfb64a9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca610da80443cef81a8fcbdce43915e9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aca610da80443cef81a8fcbdce43915e9"></a>
<a class="el" href="classVc_1_1SimdArray.html#afb9ded5f49336ae503bb9f2035ea902b">value_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVc_1_1SimdArray.html#aca610da80443cef81a8fcbdce43915e9">min</a> () const </td></tr>
<tr class="memdesc:aca610da80443cef81a8fcbdce43915e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the smallest entry in the vector. <br /></td></tr>
<tr class="separator:aca610da80443cef81a8fcbdce43915e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83d85150af2478ad02e2a86d99943f70"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a83d85150af2478ad02e2a86d99943f70"></a>
<a class="el" href="classVc_1_1SimdArray.html#afb9ded5f49336ae503bb9f2035ea902b">value_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVc_1_1SimdArray.html#a83d85150af2478ad02e2a86d99943f70">min</a> (const <a class="el" href="classVc_1_1SimdArray.html#aa717de258d14cb1066a39ae88bc5d46c">mask_type</a> &amp;mask) const </td></tr>
<tr class="memdesc:a83d85150af2478ad02e2a86d99943f70"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the smallest entry in the vector. <br /></td></tr>
<tr class="separator:a83d85150af2478ad02e2a86d99943f70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae82a2032fede908e4dbfada2c7df7293"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae82a2032fede908e4dbfada2c7df7293"></a>
<a class="el" href="classVc_1_1SimdArray.html#afb9ded5f49336ae503bb9f2035ea902b">value_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVc_1_1SimdArray.html#ae82a2032fede908e4dbfada2c7df7293">max</a> () const </td></tr>
<tr class="memdesc:ae82a2032fede908e4dbfada2c7df7293"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the largest entry in the vector. <br /></td></tr>
<tr class="separator:ae82a2032fede908e4dbfada2c7df7293"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ac753d686e6d1c3371d71d65906566f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9ac753d686e6d1c3371d71d65906566f"></a>
<a class="el" href="classVc_1_1SimdArray.html#afb9ded5f49336ae503bb9f2035ea902b">value_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVc_1_1SimdArray.html#a9ac753d686e6d1c3371d71d65906566f">max</a> (const <a class="el" href="classVc_1_1SimdArray.html#aa717de258d14cb1066a39ae88bc5d46c">mask_type</a> &amp;mask) const </td></tr>
<tr class="memdesc:a9ac753d686e6d1c3371d71d65906566f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the largest entry in the vector. <br /></td></tr>
<tr class="separator:a9ac753d686e6d1c3371d71d65906566f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac905e9d1859d1ee176ee8ff7bc376d8d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac905e9d1859d1ee176ee8ff7bc376d8d"></a>
<a class="el" href="classVc_1_1SimdArray.html#afb9ded5f49336ae503bb9f2035ea902b">value_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVc_1_1SimdArray.html#ac905e9d1859d1ee176ee8ff7bc376d8d">product</a> () const </td></tr>
<tr class="memdesc:ac905e9d1859d1ee176ee8ff7bc376d8d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the product of all entries in the vector. <br /></td></tr>
<tr class="separator:ac905e9d1859d1ee176ee8ff7bc376d8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adcea1af27dabe012ab46698a2ace268a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="adcea1af27dabe012ab46698a2ace268a"></a>
<a class="el" href="classVc_1_1SimdArray.html#afb9ded5f49336ae503bb9f2035ea902b">value_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVc_1_1SimdArray.html#adcea1af27dabe012ab46698a2ace268a">product</a> (const <a class="el" href="classVc_1_1SimdArray.html#aa717de258d14cb1066a39ae88bc5d46c">mask_type</a> &amp;mask) const </td></tr>
<tr class="memdesc:adcea1af27dabe012ab46698a2ace268a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the product of all entries in the vector. <br /></td></tr>
<tr class="separator:adcea1af27dabe012ab46698a2ace268a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc81b4eca2d60042e876c7de917d6316"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abc81b4eca2d60042e876c7de917d6316"></a>
<a class="el" href="classVc_1_1SimdArray.html#afb9ded5f49336ae503bb9f2035ea902b">value_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVc_1_1SimdArray.html#abc81b4eca2d60042e876c7de917d6316">sum</a> () const </td></tr>
<tr class="memdesc:abc81b4eca2d60042e876c7de917d6316"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the sum of all entries in the vector. <br /></td></tr>
<tr class="separator:abc81b4eca2d60042e876c7de917d6316"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a143b00493ef9f78d440e37a8f4775a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1a143b00493ef9f78d440e37a8f4775a"></a>
<a class="el" href="classVc_1_1SimdArray.html#afb9ded5f49336ae503bb9f2035ea902b">value_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVc_1_1SimdArray.html#a1a143b00493ef9f78d440e37a8f4775a">sum</a> (const <a class="el" href="classVc_1_1SimdArray.html#aa717de258d14cb1066a39ae88bc5d46c">mask_type</a> &amp;mask) const </td></tr>
<tr class="memdesc:a1a143b00493ef9f78d440e37a8f4775a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the sum of all entries in the vector. <br /></td></tr>
<tr class="separator:a1a143b00493ef9f78d440e37a8f4775a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78c731d249fd3742ad690411ee853ca8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a78c731d249fd3742ad690411ee853ca8"></a>
<a class="el" href="classVc_1_1SimdArray.html">SimdArray</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVc_1_1SimdArray.html#a78c731d249fd3742ad690411ee853ca8">partialSum</a> () const </td></tr>
<tr class="memdesc:a78c731d249fd3742ad690411ee853ca8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a vector containing the sum of all entries with smaller index. <br /></td></tr>
<tr class="separator:a78c731d249fd3742ad690411ee853ca8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8891146ec0cd51407b9865d09e3c350"><td class="memTemplParams" colspan="2"><a class="anchor" id="ac8891146ec0cd51407b9865d09e3c350"></a>
template&lt;typename F &gt; </td></tr>
<tr class="memitem:ac8891146ec0cd51407b9865d09e3c350"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classVc_1_1SimdArray.html">SimdArray</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classVc_1_1SimdArray.html#ac8891146ec0cd51407b9865d09e3c350">apply</a> (F &amp;&amp;f) const </td></tr>
<tr class="memdesc:ac8891146ec0cd51407b9865d09e3c350"><td class="mdescLeft">&#160;</td><td class="mdescRight">Call <code>f</code> on every entry of the vector and return the results as a new vector. <br /></td></tr>
<tr class="separator:ac8891146ec0cd51407b9865d09e3c350"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aadd44710e90d3ab730e1140ff6b61562"><td class="memTemplParams" colspan="2"><a class="anchor" id="aadd44710e90d3ab730e1140ff6b61562"></a>
template&lt;typename F &gt; </td></tr>
<tr class="memitem:aadd44710e90d3ab730e1140ff6b61562"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classVc_1_1SimdArray.html">SimdArray</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classVc_1_1SimdArray.html#aadd44710e90d3ab730e1140ff6b61562">apply</a> (F &amp;&amp;f, const <a class="el" href="classVc_1_1SimdArray.html#aa717de258d14cb1066a39ae88bc5d46c">mask_type</a> &amp;k) const </td></tr>
<tr class="memdesc:aadd44710e90d3ab730e1140ff6b61562"><td class="mdescLeft">&#160;</td><td class="mdescRight">As above, but skip the entries where <code>mask</code> is not set. <br /></td></tr>
<tr class="separator:aadd44710e90d3ab730e1140ff6b61562"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0fee4980a4974383fef5cdda2d45b32"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af0fee4980a4974383fef5cdda2d45b32"></a>
<a class="el" href="classVc_1_1SimdArray.html">SimdArray</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVc_1_1SimdArray.html#af0fee4980a4974383fef5cdda2d45b32">shifted</a> (int amount) const </td></tr>
<tr class="memdesc:af0fee4980a4974383fef5cdda2d45b32"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shift vector entries to the left by <code>amount</code>; shifting in zeros. <br /></td></tr>
<tr class="separator:af0fee4980a4974383fef5cdda2d45b32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8d79c7d76473d8c52a6decdad58d728"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae8d79c7d76473d8c52a6decdad58d728"></a>
<a class="el" href="classVc_1_1SimdArray.html">SimdArray</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVc_1_1SimdArray.html#ae8d79c7d76473d8c52a6decdad58d728">rotated</a> (int amount) const </td></tr>
<tr class="memdesc:ae8d79c7d76473d8c52a6decdad58d728"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rotate vector entries to the left by <code>amount</code>. <br /></td></tr>
<tr class="separator:ae8d79c7d76473d8c52a6decdad58d728"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6466c97a5cb1beb068aad71400b10329"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6466c97a5cb1beb068aad71400b10329"></a>
<a class="el" href="classVc_1_1SimdArray.html">SimdArray</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVc_1_1SimdArray.html#a6466c97a5cb1beb068aad71400b10329">reversed</a> () const </td></tr>
<tr class="memdesc:a6466c97a5cb1beb068aad71400b10329"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a vector with all components reversed. <br /></td></tr>
<tr class="separator:a6466c97a5cb1beb068aad71400b10329"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af31a30afa41408e7e5eb0ba6cea7190f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classVc_1_1SimdArray.html">SimdArray</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVc_1_1SimdArray.html#af31a30afa41408e7e5eb0ba6cea7190f">sorted</a> () const </td></tr>
<tr class="memdesc:af31a30afa41408e7e5eb0ba6cea7190f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a sorted copy of the vector.  <a href="#af31a30afa41408e7e5eb0ba6cea7190f">More...</a><br /></td></tr>
<tr class="separator:af31a30afa41408e7e5eb0ba6cea7190f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Compile-Time Constant Initialization</div></td></tr>
<tr class="memitem:a4e6a602addcee799029d068f57a86c35"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVc_1_1SimdArray.html#a4e6a602addcee799029d068f57a86c35">SimdArray</a> ()=default</td></tr>
<tr class="memdesc:a4e6a602addcee799029d068f57a86c35"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a zero-initialized vector object.  <a href="#a4e6a602addcee799029d068f57a86c35">More...</a><br /></td></tr>
<tr class="separator:a4e6a602addcee799029d068f57a86c35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Conversion/Broadcast Constructors</div></td></tr>
<tr class="memitem:a69376a62ae90b283578814162e1397cf"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVc_1_1SimdArray.html#a69376a62ae90b283578814162e1397cf">SimdArray</a> (<a class="el" href="classVc_1_1SimdArray.html#afb9ded5f49336ae503bb9f2035ea902b">value_type</a> a)</td></tr>
<tr class="memdesc:a69376a62ae90b283578814162e1397cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Broadcast Constructor.  <a href="#a69376a62ae90b283578814162e1397cf">More...</a><br /></td></tr>
<tr class="separator:a69376a62ae90b283578814162e1397cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a234beb8aabf5250ca1e815abdb55ab"><td class="memTemplParams" colspan="2"><a class="anchor" id="a0a234beb8aabf5250ca1e815abdb55ab"></a>
template&lt;typename U , typename  = enable_if&lt;std::is_same&lt;U, int&gt;::value &amp;&amp; !std::is_same&lt;int, value_type&gt;::value&gt;&gt; </td></tr>
<tr class="memitem:a0a234beb8aabf5250ca1e815abdb55ab"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><b>SimdArray</b> (U a)</td></tr>
<tr class="separator:a0a234beb8aabf5250ca1e815abdb55ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Gather constructors and member functions</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>Constructs or loads a vector from the objects at <code>mem[indexes[0]]</code>, <code>mem[indexes[1]]</code>, <code>mem[indexes[2]]</code>, ...</p>
<p>All gather functions optionally take a mask as last argument. In that case only the entries that are selected in the mask are accessed in memory and copied to the vector. This enables invalid indexes in the <code>indexes</code> vector if those are masked off in <code>mask</code>.</p>
<p>Gathers from structured data (AoS: arrays of struct) are possible via a special subscript operator of the container (array). You can use <a class="el" href="structVc_1_1array.html">Vc::array</a> and <a class="el" href="group__Containers.html#gac1ffd8b29c356abdbb821a7854c53b07">Vc::vector</a> as drop-in replacements for <code>std::array</code> and <code>std::vector</code>. These container classes contain the necessary subscript operator overload. Example: </p><div class="fragment"><div class="line"><a class="code" href="group__Containers.html#gac1ffd8b29c356abdbb821a7854c53b07">Vc::vector&lt;float&gt;</a> data(100);</div><div class="line">std::iota(data.begin(), data.end(), 0.f);  <span class="comment">// fill with values 0, 1, 2, ...</span></div><div class="line"><span class="keyword">auto</span> indexes = <a class="code" href="classVc_1_1SimdArray.html#a804229aa4eea8ed7572b273bba0530cd">float_v::IndexType::IndexesFromZero</a>();</div><div class="line"><a class="code" href="group__Vectors.html#ga5cf7c5a0dadbbbbcb9b69c5e42ee0528">float_v</a> gathered = data[indexes];  <span class="comment">// gathered == [0, 1, 2, ...]</span></div></div><!-- fragment --><p>This also works for gathers into arrays of structures: </p><div class="fragment"><div class="line"><span class="keyword">struct </span>Point { <span class="keywordtype">float</span> x, y, z; };</div><div class="line"><a class="code" href="structVc_1_1array.html">Vc::array&lt;Point, 100&gt;</a> points;</div><div class="line"><span class="comment">// fill points ...</span></div><div class="line"><span class="keyword">auto</span> indexes = <a class="code" href="classVc_1_1SimdArray.html#a804229aa4eea8ed7572b273bba0530cd">float_v::IndexType::IndexesFromZero</a>();</div><div class="line"><a class="code" href="group__Vectors.html#ga5cf7c5a0dadbbbbcb9b69c5e42ee0528">float_v</a> xs = data[indexes][&amp;Point::x];  <span class="comment">// [points[0].x, points[1].x, points[2].x, ...]</span></div><div class="line"><a class="code" href="group__Vectors.html#ga5cf7c5a0dadbbbbcb9b69c5e42ee0528">float_v</a> ys = data[indexes][&amp;Point::y];  <span class="comment">// [points[0].y, points[1].y, points[2].y, ...]</span></div><div class="line"><a class="code" href="group__Vectors.html#ga5cf7c5a0dadbbbbcb9b69c5e42ee0528">float_v</a> zs = data[indexes][&amp;Point::z];  <span class="comment">// [points[0].z, points[1].z, points[2].z, ...]</span></div></div><!-- fragment --><p>Alternatively, you can use Vc::Common::AdaptSubscriptOperator to extend a given container class with the necessary subscript operator. Example: </p><div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> Allocator = std::allocator&lt;T&gt;&gt;</div><div class="line"><span class="keyword">using</span> my_vector = Vc::Common::AdaptSubscriptOperator&lt;std::vector&lt;T, Allocator&gt;&gt;;</div></div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mem</td><td>A pointer to memory which contains objects of type <code>MT</code> at the offsets given by <code>indexes</code>. </td></tr>
    <tr><td class="paramname">indexes</td><td>A container/vector of offsets into <code>mem</code>. The type of <code>indexes</code> (<code>IT</code>) may either be a pointer to integers (C-array) or a vector of integers (preferrably IndexType). </td></tr>
    <tr><td class="paramname">mask</td><td>If a mask is given, only the active entries will be copied from memory.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>If you use a masked gather constructor the masked-off entries of the vector are zero-initilized. </dd></dl>
</div></td></tr>
<tr class="memitem:a5ea555c7c5627e0db2eb841f32481c4f"><td class="memTemplParams" colspan="2"><a class="anchor" id="a5ea555c7c5627e0db2eb841f32481c4f"></a>
template&lt;typename MT , typename IT , typename  = enable_if&lt;Traits::has_subscript_operator&lt;IT&gt;::value&gt;&gt; </td></tr>
<tr class="memitem:a5ea555c7c5627e0db2eb841f32481c4f"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classVc_1_1SimdArray.html#a5ea555c7c5627e0db2eb841f32481c4f">SimdArray</a> (const MT *mem, const IT &amp;indexes)</td></tr>
<tr class="memdesc:a5ea555c7c5627e0db2eb841f32481c4f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gather constructor. <br /></td></tr>
<tr class="separator:a5ea555c7c5627e0db2eb841f32481c4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a216f50fdbe325e15fc883e05b4e4a23c"><td class="memTemplParams" colspan="2"><a class="anchor" id="a216f50fdbe325e15fc883e05b4e4a23c"></a>
template&lt;typename MT , typename IT , typename  = enable_if&lt;Vc::Traits::has_subscript_operator&lt;IT&gt;::value&gt;&gt; </td></tr>
<tr class="memitem:a216f50fdbe325e15fc883e05b4e4a23c"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classVc_1_1SimdArray.html#a216f50fdbe325e15fc883e05b4e4a23c">SimdArray</a> (const MT *mem, const IT &amp;indexes, <a class="el" href="classVc_1_1SimdMaskArray.html">MaskArgument</a> mask)</td></tr>
<tr class="memdesc:a216f50fdbe325e15fc883e05b4e4a23c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Masked gather constructor. <br /></td></tr>
<tr class="separator:a216f50fdbe325e15fc883e05b4e4a23c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a813cc1dd2aba6d72c0b7dfbda1a898f4"><td class="memTemplParams" colspan="2"><a class="anchor" id="a813cc1dd2aba6d72c0b7dfbda1a898f4"></a>
template&lt;typename MT , typename IT , typename  = enable_if&lt;Vc::Traits::has_subscript_operator&lt;IT&gt;::value&gt;&gt; </td></tr>
<tr class="memitem:a813cc1dd2aba6d72c0b7dfbda1a898f4"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classVc_1_1SimdArray.html#a813cc1dd2aba6d72c0b7dfbda1a898f4">gather</a> (const MT *mem, const IT &amp;indexes)</td></tr>
<tr class="memdesc:a813cc1dd2aba6d72c0b7dfbda1a898f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gather function. <br /></td></tr>
<tr class="separator:a813cc1dd2aba6d72c0b7dfbda1a898f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbacca4066818dbf627e6a848b927cb7"><td class="memTemplParams" colspan="2"><a class="anchor" id="acbacca4066818dbf627e6a848b927cb7"></a>
template&lt;typename MT , typename IT , typename  = enable_if&lt;Vc::Traits::has_subscript_operator&lt;IT&gt;::value&gt;&gt; </td></tr>
<tr class="memitem:acbacca4066818dbf627e6a848b927cb7"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classVc_1_1SimdArray.html#acbacca4066818dbf627e6a848b927cb7">gather</a> (const MT *mem, const IT &amp;indexes, <a class="el" href="classVc_1_1SimdMaskArray.html">MaskArgument</a> mask)</td></tr>
<tr class="memdesc:acbacca4066818dbf627e6a848b927cb7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Masked gather function. <br /></td></tr>
<tr class="separator:acbacca4066818dbf627e6a848b927cb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr><td colspan="2"><div class="groupHeader">Scatter functions</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>Stores a vector to the objects at <code>mem[indexes[0]]</code>, <code>mem[indexes[1]]</code>, <code>mem[indexes[2]]</code>, ...</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mem</td><td>A pointer to memory which contains objects of type <code>MT</code> at the offsets given by <code>indexes</code>. </td></tr>
    <tr><td class="paramname">indexes</td><td></td></tr>
    <tr><td class="paramname">mask</td><td></td></tr>
  </table>
  </dd>
</dl>
</div></td></tr>
<tr class="memitem:af242f4f4405b3437d33ce2e30802c5dc"><td class="memTemplParams" colspan="2"><a class="anchor" id="af242f4f4405b3437d33ce2e30802c5dc"></a>
template&lt;typename MT , typename IT , typename  = enable_if&lt;Vc::Traits::has_subscript_operator&lt;IT&gt;::value&gt;&gt; </td></tr>
<tr class="memitem:af242f4f4405b3437d33ce2e30802c5dc"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classVc_1_1SimdArray.html#af242f4f4405b3437d33ce2e30802c5dc">scatter</a> (MT *mem, IT &amp;&amp;indexes) const </td></tr>
<tr class="memdesc:af242f4f4405b3437d33ce2e30802c5dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scatter function. <br /></td></tr>
<tr class="separator:af242f4f4405b3437d33ce2e30802c5dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af94152b2dbbdee91bb3ebb434adb34b6"><td class="memTemplParams" colspan="2"><a class="anchor" id="af94152b2dbbdee91bb3ebb434adb34b6"></a>
template&lt;typename MT , typename IT , typename  = enable_if&lt;Vc::Traits::has_subscript_operator&lt;IT&gt;::value&gt;&gt; </td></tr>
<tr class="memitem:af94152b2dbbdee91bb3ebb434adb34b6"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classVc_1_1SimdArray.html#af94152b2dbbdee91bb3ebb434adb34b6">scatter</a> (MT *mem, IT &amp;&amp;indexes, <a class="el" href="classVc_1_1SimdMaskArray.html">MaskArgument</a> mask) const </td></tr>
<tr class="memdesc:af94152b2dbbdee91bb3ebb434adb34b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Masked scatter function. <br /></td></tr>
<tr class="separator:af94152b2dbbdee91bb3ebb434adb34b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr><td colspan="2"><div class="groupHeader">new/delete overloads for correct alignment</div></td></tr>
<tr class="memitem:a205ed048fdf5259c2e8e0cb60ee8f719"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a205ed048fdf5259c2e8e0cb60ee8f719"></a>
void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVc_1_1SimdArray.html#a205ed048fdf5259c2e8e0cb60ee8f719">operator new</a> (size_t <a class="el" href="classVc_1_1SimdArray.html#a5e99fb015bfbc024a4b785135b34dee7">size</a>)</td></tr>
<tr class="memdesc:a205ed048fdf5259c2e8e0cb60ee8f719"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocates correctly aligned memory. <br /></td></tr>
<tr class="separator:a205ed048fdf5259c2e8e0cb60ee8f719"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a32ddebc54410cf59dec423c0b0791b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0a32ddebc54410cf59dec423c0b0791b"></a>
void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVc_1_1SimdArray.html#a0a32ddebc54410cf59dec423c0b0791b">operator new</a> (size_t, void *p)</td></tr>
<tr class="memdesc:a0a32ddebc54410cf59dec423c0b0791b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>p</code>. <br /></td></tr>
<tr class="separator:a0a32ddebc54410cf59dec423c0b0791b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63ce4f64887b9307317aee5baae6b18f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a63ce4f64887b9307317aee5baae6b18f"></a>
void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVc_1_1SimdArray.html#a63ce4f64887b9307317aee5baae6b18f">operator new[]</a> (size_t <a class="el" href="classVc_1_1SimdArray.html#a5e99fb015bfbc024a4b785135b34dee7">size</a>)</td></tr>
<tr class="memdesc:a63ce4f64887b9307317aee5baae6b18f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocates correctly aligned memory. <br /></td></tr>
<tr class="separator:a63ce4f64887b9307317aee5baae6b18f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f5a0f061d65c77264411a2914503659"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7f5a0f061d65c77264411a2914503659"></a>
void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVc_1_1SimdArray.html#a7f5a0f061d65c77264411a2914503659">operator new[]</a> (size_t, void *p)</td></tr>
<tr class="memdesc:a7f5a0f061d65c77264411a2914503659"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>p</code>. <br /></td></tr>
<tr class="separator:a7f5a0f061d65c77264411a2914503659"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22999735d5b1e1cb645614d22f108611"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a22999735d5b1e1cb645614d22f108611"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVc_1_1SimdArray.html#a22999735d5b1e1cb645614d22f108611">operator delete</a> (void *ptr, size_t)</td></tr>
<tr class="memdesc:a22999735d5b1e1cb645614d22f108611"><td class="mdescLeft">&#160;</td><td class="mdescRight">Frees aligned memory. <br /></td></tr>
<tr class="separator:a22999735d5b1e1cb645614d22f108611"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41d83e8020f1d841b254be6ebeda92d2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a41d83e8020f1d841b254be6ebeda92d2"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVc_1_1SimdArray.html#a41d83e8020f1d841b254be6ebeda92d2">operator delete</a> (void *, void *)</td></tr>
<tr class="memdesc:a41d83e8020f1d841b254be6ebeda92d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Does nothing. <br /></td></tr>
<tr class="separator:a41d83e8020f1d841b254be6ebeda92d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abefd12c9bd2fa9cd4a27cdabf64b03f8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abefd12c9bd2fa9cd4a27cdabf64b03f8"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVc_1_1SimdArray.html#abefd12c9bd2fa9cd4a27cdabf64b03f8">operator delete[]</a> (void *ptr, size_t)</td></tr>
<tr class="memdesc:abefd12c9bd2fa9cd4a27cdabf64b03f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Frees aligned memory. <br /></td></tr>
<tr class="separator:abefd12c9bd2fa9cd4a27cdabf64b03f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afea8decef8f286c8d73c89a1a81d4555"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afea8decef8f286c8d73c89a1a81d4555"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVc_1_1SimdArray.html#afea8decef8f286c8d73c89a1a81d4555">operator delete[]</a> (void *, void *)</td></tr>
<tr class="memdesc:afea8decef8f286c8d73c89a1a81d4555"><td class="mdescLeft">&#160;</td><td class="mdescRight">Does nothing. <br /></td></tr>
<tr class="separator:afea8decef8f286c8d73c89a1a81d4555"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a5e99fb015bfbc024a4b785135b34dee7"><td class="memItemLeft" align="right" valign="top">static constexpr std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVc_1_1SimdArray.html#a5e99fb015bfbc024a4b785135b34dee7">size</a> ()</td></tr>
<tr class="memdesc:a5e99fb015bfbc024a4b785135b34dee7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>N</code>, the number of scalar components in an object of this type.  <a href="#a5e99fb015bfbc024a4b785135b34dee7">More...</a><br /></td></tr>
<tr class="separator:a5e99fb015bfbc024a4b785135b34dee7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Generators</div></td></tr>
<tr class="memitem:af0c577fa32a998def623fc07d0e0199b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af0c577fa32a998def623fc07d0e0199b"></a>
static <a class="el" href="classVc_1_1SimdArray.html">SimdArray</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVc_1_1SimdArray.html#af0c577fa32a998def623fc07d0e0199b">Zero</a> ()</td></tr>
<tr class="memdesc:af0c577fa32a998def623fc07d0e0199b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a vector with the entries initialized to zero. <br /></td></tr>
<tr class="separator:af0c577fa32a998def623fc07d0e0199b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0abee757378e083ad161f05fcff3bd5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa0abee757378e083ad161f05fcff3bd5"></a>
static <a class="el" href="classVc_1_1SimdArray.html">SimdArray</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVc_1_1SimdArray.html#aa0abee757378e083ad161f05fcff3bd5">One</a> ()</td></tr>
<tr class="memdesc:aa0abee757378e083ad161f05fcff3bd5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a vector with the entries initialized to one. <br /></td></tr>
<tr class="separator:aa0abee757378e083ad161f05fcff3bd5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a804229aa4eea8ed7572b273bba0530cd"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a804229aa4eea8ed7572b273bba0530cd"></a>
static <a class="el" href="classVc_1_1SimdArray.html">SimdArray</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVc_1_1SimdArray.html#a804229aa4eea8ed7572b273bba0530cd">IndexesFromZero</a> ()</td></tr>
<tr class="memdesc:a804229aa4eea8ed7572b273bba0530cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a vector with the entries initialized to 0, 1, 2, 3, 4, 5, ... <br /></td></tr>
<tr class="separator:a804229aa4eea8ed7572b273bba0530cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af892f831b3d8ac2fa6adce4f1eb989d0"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classVc_1_1SimdArray.html">SimdArray</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVc_1_1SimdArray.html#af892f831b3d8ac2fa6adce4f1eb989d0">Random</a> ()</td></tr>
<tr class="memdesc:af892f831b3d8ac2fa6adce4f1eb989d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a vector with pseudo-random entries.  <a href="#af892f831b3d8ac2fa6adce4f1eb989d0">More...</a><br /></td></tr>
<tr class="separator:af892f831b3d8ac2fa6adce4f1eb989d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65b1fdc49a72aec22df1766171c2ca6a"><td class="memTemplParams" colspan="2"><a class="anchor" id="a65b1fdc49a72aec22df1766171c2ca6a"></a>
template&lt;typename G &gt; </td></tr>
<tr class="memitem:a65b1fdc49a72aec22df1766171c2ca6a"><td class="memTemplItemLeft" align="right" valign="top">static <a class="el" href="classVc_1_1SimdArray.html">SimdArray</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classVc_1_1SimdArray.html#a65b1fdc49a72aec22df1766171c2ca6a">generate</a> (const G &amp;gen)</td></tr>
<tr class="memdesc:a65b1fdc49a72aec22df1766171c2ca6a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate a vector object from return values of <code>gen</code> (static variant of fill). <br /></td></tr>
<tr class="separator:a65b1fdc49a72aec22df1766171c2ca6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:gaac286912729d28478c8c9a1ac97a92ac"><td class="memItemLeft" align="right" valign="top">static constexpr std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__SimdArray.html#gaac286912729d28478c8c9a1ac97a92ac">MemoryAlignment</a></td></tr>
<tr class="memdesc:gaac286912729d28478c8c9a1ac97a92ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specifies the alignment requirement for aligned load and store calls for objects of this vector type.  <a href="group__SimdArray.html#gaac286912729d28478c8c9a1ac97a92ac">More...</a><br /></td></tr>
<tr class="separator:gaac286912729d28478c8c9a1ac97a92ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Deprecated Members</h2></td></tr>
<tr class="memitem:gad550c4cd366024e9b37c4a7c7c9b96ff"><td class="memItemLeft" align="right" valign="top">static constexpr std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__SimdArray.html#gad550c4cd366024e9b37c4a7c7c9b96ff">Size</a> = <a class="el" href="classVc_1_1SimdArray.html#a5e99fb015bfbc024a4b785135b34dee7">size</a>()</td></tr>
<tr class="memdesc:gad550c4cd366024e9b37c4a7c7c9b96ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>N</code>, the number of scalar components in an object of this type.  <a href="group__SimdArray.html#gad550c4cd366024e9b37c4a7c7c9b96ff">More...</a><br /></td></tr>
<tr class="separator:gad550c4cd366024e9b37c4a7c7c9b96ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3de056fda26c77742725100047767e6e"><td class="memTemplParams" colspan="2">template&lt;typename S1 , typename IT &gt; </td></tr>
<tr class="memitem:ga3de056fda26c77742725100047767e6e"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__SimdArray.html#ga3de056fda26c77742725100047767e6e">SimdArray</a> (const S1 *<a class="el" href="structVc_1_1array.html">array</a>, const <a class="el" href="classVc_1_1SimdArray.html#ae01209df02a8750be9c3aca4728e056d">EntryType</a> S1::*member1, IT indexes)</td></tr>
<tr class="separator:ga3de056fda26c77742725100047767e6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf1967c386a5653e59699851822dd02ba"><td class="memTemplParams" colspan="2">template&lt;typename S1 , typename IT &gt; </td></tr>
<tr class="memitem:gaf1967c386a5653e59699851822dd02ba"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__SimdArray.html#gaf1967c386a5653e59699851822dd02ba">SimdArray</a> (const S1 *<a class="el" href="structVc_1_1array.html">array</a>, const <a class="el" href="classVc_1_1SimdArray.html#ae01209df02a8750be9c3aca4728e056d">EntryType</a> S1::*member1, IT indexes, <a class="el" href="classVc_1_1SimdMaskArray.html">MaskArgument</a> mask)</td></tr>
<tr class="separator:gaf1967c386a5653e59699851822dd02ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3bb6110edd007d19a3aa32767a24e5fc"><td class="memTemplParams" colspan="2">template&lt;typename S1 , typename S2 , typename IT &gt; </td></tr>
<tr class="memitem:ga3bb6110edd007d19a3aa32767a24e5fc"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__SimdArray.html#ga3bb6110edd007d19a3aa32767a24e5fc">SimdArray</a> (const S1 *<a class="el" href="structVc_1_1array.html">array</a>, const S2 S1::*member1, const <a class="el" href="classVc_1_1SimdArray.html#ae01209df02a8750be9c3aca4728e056d">EntryType</a> S2::*member2, IT indexes)</td></tr>
<tr class="separator:ga3bb6110edd007d19a3aa32767a24e5fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga35f362070fbb57c4c1b3c974e6aead27"><td class="memTemplParams" colspan="2">template&lt;typename S1 , typename S2 , typename IT &gt; </td></tr>
<tr class="memitem:ga35f362070fbb57c4c1b3c974e6aead27"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__SimdArray.html#ga35f362070fbb57c4c1b3c974e6aead27">SimdArray</a> (const S1 *<a class="el" href="structVc_1_1array.html">array</a>, const S2 S1::*member1, const <a class="el" href="classVc_1_1SimdArray.html#ae01209df02a8750be9c3aca4728e056d">EntryType</a> S2::*member2, IT indexes, <a class="el" href="classVc_1_1SimdMaskArray.html">MaskArgument</a> mask)</td></tr>
<tr class="separator:ga35f362070fbb57c4c1b3c974e6aead27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9834c282b56feb17fda8550c5cea59d8"><td class="memTemplParams" colspan="2">template&lt;typename S1 , typename IT1 , typename IT2 &gt; </td></tr>
<tr class="memitem:ga9834c282b56feb17fda8550c5cea59d8"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__SimdArray.html#ga9834c282b56feb17fda8550c5cea59d8">SimdArray</a> (const S1 *<a class="el" href="structVc_1_1array.html">array</a>, const <a class="el" href="classVc_1_1SimdArray.html#ae01209df02a8750be9c3aca4728e056d">EntryType</a> *const S1::*ptrMember1, IT1 outerIndexes, IT2 innerIndexes)</td></tr>
<tr class="separator:ga9834c282b56feb17fda8550c5cea59d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaacef2e9e3989d89943f0d51d2188010f"><td class="memTemplParams" colspan="2">template&lt;typename S1 , typename IT1 , typename IT2 &gt; </td></tr>
<tr class="memitem:gaacef2e9e3989d89943f0d51d2188010f"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__SimdArray.html#gaacef2e9e3989d89943f0d51d2188010f">SimdArray</a> (const S1 *<a class="el" href="structVc_1_1array.html">array</a>, const <a class="el" href="classVc_1_1SimdArray.html#ae01209df02a8750be9c3aca4728e056d">EntryType</a> *const S1::*ptrMember1, IT1 outerIndexes, IT2 innerIndexes, <a class="el" href="classVc_1_1SimdMaskArray.html">MaskArgument</a> mask)</td></tr>
<tr class="separator:gaacef2e9e3989d89943f0d51d2188010f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga74678fe3f7c4925bd19b5674fcac3ec2"><td class="memTemplParams" colspan="2">template&lt;typename S1 , typename IT &gt; </td></tr>
<tr class="memitem:ga74678fe3f7c4925bd19b5674fcac3ec2"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__SimdArray.html#ga74678fe3f7c4925bd19b5674fcac3ec2">gather</a> (const S1 *<a class="el" href="structVc_1_1array.html">array</a>, const <a class="el" href="classVc_1_1SimdArray.html#ae01209df02a8750be9c3aca4728e056d">EntryType</a> S1::*member1, IT indexes)</td></tr>
<tr class="separator:ga74678fe3f7c4925bd19b5674fcac3ec2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga41aec2586ff985e863c78803d11d2306"><td class="memTemplParams" colspan="2">template&lt;typename S1 , typename IT &gt; </td></tr>
<tr class="memitem:ga41aec2586ff985e863c78803d11d2306"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__SimdArray.html#ga41aec2586ff985e863c78803d11d2306">gather</a> (const S1 *<a class="el" href="structVc_1_1array.html">array</a>, const <a class="el" href="classVc_1_1SimdArray.html#ae01209df02a8750be9c3aca4728e056d">EntryType</a> S1::*member1, IT indexes, <a class="el" href="classVc_1_1SimdMaskArray.html">MaskArgument</a> mask)</td></tr>
<tr class="separator:ga41aec2586ff985e863c78803d11d2306"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab7e0e744bbf8112abc60707ec35782ac"><td class="memTemplParams" colspan="2">template&lt;typename S1 , typename S2 , typename IT &gt; </td></tr>
<tr class="memitem:gab7e0e744bbf8112abc60707ec35782ac"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__SimdArray.html#gab7e0e744bbf8112abc60707ec35782ac">gather</a> (const S1 *<a class="el" href="structVc_1_1array.html">array</a>, const S2 S1::*member1, const <a class="el" href="classVc_1_1SimdArray.html#ae01209df02a8750be9c3aca4728e056d">EntryType</a> S2::*member2, IT indexes)</td></tr>
<tr class="separator:gab7e0e744bbf8112abc60707ec35782ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0a0ce77d4761ff3d4c346f44b02d5168"><td class="memTemplParams" colspan="2">template&lt;typename S1 , typename S2 , typename IT &gt; </td></tr>
<tr class="memitem:ga0a0ce77d4761ff3d4c346f44b02d5168"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__SimdArray.html#ga0a0ce77d4761ff3d4c346f44b02d5168">gather</a> (const S1 *<a class="el" href="structVc_1_1array.html">array</a>, const S2 S1::*member1, const <a class="el" href="classVc_1_1SimdArray.html#ae01209df02a8750be9c3aca4728e056d">EntryType</a> S2::*member2, IT indexes, <a class="el" href="classVc_1_1SimdMaskArray.html">MaskArgument</a> mask)</td></tr>
<tr class="separator:ga0a0ce77d4761ff3d4c346f44b02d5168"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga851eee82fe0a753a26929a1a6982f84a"><td class="memTemplParams" colspan="2">template&lt;typename S1 , typename IT1 , typename IT2 &gt; </td></tr>
<tr class="memitem:ga851eee82fe0a753a26929a1a6982f84a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__SimdArray.html#ga851eee82fe0a753a26929a1a6982f84a">gather</a> (const S1 *<a class="el" href="structVc_1_1array.html">array</a>, const <a class="el" href="classVc_1_1SimdArray.html#ae01209df02a8750be9c3aca4728e056d">EntryType</a> *const S1::*ptrMember1, IT1 outerIndexes, IT2 innerIndexes)</td></tr>
<tr class="separator:ga851eee82fe0a753a26929a1a6982f84a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf179ee076927fb7ed38661b34e70b5ee"><td class="memTemplParams" colspan="2">template&lt;typename S1 , typename IT1 , typename IT2 &gt; </td></tr>
<tr class="memitem:gaf179ee076927fb7ed38661b34e70b5ee"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__SimdArray.html#gaf179ee076927fb7ed38661b34e70b5ee">gather</a> (const S1 *<a class="el" href="structVc_1_1array.html">array</a>, const <a class="el" href="classVc_1_1SimdArray.html#ae01209df02a8750be9c3aca4728e056d">EntryType</a> *const S1::*ptrMember1, IT1 outerIndexes, IT2 innerIndexes, <a class="el" href="classVc_1_1SimdMaskArray.html">MaskArgument</a> mask)</td></tr>
<tr class="separator:gaf179ee076927fb7ed38661b34e70b5ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf57dd65795bb03a652b52bdc59152974"><td class="memTemplParams" colspan="2">template&lt;typename S1 , typename IT &gt; </td></tr>
<tr class="memitem:gaf57dd65795bb03a652b52bdc59152974"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__SimdArray.html#gaf57dd65795bb03a652b52bdc59152974">scatter</a> (S1 *<a class="el" href="structVc_1_1array.html">array</a>, <a class="el" href="classVc_1_1SimdArray.html#ae01209df02a8750be9c3aca4728e056d">EntryType</a> S1::*member1, IT indexes) const </td></tr>
<tr class="separator:gaf57dd65795bb03a652b52bdc59152974"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac767f28c920a44d0f732505ec7bb9865"><td class="memTemplParams" colspan="2">template&lt;typename S1 , typename IT &gt; </td></tr>
<tr class="memitem:gac767f28c920a44d0f732505ec7bb9865"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__SimdArray.html#gac767f28c920a44d0f732505ec7bb9865">scatter</a> (S1 *<a class="el" href="structVc_1_1array.html">array</a>, <a class="el" href="classVc_1_1SimdArray.html#ae01209df02a8750be9c3aca4728e056d">EntryType</a> S1::*member1, IT indexes, <a class="el" href="classVc_1_1SimdMaskArray.html">MaskArgument</a> mask) const </td></tr>
<tr class="separator:gac767f28c920a44d0f732505ec7bb9865"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga90951e0b3ea5b221cd6a71734d5ce93d"><td class="memTemplParams" colspan="2">template&lt;typename S1 , typename S2 , typename IT &gt; </td></tr>
<tr class="memitem:ga90951e0b3ea5b221cd6a71734d5ce93d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__SimdArray.html#ga90951e0b3ea5b221cd6a71734d5ce93d">scatter</a> (S1 *<a class="el" href="structVc_1_1array.html">array</a>, S2 S1::*member1, <a class="el" href="classVc_1_1SimdArray.html#ae01209df02a8750be9c3aca4728e056d">EntryType</a> S2::*member2, IT indexes) const </td></tr>
<tr class="separator:ga90951e0b3ea5b221cd6a71734d5ce93d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga299631364e9c623ac9597f31801bd927"><td class="memTemplParams" colspan="2">template&lt;typename S1 , typename S2 , typename IT &gt; </td></tr>
<tr class="memitem:ga299631364e9c623ac9597f31801bd927"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__SimdArray.html#ga299631364e9c623ac9597f31801bd927">scatter</a> (S1 *<a class="el" href="structVc_1_1array.html">array</a>, S2 S1::*member1, <a class="el" href="classVc_1_1SimdArray.html#ae01209df02a8750be9c3aca4728e056d">EntryType</a> S2::*member2, IT indexes, <a class="el" href="classVc_1_1SimdMaskArray.html">MaskArgument</a> mask) const </td></tr>
<tr class="separator:ga299631364e9c623ac9597f31801bd927"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga811c74efda5768b9decec85dce246173"><td class="memTemplParams" colspan="2">template&lt;typename S1 , typename IT1 , typename IT2 &gt; </td></tr>
<tr class="memitem:ga811c74efda5768b9decec85dce246173"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__SimdArray.html#ga811c74efda5768b9decec85dce246173">scatter</a> (S1 *<a class="el" href="structVc_1_1array.html">array</a>, <a class="el" href="classVc_1_1SimdArray.html#ae01209df02a8750be9c3aca4728e056d">EntryType</a> *S1::*ptrMember1, IT1 outerIndexes, IT2 innerIndexes) const </td></tr>
<tr class="separator:ga811c74efda5768b9decec85dce246173"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab145b30f47b57e36d08592e2ab454d6f"><td class="memTemplParams" colspan="2">template&lt;typename S1 , typename IT1 , typename IT2 &gt; </td></tr>
<tr class="memitem:gab145b30f47b57e36d08592e2ab454d6f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__SimdArray.html#gab145b30f47b57e36d08592e2ab454d6f">scatter</a> (S1 *<a class="el" href="structVc_1_1array.html">array</a>, <a class="el" href="classVc_1_1SimdArray.html#ae01209df02a8750be9c3aca4728e056d">EntryType</a> *S1::*ptrMember1, IT1 outerIndexes, IT2 innerIndexes, <a class="el" href="classVc_1_1SimdMaskArray.html">MaskArgument</a> mask) const </td></tr>
<tr class="separator:gab145b30f47b57e36d08592e2ab454d6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9efe43b277afc22a8ecf7d1c5c3e2d69"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classVc_1_1SimdArray.html">SimdArray</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__SimdArray.html#ga9efe43b277afc22a8ecf7d1c5c3e2d69">exponent</a> () const </td></tr>
<tr class="memdesc:ga9efe43b277afc22a8ecf7d1c5c3e2d69"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the exponents of the floating-point values in the vector.  <a href="group__SimdArray.html#ga9efe43b277afc22a8ecf7d1c5c3e2d69">More...</a><br /></td></tr>
<tr class="separator:ga9efe43b277afc22a8ecf7d1c5c3e2d69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae69d39745f8c88369041a693f6e5d0b7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classVc_1_1SimdArray.html#a2fd4547d07b041a214d9e5002ef0e7c2">MaskType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__SimdArray.html#gae69d39745f8c88369041a693f6e5d0b7">isNegative</a> () const </td></tr>
<tr class="memdesc:gae69d39745f8c88369041a693f6e5d0b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether a value is negative.  <a href="group__SimdArray.html#gae69d39745f8c88369041a693f6e5d0b7">More...</a><br /></td></tr>
<tr class="separator:gae69d39745f8c88369041a693f6e5d0b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafa32a2551d18c3fd8812b9ce7bb7282b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classVc_1_1SimdArray.html">SimdArray</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__SimdArray.html#gafa32a2551d18c3fd8812b9ce7bb7282b">copySign</a> (const <a class="el" href="classVc_1_1SimdArray.html">SimdArray</a> &amp;reference) const </td></tr>
<tr class="memdesc:gafa32a2551d18c3fd8812b9ce7bb7282b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies the signs of the components of <code>reference</code> to the components of the current vector, returning the result.  <a href="group__SimdArray.html#gafa32a2551d18c3fd8812b9ce7bb7282b">More...</a><br /></td></tr>
<tr class="separator:gafa32a2551d18c3fd8812b9ce7bb7282b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Scalar Subscript Operators</h2></td></tr>
<tr class="memitem:a26d4a8257663690c298c6371095c6568"><td class="memItemLeft" align="right" valign="top">reference&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVc_1_1SimdArray.html#a26d4a8257663690c298c6371095c6568">operator[]</a> (size_t i) noexcept</td></tr>
<tr class="memdesc:a26d4a8257663690c298c6371095c6568"><td class="mdescLeft">&#160;</td><td class="mdescRight">This operator can be used to modify scalar entries of the vector.  <a href="#a26d4a8257663690c298c6371095c6568">More...</a><br /></td></tr>
<tr class="separator:a26d4a8257663690c298c6371095c6568"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7941a8bfa6845a198bda7038a39e18f0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classVc_1_1SimdArray.html#afb9ded5f49336ae503bb9f2035ea902b">value_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVc_1_1SimdArray.html#a7941a8bfa6845a198bda7038a39e18f0">operator[]</a> (size_t index) const noexcept</td></tr>
<tr class="memdesc:a7941a8bfa6845a198bda7038a39e18f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">This operator can be used to read scalar entries of the vector.  <a href="#a7941a8bfa6845a198bda7038a39e18f0">More...</a><br /></td></tr>
<tr class="separator:a7941a8bfa6845a198bda7038a39e18f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Member Typedef Documentation</h2>
<a class="anchor" id="ae18e3a1c00f24f46c0654059d58661a2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classVc_1_1SimdArray.html#ae18e3a1c00f24f46c0654059d58661a2">Mask</a> =  <a class="el" href="classVc_1_1SimdArray.html#aa717de258d14cb1066a39ae88bc5d46c">mask_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The type of the mask used for masked operations and returned from comparisons. </p>

<p>Definition at line <a class="el" href="simdarray_8h_source.html#l00621">621</a> of file <a class="el" href="simdarray_8h_source.html">simdarray.h</a>.</p>

</div>
</div>
<a class="anchor" id="a2fd4547d07b041a214d9e5002ef0e7c2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classVc_1_1SimdArray.html#a2fd4547d07b041a214d9e5002ef0e7c2">MaskType</a> =  <a class="el" href="classVc_1_1SimdArray.html#ae18e3a1c00f24f46c0654059d58661a2">Mask</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The type of the mask used for masked operations and returned from comparisons. </p>

<p>Definition at line <a class="el" href="simdarray_8h_source.html#l00623">623</a> of file <a class="el" href="simdarray_8h_source.html">simdarray.h</a>.</p>

</div>
</div>
<a class="anchor" id="ae01209df02a8750be9c3aca4728e056d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classVc_1_1SimdArray.html#ae01209df02a8750be9c3aca4728e056d">EntryType</a> =  <a class="el" href="classVc_1_1SimdArray.html#afb9ded5f49336ae503bb9f2035ea902b">value_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The type of the elements (i.e. <code>T</code>) </p>

<p>Definition at line <a class="el" href="simdarray_8h_source.html#l00627">627</a> of file <a class="el" href="simdarray_8h_source.html">simdarray.h</a>.</p>

</div>
</div>
<a class="anchor" id="a205d97a77f849945d9d0b65835d68695"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classVc_1_1SimdArray.html#a205d97a77f849945d9d0b65835d68695">IndexType</a> =  <a class="el" href="classVc_1_1SimdArray.html#a0d2b0c15739451a17d861f9b3421e1c6">index_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The type of the vector used for indexes in gather and scatter operations. </p>

<p>Definition at line <a class="el" href="simdarray_8h_source.html#l00629">629</a> of file <a class="el" href="simdarray_8h_source.html">simdarray.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a4e6a602addcee799029d068f57a86c35"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVc_1_1SimdArray.html">SimdArray</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct a zero-initialized vector object. </p>
<p>This constructor follows the behavior of the underlying arithmetic type <code>T</code> in that the expression <code>T()</code> zero-initializes the object. On the other hand the variable <code>x</code> in <code>T x;</code> is uninitialized. Since, for class types, both expressions call the default constructor <code><a class="el" href="classVc_1_1Vector.html" title="The main vector class for expressing data parallelism. ">Vector</a>&lt;T&gt; x</code> must zero-initialize <code>x</code> as well. </p>

</div>
</div>
<a class="anchor" id="a69376a62ae90b283578814162e1397cf"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVc_1_1SimdArray.html">SimdArray</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classVc_1_1SimdArray.html#afb9ded5f49336ae503bb9f2035ea902b">value_type</a>&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Broadcast Constructor. </p>
<p>Constructs a vector with all entries of the vector filled with the given value.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>The scalar value to broadcast to all entries of the constructed vector. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="simdarray_8h_source.html#l00693">693</a> of file <a class="el" href="simdarray_8h_source.html">simdarray.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a5e99fb015bfbc024a4b785135b34dee7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr std::size_t size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns <code>N</code>, the number of scalar components in an object of this type. </p>
<p>The size of the <a class="el" href="classVc_1_1SimdArray.html" title="Data-parallel arithmetic type with user-defined number of elements. ">SimdArray</a>, i.e. the number of scalar elements in the vector. In contrast to <a class="el" href="classVc_1_1Vector.html#a1b5d7e2e663d7997796fd9f72b8af75a" title="Returns the number of scalar components ( ) in a vector of this type. ">Vector::size()</a> you have control over this value via the <code>N</code> template parameter of the <a class="el" href="classVc_1_1SimdArray.html" title="Data-parallel arithmetic type with user-defined number of elements. ">SimdArray</a> class template.</p>
<dl class="section return"><dt>Returns</dt><dd>The number of scalar values stored and manipulated concurrently by objects of this type. </dd></dl>

<p>Definition at line <a class="el" href="simdarray_8h_source.html#l00618">618</a> of file <a class="el" href="simdarray_8h_source.html">simdarray.h</a>.</p>

</div>
</div>
<a class="anchor" id="af892f831b3d8ac2fa6adce4f1eb989d0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classVc_1_1SimdArray.html">SimdArray</a> Random </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a vector with pseudo-random entries. </p>
<p>Currently the state of the random number generator cannot be modified and starts off with the same state. Thus you will get the same sequence of numbers for the same sequence of calls.</p>
<dl class="section return"><dt>Returns</dt><dd>a new random vector. Floating-point values will be in the 0-1 range. Integers will use the full range the integer representation allows.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function may use a very small amount of state and thus will be a weak random number generator. </dd></dl>

<p>Definition at line <a class="el" href="simdarray_8h_source.html#l00662">662</a> of file <a class="el" href="simdarray_8h_source.html">simdarray.h</a>.</p>

</div>
</div>
<a class="anchor" id="a26d4a8257663690c298c6371095c6568"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">reference operator[] </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This operator can be used to modify scalar entries of the vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>A value between 0 and Size. This value is not checked internally so you must make/be sure it is in range.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to the vector entry at the given <code>index</code>.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>The use of this function may result in suboptimal performance. Please check whether you can find a more vector-friendly way to do what you intended. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>the returned object models the concept of a reference and as such it can exist longer than the data it is referencing. </dd>
<dd>
to avoid lifetime issues, we strongly advice not to store any reference objects. </dd>
<dd>
the returned object models the concept of a reference and as such it can exist longer than the data it is referencing. </dd>
<dd>
to avoid lifetime issues, we strongly advice not to store any reference objects. </dd></dl>

<p>Definition at line <a class="el" href="simdarray_8h_source.html#l00969">969</a> of file <a class="el" href="simdarray_8h_source.html">simdarray.h</a>.</p>

</div>
</div>
<a class="anchor" id="a7941a8bfa6845a198bda7038a39e18f0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVc_1_1SimdArray.html#afb9ded5f49336ae503bb9f2035ea902b">value_type</a> operator[] </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This operator can be used to read scalar entries of the vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>A value between 0 and Size. This value is not checked internally so you must make/be sure it is in range.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a copy of the vector entry at the given <code>index</code>. </dd></dl>

<p>Definition at line <a class="el" href="simdarray_8h_source.html#l00976">976</a> of file <a class="el" href="simdarray_8h_source.html">simdarray.h</a>.</p>

</div>
</div>
<a class="anchor" id="a8d3569d32ca32737aa11b255cfb64a9f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Common::WriteMaskedVector&lt;<a class="el" href="classVc_1_1SimdArray.html">SimdArray</a>, <a class="el" href="classVc_1_1SimdArray.html#aa717de258d14cb1066a39ae88bc5d46c">mask_type</a>&gt; operator() </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classVc_1_1SimdArray.html#aa717de258d14cb1066a39ae88bc5d46c">mask_type</a> &amp;&#160;</td>
          <td class="paramname"><em>mask</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writemask the vector before an assignment. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mask</td><td>The writemask to be used.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an object that can be used for any kind of masked assignment.</dd></dl>
<p>The returned object is only to be used for assignments and should not be assigned to a variable.</p>
<p>Examples: </p><div class="fragment"><div class="line"><a class="code" href="group__Vectors.html#ga5cf7c5a0dadbbbbcb9b69c5e42ee0528">float_v</a> v = <a class="code" href="classVc_1_1Vector.html#af9c6cd3201b97b6c86d64a3b25e584d7">float_v::Zero</a>();         <span class="comment">// v  = [0, 0, 0, 0]</span></div><div class="line"><a class="code" href="group__Vectors.html#gaff6f527c244d2e97ae290d2325de8ec0">int_v</a> v2 = <a class="code" href="classVc_1_1Vector.html#a493fd531cf26bec9f8b40740ab110eec">int_v::IndexesFromZero</a>(); <span class="comment">// v2 = [0, 1, 2, 3]</span></div><div class="line">v(v2 &lt; 2) = 1.f;                     <span class="comment">// v  = [1, 1, 0, 0]</span></div><div class="line">v(v2 &lt; 3) += 1.f;                    <span class="comment">// v  = [2, 2, 1, 0]</span></div><div class="line">++v2(v &lt; 1.f);                       <span class="comment">// v2 = [0, 1, 2, 4]</span></div></div><!-- fragment --> 
<p>Definition at line <a class="el" href="simdarray_8h_source.html#l00984">984</a> of file <a class="el" href="simdarray_8h_source.html">simdarray.h</a>.</p>

</div>
</div>
<a class="anchor" id="af31a30afa41408e7e5eb0ba6cea7190f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVc_1_1SimdArray.html">SimdArray</a> sorted </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a sorted copy of the vector. </p>
<dl class="section return"><dt>Returns</dt><dd>a sorted vector. The returned values are in ascending order: <pre class="fragment">v[0] &lt;= v[1] &lt;= v[2] &lt;= v[3] ...
</pre></dd></dl>
<dl class="section note"><dt>Note</dt><dd>If the vector contains NaNs the result is undefined.</dd></dl>
<p>Example: </p><div class="fragment"><div class="line"><a class="code" href="group__Vectors.html#gaff6f527c244d2e97ae290d2325de8ec0">int_v</a> v = <a class="code" href="classVc_1_1Vector.html#aaa7aece82798960b1144c030e4c8f6cc">int_v::Random</a>();</div><div class="line"><a class="code" href="group__Vectors.html#gaff6f527c244d2e97ae290d2325de8ec0">int_v</a> s = v.sorted();</div><div class="line">std::cout &lt;&lt; v &lt;&lt; <span class="charliteral">&#39;\n&#39;</span> &lt;&lt; s &lt;&lt; <span class="charliteral">&#39;\n&#39;</span>;</div></div><!-- fragment --><p>With SSE the output would be:</p>
<pre class="fragment">[1513634383, -963914658, 1763536262, -1285037745]
[-1285037745, -963914658, 1513634383, 1763536262]
</pre><p>With the Scalar implementation: </p><pre class="fragment">[1513634383]
[1513634383]
</pre> 
<p>Definition at line <a class="el" href="simdarray_8h_source.html#l01293">1293</a> of file <a class="el" href="simdarray_8h_source.html">simdarray.h</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>/home/mkretz/src/Vc-1.3/common/<a class="el" href="simdarray_8h_source.html">simdarray.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespaceVc.html">Vc</a></li><li class="navelem"><a class="el" href="classVc_1_1SimdArray.html">SimdArray</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.11 </li>
  </ul>
</div>
</body>
</html>
