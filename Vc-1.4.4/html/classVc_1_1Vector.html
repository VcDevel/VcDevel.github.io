<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.4"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Vc: Vector&lt; T, Abi &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
  $(document).ready(function() { init_search(); });
/* @license-end */
</script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="logo_small.png"/></td>
  <td id="projectalign">
   <div id="projectname">Vc<span id="projectnumber">&#160;1.4.4</span>
   </div>
   <div id="projectbrief">SIMD Vector Classes for C++</div>
  </td>
    <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.svg"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.4 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('classVc_1_1Vector.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="classVc_1_1Vector-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">Vector&lt; T, Abi &gt; Class Template Reference<div class="ingroups"><a class="el" href="group__Vectors.html">Vectors</a></div></div></div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;typename T, typename Abi = VectorAbi::Best&lt;T&gt;&gt;<br />
class Vc::Vector&lt; T, Abi &gt;</div><p >The main vector class for expressing data parallelism. </p>
<p >are specializations of this class. For most cases there are no API differences for the specializations. Make use of Vector&lt;T&gt; for generic programming, otherwise you might prefer to use the <code>*_v</code> aliases.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__Vectors.html#ga5cf7c5a0dadbbbbcb9b69c5e42ee0528" title="vector of single precision">Vc::float_v</a>, <a class="el" href="group__Vectors.html#ga0c29c10a0054260ee326ff12938243fa" title="vector of double precision">Vc::double_v</a>, <a class="el" href="group__Vectors.html#gaff6f527c244d2e97ae290d2325de8ec0" title="vector of signed integers">Vc::int_v</a>, <a class="el" href="group__Vectors.html#gab04f66a2e5672fe27f27e9fbff5afcbc" title="vector of unsigned integers">Vc::uint_v</a>, <a class="el" href="group__Vectors.html#ga357ea2ba8644fc80c7e7cf13069e6ed0" title="vector of signed short integers">Vc::short_v</a>, <a class="el" href="group__Vectors.html#ga06b026f838dc9e1a7b8d76a89a852503" title="vector of unsigned short integers">Vc::ushort_v</a> </dd>
<dd>
<a class="el" href="classVc_1_1Mask.html" title="The main SIMD mask class.">Mask</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="common_2vector_8h_source.html#l00125">125</a> of file <a class="el" href="common_2vector_8h_source.html">vector.h</a>.</p>
</div>
<p><code>#include &lt;<a class="el" href="types_8h_source.html">Vc/vector.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:abe9aa1f35fa46be781ae9e81d374a72b"><td class="memItemLeft" align="right" valign="top"><a id="abe9aa1f35fa46be781ae9e81d374a72b" name="abe9aa1f35fa46be781ae9e81d374a72b"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>abi</b> = Abi</td></tr>
<tr class="memdesc:abe9aa1f35fa46be781ae9e81d374a72b"><td class="mdescLeft">&#160;</td><td class="mdescRight">The ABI tag type of the current template instantiation. <br /></td></tr>
<tr class="separator:abe9aa1f35fa46be781ae9e81d374a72b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9cb6038cbd15cb0bdc596f5383c2b21"><td class="memItemLeft" align="right" valign="top"><a id="ae9cb6038cbd15cb0bdc596f5383c2b21" name="ae9cb6038cbd15cb0bdc596f5383c2b21"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>EntryType</b> = typename VectorTraits&lt; T, Abi &gt;::EntryType</td></tr>
<tr class="memdesc:ae9cb6038cbd15cb0bdc596f5383c2b21"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type of the entries in the vector. <br /></td></tr>
<tr class="separator:ae9cb6038cbd15cb0bdc596f5383c2b21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af58a233cf0cdf62369686dd5798bd589"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVc_1_1Vector.html#af58a233cf0cdf62369686dd5798bd589">value_type</a> = <a class="el" href="classVc_1_1Vector.html#ae9cb6038cbd15cb0bdc596f5383c2b21">EntryType</a></td></tr>
<tr class="memdesc:af58a233cf0cdf62369686dd5798bd589"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type of the entries in the vector.  <a href="classVc_1_1Vector.html#af58a233cf0cdf62369686dd5798bd589">More...</a><br /></td></tr>
<tr class="separator:af58a233cf0cdf62369686dd5798bd589"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87ee111bfca7f15829e802bdf47c3b0e"><td class="memItemLeft" align="right" valign="top"><a id="a87ee111bfca7f15829e802bdf47c3b0e" name="a87ee111bfca7f15829e802bdf47c3b0e"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>MaskType</b> = <a class="el" href="classVc_1_1Mask.html">Vc::Mask</a>&lt; T, Abi &gt;</td></tr>
<tr class="memdesc:a87ee111bfca7f15829e802bdf47c3b0e"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type of the mask used for masked operations and returned from comparisons. <br /></td></tr>
<tr class="separator:a87ee111bfca7f15829e802bdf47c3b0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abffe464ff20f5933e5a50b699555fa5f"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVc_1_1Vector.html#abffe464ff20f5933e5a50b699555fa5f">mask_type</a> = <a class="el" href="classVc_1_1Vector.html#a87ee111bfca7f15829e802bdf47c3b0e">MaskType</a></td></tr>
<tr class="memdesc:abffe464ff20f5933e5a50b699555fa5f"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type of the mask used for masked operations and returned from comparisons.  <a href="classVc_1_1Vector.html#abffe464ff20f5933e5a50b699555fa5f">More...</a><br /></td></tr>
<tr class="separator:abffe464ff20f5933e5a50b699555fa5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00b1721fbbac37b8c884b6347af3ce70"><td class="memItemLeft" align="right" valign="top"><a id="a00b1721fbbac37b8c884b6347af3ce70" name="a00b1721fbbac37b8c884b6347af3ce70"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>IndexType</b> = <a class="el" href="classVc_1_1Vector.html">Vc::fixed_size_simd</a>&lt; int, VectorTraits&lt; T, Abi &gt;<a class="el" href="classVc_1_1Vector.html#a1b5d7e2e663d7997796fd9f72b8af75a">::size</a>()&gt;</td></tr>
<tr class="memdesc:a00b1721fbbac37b8c884b6347af3ce70"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type of the vector used for indexes in gather and scatter operations. <br /></td></tr>
<tr class="separator:a00b1721fbbac37b8c884b6347af3ce70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2eaac791c05f06627d44f9438059b1ab"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVc_1_1Vector.html#a2eaac791c05f06627d44f9438059b1ab">index_type</a> = <a class="el" href="classVc_1_1Vector.html#a00b1721fbbac37b8c884b6347af3ce70">IndexType</a></td></tr>
<tr class="memdesc:a2eaac791c05f06627d44f9438059b1ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type of the vector used for indexes in gather and scatter operations.  <a href="classVc_1_1Vector.html#a2eaac791c05f06627d44f9438059b1ab">More...</a><br /></td></tr>
<tr class="separator:a2eaac791c05f06627d44f9438059b1ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a47affd1a10b589811fc4828c1a2e0c6d"><td class="memItemLeft" align="right" valign="top"><a id="a47affd1a10b589811fc4828c1a2e0c6d" name="a47affd1a10b589811fc4828c1a2e0c6d"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>setZero</b> ()</td></tr>
<tr class="memdesc:a47affd1a10b589811fc4828c1a2e0c6d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set all entries to zero. <br /></td></tr>
<tr class="separator:a47affd1a10b589811fc4828c1a2e0c6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a804d5492c78c2e5f9ca92f1d02c78c1b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVc_1_1Vector.html#a804d5492c78c2e5f9ca92f1d02c78c1b">setZero</a> (<a class="el" href="classVc_1_1Vector.html#a87ee111bfca7f15829e802bdf47c3b0e">MaskType</a> mask)</td></tr>
<tr class="memdesc:a804d5492c78c2e5f9ca92f1d02c78c1b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set all entries to zero where the mask is set.  <a href="classVc_1_1Vector.html#a804d5492c78c2e5f9ca92f1d02c78c1b">More...</a><br /></td></tr>
<tr class="separator:a804d5492c78c2e5f9ca92f1d02c78c1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10b3726d4ad99374f9448860fa5229d5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVc_1_1Vector.html#a10b3726d4ad99374f9448860fa5229d5">setZeroInverted</a> (<a class="el" href="classVc_1_1Vector.html#a87ee111bfca7f15829e802bdf47c3b0e">MaskType</a> mask)</td></tr>
<tr class="memdesc:a10b3726d4ad99374f9448860fa5229d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set all entries to zero where the mask is not set.  <a href="classVc_1_1Vector.html#a10b3726d4ad99374f9448860fa5229d5">More...</a><br /></td></tr>
<tr class="separator:a10b3726d4ad99374f9448860fa5229d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3fb1503849734e51c08adaff319c5e60"><td class="memItemLeft" align="right" valign="top"><a id="a3fb1503849734e51c08adaff319c5e60" name="a3fb1503849734e51c08adaff319c5e60"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>setQnan</b> ()</td></tr>
<tr class="memdesc:a3fb1503849734e51c08adaff319c5e60"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set all entries to the bit representation of a QNaN. <br /></td></tr>
<tr class="separator:a3fb1503849734e51c08adaff319c5e60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b97acf03cd2b4e96eeed94c6bf6a3fa"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVc_1_1Vector.html#a3b97acf03cd2b4e96eeed94c6bf6a3fa">setQnan</a> (<a class="el" href="classVc_1_1Vector.html#a87ee111bfca7f15829e802bdf47c3b0e">MaskType</a> mask)</td></tr>
<tr class="memdesc:a3b97acf03cd2b4e96eeed94c6bf6a3fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set all entries to the bit representation of a QNaN where the mask is set.  <a href="classVc_1_1Vector.html#a3b97acf03cd2b4e96eeed94c6bf6a3fa">More...</a><br /></td></tr>
<tr class="separator:a3b97acf03cd2b4e96eeed94c6bf6a3fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd478ea3c475c6821c2eee09d3b62e7c"><td class="memItemLeft" align="right" valign="top">Common::WriteMaskedVector&lt; <a class="el" href="classVc_1_1Vector.html">Vector</a>, <a class="el" href="classVc_1_1Vector.html#a87ee111bfca7f15829e802bdf47c3b0e">MaskType</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVc_1_1Vector.html#abd478ea3c475c6821c2eee09d3b62e7c">operator()</a> (<a class="el" href="classVc_1_1Vector.html#a87ee111bfca7f15829e802bdf47c3b0e">MaskType</a> mask)</td></tr>
<tr class="memdesc:abd478ea3c475c6821c2eee09d3b62e7c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writemask the vector before an assignment.  <a href="classVc_1_1Vector.html#abd478ea3c475c6821c2eee09d3b62e7c">More...</a><br /></td></tr>
<tr class="separator:abd478ea3c475c6821c2eee09d3b62e7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abcbb1d306f41b8b282731ae6dee0df81"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classVc_1_1Vector.html">Vector</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVc_1_1Vector.html#abcbb1d306f41b8b282731ae6dee0df81">sorted</a> () const</td></tr>
<tr class="memdesc:abcbb1d306f41b8b282731ae6dee0df81"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a sorted copy of the vector.  <a href="classVc_1_1Vector.html#abcbb1d306f41b8b282731ae6dee0df81">More...</a><br /></td></tr>
<tr class="separator:abcbb1d306f41b8b282731ae6dee0df81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Compile-Time Constant Initialization</div></td></tr>
<tr class="memitem:aba83f7828d95b601500471996fc8c3c0"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVc_1_1Vector.html#aba83f7828d95b601500471996fc8c3c0">Vector</a> ()=default</td></tr>
<tr class="memdesc:aba83f7828d95b601500471996fc8c3c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a zero-initialized vector object.  <a href="classVc_1_1Vector.html#aba83f7828d95b601500471996fc8c3c0">More...</a><br /></td></tr>
<tr class="separator:aba83f7828d95b601500471996fc8c3c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b959c60986675489b915cd33ffa1a65"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVc_1_1Vector.html#a4b959c60986675489b915cd33ffa1a65">Vector</a> (VectorSpecialInitializerZero)</td></tr>
<tr class="memdesc:a4b959c60986675489b915cd33ffa1a65"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a vector with the entries initialized to zero.  <a href="classVc_1_1Vector.html#a4b959c60986675489b915cd33ffa1a65">More...</a><br /></td></tr>
<tr class="separator:a4b959c60986675489b915cd33ffa1a65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6faca3e9ae02f4e213bad11cb860e20"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVc_1_1Vector.html#ac6faca3e9ae02f4e213bad11cb860e20">Vector</a> (VectorSpecialInitializerOne)</td></tr>
<tr class="memdesc:ac6faca3e9ae02f4e213bad11cb860e20"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a vector with the entries initialized to one.  <a href="classVc_1_1Vector.html#ac6faca3e9ae02f4e213bad11cb860e20">More...</a><br /></td></tr>
<tr class="separator:ac6faca3e9ae02f4e213bad11cb860e20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c5bdbbb09e1851bcb9b35b286c76753"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVc_1_1Vector.html#a9c5bdbbb09e1851bcb9b35b286c76753">Vector</a> (VectorSpecialInitializerIndexesFromZero)</td></tr>
<tr class="memdesc:a9c5bdbbb09e1851bcb9b35b286c76753"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a vector with the entries initialized to 0, 1, 2, 3, 4, 5, ...  <a href="classVc_1_1Vector.html#a9c5bdbbb09e1851bcb9b35b286c76753">More...</a><br /></td></tr>
<tr class="separator:a9c5bdbbb09e1851bcb9b35b286c76753"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Conversion/Broadcast Constructors</div></td></tr>
<tr class="memitem:ab03f19704c60f0c56cfbf52ec3ee1b73"><td class="memTemplParams" colspan="2"><a id="ab03f19704c60f0c56cfbf52ec3ee1b73" name="ab03f19704c60f0c56cfbf52ec3ee1b73"></a>
template&lt;typename U &gt; </td></tr>
<tr class="memitem:ab03f19704c60f0c56cfbf52ec3ee1b73"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><b>Vector</b> (<a class="el" href="classVc_1_1Vector.html">Vector</a>&lt; U, <a class="el" href="classVc_1_1Vector.html#abe9aa1f35fa46be781ae9e81d374a72b">abi</a> &gt; x, enable_if&lt; Traits::is_implicit_cast_allowed&lt; U, T &gt;::value &gt;=nullarg)</td></tr>
<tr class="memdesc:ab03f19704c60f0c56cfbf52ec3ee1b73"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implict conversion from compatible Vector&lt;U, Abi&gt; types. <br /></td></tr>
<tr class="separator:ab03f19704c60f0c56cfbf52ec3ee1b73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7290079f3ee28150a310a6583b4eb3bd"><td class="memTemplParams" colspan="2">template&lt;typename U &gt; </td></tr>
<tr class="memitem:a7290079f3ee28150a310a6583b4eb3bd"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classVc_1_1Vector.html#a7290079f3ee28150a310a6583b4eb3bd">Vector</a> (<a class="el" href="classVc_1_1Vector.html">Vector</a>&lt; U, <a class="el" href="classVc_1_1Vector.html#abe9aa1f35fa46be781ae9e81d374a72b">abi</a> &gt; x, enable_if&lt;!Traits::is_implicit_cast_allowed&lt; U, T &gt;::value &gt;=nullarg)</td></tr>
<tr class="memdesc:a7290079f3ee28150a310a6583b4eb3bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Explicit conversion (i.e.  <a href="classVc_1_1Vector.html#a7290079f3ee28150a310a6583b4eb3bd">More...</a><br /></td></tr>
<tr class="separator:a7290079f3ee28150a310a6583b4eb3bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e363c9b2d525293cfb1656e1498e796"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVc_1_1Vector.html#a7e363c9b2d525293cfb1656e1498e796">Vector</a> (<a class="el" href="classVc_1_1Vector.html#ae9cb6038cbd15cb0bdc596f5383c2b21">EntryType</a> a)</td></tr>
<tr class="memdesc:a7e363c9b2d525293cfb1656e1498e796"><td class="mdescLeft">&#160;</td><td class="mdescRight">Broadcast Constructor.  <a href="classVc_1_1Vector.html#a7e363c9b2d525293cfb1656e1498e796">More...</a><br /></td></tr>
<tr class="separator:a7e363c9b2d525293cfb1656e1498e796"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7394b442797518f5d84ddb78e64744a4"><td class="memTemplParams" colspan="2"><a id="a7394b442797518f5d84ddb78e64744a4" name="a7394b442797518f5d84ddb78e64744a4"></a>
template&lt;typename U &gt; </td></tr>
<tr class="memitem:a7394b442797518f5d84ddb78e64744a4"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><b>Vector</b> (U a, enable_if&lt; std::is_same&lt; U, int &gt;::value &amp;&amp;!std::is_same&lt; U, <a class="el" href="classVc_1_1Vector.html#ae9cb6038cbd15cb0bdc596f5383c2b21">EntryType</a> &gt;::value &gt;=nullarg)</td></tr>
<tr class="separator:a7394b442797518f5d84ddb78e64744a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8dfa8dab6af1fa132c135b6791c86ddd"><td class="memItemLeft" align="right" valign="top"><a id="a8dfa8dab6af1fa132c135b6791c86ddd" name="a8dfa8dab6af1fa132c135b6791c86ddd"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>Vector</b> (reference a)</td></tr>
<tr class="separator:a8dfa8dab6af1fa132c135b6791c86ddd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Scalar Subscript Operators</div></td></tr>
<tr class="memitem:ad9490a1dfe9ab280829a12edea2a858b"><td class="memItemLeft" align="right" valign="top">reference&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVc_1_1Vector.html#ad9490a1dfe9ab280829a12edea2a858b">operator[]</a> (size_t index) noexcept</td></tr>
<tr class="memdesc:ad9490a1dfe9ab280829a12edea2a858b"><td class="mdescLeft">&#160;</td><td class="mdescRight">This operator can be used to modify scalar entries of the vector.  <a href="classVc_1_1Vector.html#ad9490a1dfe9ab280829a12edea2a858b">More...</a><br /></td></tr>
<tr class="separator:ad9490a1dfe9ab280829a12edea2a858b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b07118e73a90c0bb93dceb209d5676e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classVc_1_1Vector.html#ae9cb6038cbd15cb0bdc596f5383c2b21">EntryType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVc_1_1Vector.html#a3b07118e73a90c0bb93dceb209d5676e">operator[]</a> (size_t index) const noexcept</td></tr>
<tr class="memdesc:a3b07118e73a90c0bb93dceb209d5676e"><td class="mdescLeft">&#160;</td><td class="mdescRight">This operator can be used to read scalar entries of the vector.  <a href="classVc_1_1Vector.html#a3b07118e73a90c0bb93dceb209d5676e">More...</a><br /></td></tr>
<tr class="separator:a3b07118e73a90c0bb93dceb209d5676e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Unary Operators</div></td></tr>
<tr class="memitem:af75e76ccff4d4fa559902291c184c6ce"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classVc_1_1Vector.html#a87ee111bfca7f15829e802bdf47c3b0e">MaskType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVc_1_1Vector.html#af75e76ccff4d4fa559902291c184c6ce">operator!</a> () const</td></tr>
<tr class="memdesc:af75e76ccff4d4fa559902291c184c6ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine where the vector is null.  <a href="classVc_1_1Vector.html#af75e76ccff4d4fa559902291c184c6ce">More...</a><br /></td></tr>
<tr class="separator:af75e76ccff4d4fa559902291c184c6ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1dbbf2712d48879e963184d9627515e5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classVc_1_1Vector.html">Vector</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVc_1_1Vector.html#a1dbbf2712d48879e963184d9627515e5">operator~</a> () const</td></tr>
<tr class="memdesc:a1dbbf2712d48879e963184d9627515e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inverts all bits.  <a href="classVc_1_1Vector.html#a1dbbf2712d48879e963184d9627515e5">More...</a><br /></td></tr>
<tr class="separator:a1dbbf2712d48879e963184d9627515e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5785e18696423dd7b9b3667563d6950d"><td class="memItemLeft" align="right" valign="top"><a id="a5785e18696423dd7b9b3667563d6950d" name="a5785e18696423dd7b9b3667563d6950d"></a>
<a class="el" href="classVc_1_1Vector.html">Vector</a>&#160;</td><td class="memItemRight" valign="bottom"><b>operator-</b> () const</td></tr>
<tr class="memdesc:a5785e18696423dd7b9b3667563d6950d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a new vector object with all entries negated. <br /></td></tr>
<tr class="separator:a5785e18696423dd7b9b3667563d6950d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5701fd833be7b8ef2e2f86c09cd5499f"><td class="memItemLeft" align="right" valign="top"><a id="a5701fd833be7b8ef2e2f86c09cd5499f" name="a5701fd833be7b8ef2e2f86c09cd5499f"></a>
<a class="el" href="classVc_1_1Vector.html">Vector</a>&#160;</td><td class="memItemRight" valign="bottom"><b>operator+</b> () const</td></tr>
<tr class="memdesc:a5701fd833be7b8ef2e2f86c09cd5499f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a copy of the vector object. <br /></td></tr>
<tr class="separator:a5701fd833be7b8ef2e2f86c09cd5499f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Increment and Decrement Operators</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p >The increment and decrement operators apply the increment/decrement operation per component.</p>
<p >The semantics are equal to the semantics of the fundamental arithmetics type <code>T</code>.</p>
<dl class="section note"><dt>Note</dt><dd>Over-/Underflow of signed integral types is undefined behavior and may actually break your code. </dd></dl>
</div></td></tr>
<tr class="memitem:a75b395ecb5cda634fe62780c51d8a7c8"><td class="memItemLeft" align="right" valign="top"><a id="a75b395ecb5cda634fe62780c51d8a7c8" name="a75b395ecb5cda634fe62780c51d8a7c8"></a>
<a class="el" href="classVc_1_1Vector.html">Vector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator++</b> ()</td></tr>
<tr class="separator:a75b395ecb5cda634fe62780c51d8a7c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaaaa52b9a4c62f549da6f28da151f070"><td class="memItemLeft" align="right" valign="top"><a id="aaaaa52b9a4c62f549da6f28da151f070" name="aaaaa52b9a4c62f549da6f28da151f070"></a>
<a class="el" href="classVc_1_1Vector.html">Vector</a>&#160;</td><td class="memItemRight" valign="bottom"><b>operator++</b> (int)</td></tr>
<tr class="separator:aaaaa52b9a4c62f549da6f28da151f070"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b0977b9e7e0c77e9f8471dc45cf40f1"><td class="memItemLeft" align="right" valign="top"><a id="a8b0977b9e7e0c77e9f8471dc45cf40f1" name="a8b0977b9e7e0c77e9f8471dc45cf40f1"></a>
<a class="el" href="classVc_1_1Vector.html">Vector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator--</b> ()</td></tr>
<tr class="separator:a8b0977b9e7e0c77e9f8471dc45cf40f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9be470793142b7361c388162436d3a72"><td class="memItemLeft" align="right" valign="top"><a id="a9be470793142b7361c388162436d3a72" name="a9be470793142b7361c388162436d3a72"></a>
<a class="el" href="classVc_1_1Vector.html">Vector</a>&#160;</td><td class="memItemRight" valign="bottom"><b>operator--</b> (int)</td></tr>
<tr class="separator:a9be470793142b7361c388162436d3a72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Arithmetic Operations</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p >The arithmetic operations are implemented as component-wise application of the operator on the two vector objects.</p>
<p >Example: </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> foo(<a class="code hl_class" href="classVc_1_1Vector.html">float_v</a> a, <a class="code hl_class" href="classVc_1_1Vector.html">float_v</a> b) {</div>
<div class="line">  <span class="keyword">const</span> <a class="code hl_class" href="classVc_1_1Vector.html">float_v</a> <a class="code hl_function" href="classVc_1_1Vector.html#a5df0e474de79e207072c337747ee2747">product</a>    = a * b;</div>
<div class="line">  <span class="keyword">const</span> <a class="code hl_class" href="classVc_1_1Vector.html">float_v</a> difference = a - b;</div>
<div class="line">  a += b;</div>
<div class="line">  <span class="keyword">auto</span> quotient = a / b;</div>
<div class="line">  <span class="keyword">auto</span> modulo = <span class="keyword">static_cast&lt;</span><a class="code hl_class" href="classVc_1_1Vector.html">int_v</a><span class="keyword">&gt;</span>(a) % <span class="keyword">static_cast&lt;</span><a class="code hl_class" href="classVc_1_1Vector.html">int_v</a><span class="keyword">&gt;</span>(b);</div>
<div class="line">}</div>
<div class="ttc" id="aclassVc_1_1Vector_html"><div class="ttname"><a href="classVc_1_1Vector.html">Vc::Vector</a></div><div class="ttdoc">The main vector class for expressing data parallelism.</div><div class="ttdef"><b>Definition:</b> <a href="common_2vector_8h_source.html#l00125">vector.h:126</a></div></div>
<div class="ttc" id="aclassVc_1_1Vector_html_a5df0e474de79e207072c337747ee2747"><div class="ttname"><a href="classVc_1_1Vector.html#a5df0e474de79e207072c337747ee2747">Vc::Vector::product</a></div><div class="ttdeci">EntryType product() const</div><div class="ttdoc">Returns the product of all entries in the vector.</div></div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>The vector to add, subtract, multiply, or divide by. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector object of the same type with the components filled according to a component-wise application of the operator.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>If a signed integral vector operation overflows the result is undefined. (which is in agreement to the behavior of the fundamental signed integral types in C++) </dd></dl>
</div></td></tr>
<tr class="memitem:ae33950d6a2e9b48c057d5c519e8da265"><td class="memItemLeft" align="right" valign="top"><a id="ae33950d6a2e9b48c057d5c519e8da265" name="ae33950d6a2e9b48c057d5c519e8da265"></a>
<a class="el" href="classVc_1_1Vector.html">Vector</a>&#160;</td><td class="memItemRight" valign="bottom"><b>operator+</b> (const <a class="el" href="classVc_1_1Vector.html">Vector</a> &amp;x) const</td></tr>
<tr class="separator:ae33950d6a2e9b48c057d5c519e8da265"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2e95ee34d02e318d001d931a3ddbc48"><td class="memItemLeft" align="right" valign="top"><a id="aa2e95ee34d02e318d001d931a3ddbc48" name="aa2e95ee34d02e318d001d931a3ddbc48"></a>
<a class="el" href="classVc_1_1Vector.html">Vector</a>&#160;</td><td class="memItemRight" valign="bottom"><b>operator-</b> (const <a class="el" href="classVc_1_1Vector.html">Vector</a> &amp;x) const</td></tr>
<tr class="separator:aa2e95ee34d02e318d001d931a3ddbc48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97575bd465b5b12dcb5ff86abb2832a5"><td class="memItemLeft" align="right" valign="top"><a id="a97575bd465b5b12dcb5ff86abb2832a5" name="a97575bd465b5b12dcb5ff86abb2832a5"></a>
<a class="el" href="classVc_1_1Vector.html">Vector</a>&#160;</td><td class="memItemRight" valign="bottom"><b>operator*</b> (const <a class="el" href="classVc_1_1Vector.html">Vector</a> &amp;x) const</td></tr>
<tr class="separator:a97575bd465b5b12dcb5ff86abb2832a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac55ef8db1cd6b6a2ead35996efaaa69c"><td class="memItemLeft" align="right" valign="top"><a id="ac55ef8db1cd6b6a2ead35996efaaa69c" name="ac55ef8db1cd6b6a2ead35996efaaa69c"></a>
<a class="el" href="classVc_1_1Vector.html">Vector</a>&#160;</td><td class="memItemRight" valign="bottom"><b>operator/</b> (const <a class="el" href="classVc_1_1Vector.html">Vector</a> &amp;x) const</td></tr>
<tr class="separator:ac55ef8db1cd6b6a2ead35996efaaa69c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02f8de8f26bbca162dc0b2fa67daa4d5"><td class="memItemLeft" align="right" valign="top"><a id="a02f8de8f26bbca162dc0b2fa67daa4d5" name="a02f8de8f26bbca162dc0b2fa67daa4d5"></a>
<a class="el" href="classVc_1_1Vector.html">Vector</a>&#160;</td><td class="memItemRight" valign="bottom"><b>operator%</b> (const <a class="el" href="classVc_1_1Vector.html">Vector</a> &amp;x) const</td></tr>
<tr class="separator:a02f8de8f26bbca162dc0b2fa67daa4d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Binary Operations</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p >The binary operations are implemented as component-wise application of the operator on the two vector objects.</p>
<p >Example: </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> foo(<a class="code hl_class" href="classVc_1_1Vector.html">int_v</a> a, <a class="code hl_class" href="classVc_1_1Vector.html">int_v</a> b) {</div>
<div class="line">  <span class="keyword">const</span> <a class="code hl_class" href="classVc_1_1Vector.html">int_v</a> combined_bits = a | b;</div>
<div class="line">  <span class="keyword">const</span> <a class="code hl_class" href="classVc_1_1Vector.html">int_v</a> masked_bits = a &amp; b;</div>
<div class="line">  a ^= b;  <span class="comment">// flipped bits</span></div>
<div class="line">}</div>
</div><!-- fragment --><dl class="section return"><dt>Returns</dt><dd>A vector object of the same type with the components filled according to a component-wise application of the operator. </dd></dl>
</div></td></tr>
<tr class="memitem:a28b6dc16d6f691906a08dc2c8bb15c5e"><td class="memItemLeft" align="right" valign="top"><a id="a28b6dc16d6f691906a08dc2c8bb15c5e" name="a28b6dc16d6f691906a08dc2c8bb15c5e"></a>
<a class="el" href="classVc_1_1Vector.html">Vector</a>&#160;</td><td class="memItemRight" valign="bottom"><b>operator|</b> (const <a class="el" href="classVc_1_1Vector.html">Vector</a> &amp;x) const</td></tr>
<tr class="separator:a28b6dc16d6f691906a08dc2c8bb15c5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abcf2691cb20eeac4bc9eaeb3d781b225"><td class="memItemLeft" align="right" valign="top"><a id="abcf2691cb20eeac4bc9eaeb3d781b225" name="abcf2691cb20eeac4bc9eaeb3d781b225"></a>
<a class="el" href="classVc_1_1Vector.html">Vector</a>&#160;</td><td class="memItemRight" valign="bottom"><b>operator&amp;</b> (const <a class="el" href="classVc_1_1Vector.html">Vector</a> &amp;x) const</td></tr>
<tr class="separator:abcf2691cb20eeac4bc9eaeb3d781b225"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa201f2de2455701a88f539c0c2c92046"><td class="memItemLeft" align="right" valign="top"><a id="aa201f2de2455701a88f539c0c2c92046" name="aa201f2de2455701a88f539c0c2c92046"></a>
<a class="el" href="classVc_1_1Vector.html">Vector</a>&#160;</td><td class="memItemRight" valign="bottom"><b>operator^</b> (const <a class="el" href="classVc_1_1Vector.html">Vector</a> &amp;x) const</td></tr>
<tr class="separator:aa201f2de2455701a88f539c0c2c92046"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Shift Operations</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p >The shift operations are implemented as component-wise application of the operator on the two vector objects.</p>
<p >Example: </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> foo(<a class="code hl_class" href="classVc_1_1Vector.html">int_v</a> a, <a class="code hl_class" href="classVc_1_1Vector.html">int_v</a> b) {</div>
<div class="line">  <span class="keyword">const</span> <a class="code hl_class" href="classVc_1_1Vector.html">int_v</a> right = a &gt;&gt; b;</div>
<div class="line">  a &lt;&lt;= b;</div>
<div class="line">}</div>
</div><!-- fragment --><dl class="section return"><dt>Returns</dt><dd>A vector object of the same type with the components filled according to a component-wise application of the operator. </dd></dl>
</div></td></tr>
<tr class="memitem:a564fd7b17aa3864da8fa42817317951a"><td class="memItemLeft" align="right" valign="top"><a id="a564fd7b17aa3864da8fa42817317951a" name="a564fd7b17aa3864da8fa42817317951a"></a>
<a class="el" href="classVc_1_1Vector.html">Vector</a>&#160;</td><td class="memItemRight" valign="bottom"><b>operator&lt;&lt;</b> (const <a class="el" href="classVc_1_1Vector.html">Vector</a> &amp;x) const</td></tr>
<tr class="separator:a564fd7b17aa3864da8fa42817317951a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61f8da95716e26765590baaf4a5e11a3"><td class="memItemLeft" align="right" valign="top"><a id="a61f8da95716e26765590baaf4a5e11a3" name="a61f8da95716e26765590baaf4a5e11a3"></a>
<a class="el" href="classVc_1_1Vector.html">Vector</a>&#160;</td><td class="memItemRight" valign="bottom"><b>operator&gt;&gt;</b> (const <a class="el" href="classVc_1_1Vector.html">Vector</a> &amp;x) const</td></tr>
<tr class="separator:a61f8da95716e26765590baaf4a5e11a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Comparisons</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p >All comparison operators return a mask object.</p>
<p >Example: </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> foo(<span class="keyword">const</span> <a class="code hl_class" href="classVc_1_1Vector.html">float_v</a> &amp;a, <span class="keyword">const</span> <a class="code hl_class" href="classVc_1_1Vector.html">float_v</a> &amp;b) {</div>
<div class="line">  <span class="keyword">const</span> <a class="code hl_class" href="classVc_1_1Mask.html">float_m</a> mask = a &lt; b;</div>
<div class="line">  ...</div>
<div class="line">}</div>
<div class="ttc" id="aclassVc_1_1Mask_html"><div class="ttname"><a href="classVc_1_1Mask.html">Vc::Mask</a></div><div class="ttdoc">The main SIMD mask class.</div><div class="ttdef"><b>Definition:</b> <a href="mask_8h_source.html#l00041">mask.h:42</a></div></div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>The vector to compare against. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A mask object. Its components contain the boolean results of the component-wise compare operation. </dd></dl>
</div></td></tr>
<tr class="memitem:a72146a8994e41ff49beb567ebc34c1bd"><td class="memItemLeft" align="right" valign="top"><a id="a72146a8994e41ff49beb567ebc34c1bd" name="a72146a8994e41ff49beb567ebc34c1bd"></a>
<a class="el" href="classVc_1_1Vector.html#a87ee111bfca7f15829e802bdf47c3b0e">MaskType</a>&#160;</td><td class="memItemRight" valign="bottom"><b>operator==</b> (const <a class="el" href="classVc_1_1Vector.html">Vector</a> &amp;x) const</td></tr>
<tr class="separator:a72146a8994e41ff49beb567ebc34c1bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c6b5632d6a2fdecfca05eb6a0344a90"><td class="memItemLeft" align="right" valign="top"><a id="a2c6b5632d6a2fdecfca05eb6a0344a90" name="a2c6b5632d6a2fdecfca05eb6a0344a90"></a>
<a class="el" href="classVc_1_1Vector.html#a87ee111bfca7f15829e802bdf47c3b0e">MaskType</a>&#160;</td><td class="memItemRight" valign="bottom"><b>operator!=</b> (const <a class="el" href="classVc_1_1Vector.html">Vector</a> &amp;x) const</td></tr>
<tr class="separator:a2c6b5632d6a2fdecfca05eb6a0344a90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae39bb9aaf6517490fa2395c36a3707fe"><td class="memItemLeft" align="right" valign="top"><a id="ae39bb9aaf6517490fa2395c36a3707fe" name="ae39bb9aaf6517490fa2395c36a3707fe"></a>
<a class="el" href="classVc_1_1Vector.html#a87ee111bfca7f15829e802bdf47c3b0e">MaskType</a>&#160;</td><td class="memItemRight" valign="bottom"><b>operator&lt;=</b> (const <a class="el" href="classVc_1_1Vector.html">Vector</a> &amp;x) const</td></tr>
<tr class="separator:ae39bb9aaf6517490fa2395c36a3707fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad86b5c2e988c73e475036a3652328ec"><td class="memItemLeft" align="right" valign="top"><a id="aad86b5c2e988c73e475036a3652328ec" name="aad86b5c2e988c73e475036a3652328ec"></a>
<a class="el" href="classVc_1_1Vector.html#a87ee111bfca7f15829e802bdf47c3b0e">MaskType</a>&#160;</td><td class="memItemRight" valign="bottom"><b>operator&gt;=</b> (const <a class="el" href="classVc_1_1Vector.html">Vector</a> &amp;x) const</td></tr>
<tr class="separator:aad86b5c2e988c73e475036a3652328ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4d35b6723c79ff7ae76dccfa5d2ae37"><td class="memItemLeft" align="right" valign="top"><a id="ab4d35b6723c79ff7ae76dccfa5d2ae37" name="ab4d35b6723c79ff7ae76dccfa5d2ae37"></a>
<a class="el" href="classVc_1_1Vector.html#a87ee111bfca7f15829e802bdf47c3b0e">MaskType</a>&#160;</td><td class="memItemRight" valign="bottom"><b>operator&lt;</b> (const <a class="el" href="classVc_1_1Vector.html">Vector</a> &amp;x) const</td></tr>
<tr class="separator:ab4d35b6723c79ff7ae76dccfa5d2ae37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f08300057cb4cc8dd876d49582c3871"><td class="memItemLeft" align="right" valign="top"><a id="a4f08300057cb4cc8dd876d49582c3871" name="a4f08300057cb4cc8dd876d49582c3871"></a>
<a class="el" href="classVc_1_1Vector.html#a87ee111bfca7f15829e802bdf47c3b0e">MaskType</a>&#160;</td><td class="memItemRight" valign="bottom"><b>operator&gt;</b> (const <a class="el" href="classVc_1_1Vector.html">Vector</a> &amp;x) const</td></tr>
<tr class="separator:a4f08300057cb4cc8dd876d49582c3871"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Horizontal Reduction Operations</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p >Horizontal operations can be used to reduce the values of a vector to a scalar value.</p>
<p >Example: </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> foo(<span class="keyword">const</span> <a class="code hl_class" href="classVc_1_1Vector.html">float_v</a> &amp;v) {</div>
<div class="line">  <span class="keywordtype">float</span> <a class="code hl_function" href="classVc_1_1Vector.html#ab32a053a2dfc6a1d7c05bbafbeb07401">min</a> = v.<a class="code hl_function" href="classVc_1_1Vector.html#ab32a053a2dfc6a1d7c05bbafbeb07401">min</a>(); <span class="comment">// smallest value in v</span></div>
<div class="line">  <span class="keywordtype">float</span> <a class="code hl_function" href="classVc_1_1Vector.html#a4dd96909332b97929d0670fb06226ba3">sum</a> = v.<a class="code hl_function" href="classVc_1_1Vector.html#a4dd96909332b97929d0670fb06226ba3">sum</a>(); <span class="comment">// sum of all values in v</span></div>
<div class="line">}</div>
<div class="ttc" id="aclassVc_1_1Vector_html_a4dd96909332b97929d0670fb06226ba3"><div class="ttname"><a href="classVc_1_1Vector.html#a4dd96909332b97929d0670fb06226ba3">Vc::Vector::sum</a></div><div class="ttdeci">EntryType sum() const</div><div class="ttdoc">Returns the sum of all entries in the vector.</div></div>
<div class="ttc" id="aclassVc_1_1Vector_html_ab32a053a2dfc6a1d7c05bbafbeb07401"><div class="ttname"><a href="classVc_1_1Vector.html#ab32a053a2dfc6a1d7c05bbafbeb07401">Vc::Vector::min</a></div><div class="ttdeci">EntryType min() const</div><div class="ttdoc">Returns the smallest entry in the vector.</div></div>
</div><!-- fragment --> </div></td></tr>
<tr class="memitem:ab32a053a2dfc6a1d7c05bbafbeb07401"><td class="memItemLeft" align="right" valign="top"><a id="ab32a053a2dfc6a1d7c05bbafbeb07401" name="ab32a053a2dfc6a1d7c05bbafbeb07401"></a>
<a class="el" href="classVc_1_1Vector.html#ae9cb6038cbd15cb0bdc596f5383c2b21">EntryType</a>&#160;</td><td class="memItemRight" valign="bottom"><b>min</b> () const</td></tr>
<tr class="memdesc:ab32a053a2dfc6a1d7c05bbafbeb07401"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the smallest entry in the vector. <br /></td></tr>
<tr class="separator:ab32a053a2dfc6a1d7c05bbafbeb07401"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a983d8ee43750effd70ab858bb4eb7ee9"><td class="memItemLeft" align="right" valign="top"><a id="a983d8ee43750effd70ab858bb4eb7ee9" name="a983d8ee43750effd70ab858bb4eb7ee9"></a>
<a class="el" href="classVc_1_1Vector.html#ae9cb6038cbd15cb0bdc596f5383c2b21">EntryType</a>&#160;</td><td class="memItemRight" valign="bottom"><b>max</b> () const</td></tr>
<tr class="memdesc:a983d8ee43750effd70ab858bb4eb7ee9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the largest entry in the vector. <br /></td></tr>
<tr class="separator:a983d8ee43750effd70ab858bb4eb7ee9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5df0e474de79e207072c337747ee2747"><td class="memItemLeft" align="right" valign="top"><a id="a5df0e474de79e207072c337747ee2747" name="a5df0e474de79e207072c337747ee2747"></a>
<a class="el" href="classVc_1_1Vector.html#ae9cb6038cbd15cb0bdc596f5383c2b21">EntryType</a>&#160;</td><td class="memItemRight" valign="bottom"><b>product</b> () const</td></tr>
<tr class="memdesc:a5df0e474de79e207072c337747ee2747"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the product of all entries in the vector. <br /></td></tr>
<tr class="separator:a5df0e474de79e207072c337747ee2747"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4dd96909332b97929d0670fb06226ba3"><td class="memItemLeft" align="right" valign="top"><a id="a4dd96909332b97929d0670fb06226ba3" name="a4dd96909332b97929d0670fb06226ba3"></a>
<a class="el" href="classVc_1_1Vector.html#ae9cb6038cbd15cb0bdc596f5383c2b21">EntryType</a>&#160;</td><td class="memItemRight" valign="bottom"><b>sum</b> () const</td></tr>
<tr class="memdesc:a4dd96909332b97929d0670fb06226ba3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the sum of all entries in the vector. <br /></td></tr>
<tr class="separator:a4dd96909332b97929d0670fb06226ba3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5fc64c02f551ed1950af782e9778978"><td class="memItemLeft" align="right" valign="top"><a id="ad5fc64c02f551ed1950af782e9778978" name="ad5fc64c02f551ed1950af782e9778978"></a>
<a class="el" href="classVc_1_1Vector.html">Vector</a>&#160;</td><td class="memItemRight" valign="bottom"><b>partialSum</b> () const</td></tr>
<tr class="memdesc:ad5fc64c02f551ed1950af782e9778978"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a vector containing the sum of all entries with smaller index. <br /></td></tr>
<tr class="separator:ad5fc64c02f551ed1950af782e9778978"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc247cea8d737545fab1520fe1d33bd7"><td class="memItemLeft" align="right" valign="top"><a id="adc247cea8d737545fab1520fe1d33bd7" name="adc247cea8d737545fab1520fe1d33bd7"></a>
<a class="el" href="classVc_1_1Vector.html#ae9cb6038cbd15cb0bdc596f5383c2b21">EntryType</a>&#160;</td><td class="memItemRight" valign="bottom"><b>min</b> (<a class="el" href="classVc_1_1Vector.html#a87ee111bfca7f15829e802bdf47c3b0e">MaskType</a> mask) const</td></tr>
<tr class="memdesc:adc247cea8d737545fab1520fe1d33bd7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the smallest entry of the vector components selected by <code>mask</code>. <br /></td></tr>
<tr class="separator:adc247cea8d737545fab1520fe1d33bd7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7acc17c0d0094fa240f0dde28ca3ce9"><td class="memItemLeft" align="right" valign="top"><a id="af7acc17c0d0094fa240f0dde28ca3ce9" name="af7acc17c0d0094fa240f0dde28ca3ce9"></a>
<a class="el" href="classVc_1_1Vector.html#ae9cb6038cbd15cb0bdc596f5383c2b21">EntryType</a>&#160;</td><td class="memItemRight" valign="bottom"><b>max</b> (<a class="el" href="classVc_1_1Vector.html#a87ee111bfca7f15829e802bdf47c3b0e">MaskType</a> mask) const</td></tr>
<tr class="memdesc:af7acc17c0d0094fa240f0dde28ca3ce9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the largest entry of the vector components selected by <code>mask</code>. <br /></td></tr>
<tr class="separator:af7acc17c0d0094fa240f0dde28ca3ce9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adee31e6331faed08938898381548cb8a"><td class="memItemLeft" align="right" valign="top"><a id="adee31e6331faed08938898381548cb8a" name="adee31e6331faed08938898381548cb8a"></a>
<a class="el" href="classVc_1_1Vector.html#ae9cb6038cbd15cb0bdc596f5383c2b21">EntryType</a>&#160;</td><td class="memItemRight" valign="bottom"><b>product</b> (<a class="el" href="classVc_1_1Vector.html#a87ee111bfca7f15829e802bdf47c3b0e">MaskType</a> mask) const</td></tr>
<tr class="memdesc:adee31e6331faed08938898381548cb8a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the product of the vector components selected by <code>mask</code>. <br /></td></tr>
<tr class="separator:adee31e6331faed08938898381548cb8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2575586df89cc07d8379f0ff7ed837c8"><td class="memItemLeft" align="right" valign="top"><a id="a2575586df89cc07d8379f0ff7ed837c8" name="a2575586df89cc07d8379f0ff7ed837c8"></a>
<a class="el" href="classVc_1_1Vector.html#ae9cb6038cbd15cb0bdc596f5383c2b21">EntryType</a>&#160;</td><td class="memItemRight" valign="bottom"><b>sum</b> (<a class="el" href="classVc_1_1Vector.html#a87ee111bfca7f15829e802bdf47c3b0e">MaskType</a> mask) const</td></tr>
<tr class="memdesc:a2575586df89cc07d8379f0ff7ed837c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the sum of the vector components selected by <code>mask</code>. <br /></td></tr>
<tr class="separator:a2575586df89cc07d8379f0ff7ed837c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Shift and Rotate</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p >These functions allow to shift or rotate the entries in a vector.</p>
<p >All functions with an <code>amount</code> parameter support positive and negative numbers for the shift/rotate value.</p>
<p >Example: </p><div class="fragment"><div class="line"><span class="keyword">using namespace </span><a class="code hl_namespace" href="namespaceVc.html">Vc</a>;</div>
<div class="line"><a class="code hl_class" href="classVc_1_1Vector.html">int_v</a> foo = <a class="code hl_function" href="classVc_1_1Vector.html#a493fd531cf26bec9f8b40740ab110eec">int_v::IndexesFromZero</a>() + 1; <span class="comment">// e.g. [1, 2, 3, 4] with SSE</span></div>
<div class="line"><a class="code hl_class" href="classVc_1_1Vector.html">int_v</a> x;</div>
<div class="line">x = foo.<a class="code hl_function" href="classVc_1_1Vector.html#a5bdf5c1bbc0f77f759ca74b4ae7575b7">shifted</a>( 1); <span class="comment">// [2, 3, 4, 0]</span></div>
<div class="line">x = foo.<a class="code hl_function" href="classVc_1_1Vector.html#a5bdf5c1bbc0f77f759ca74b4ae7575b7">shifted</a>( 2); <span class="comment">// [3, 4, 0, 0]</span></div>
<div class="line">x = foo.<a class="code hl_function" href="classVc_1_1Vector.html#a5bdf5c1bbc0f77f759ca74b4ae7575b7">shifted</a>( 3); <span class="comment">// [4, 0, 0, 0]</span></div>
<div class="line">x = foo.<a class="code hl_function" href="classVc_1_1Vector.html#a5bdf5c1bbc0f77f759ca74b4ae7575b7">shifted</a>( 4); <span class="comment">// [0, 0, 0, 0]</span></div>
<div class="line">x = foo.<a class="code hl_function" href="classVc_1_1Vector.html#a5bdf5c1bbc0f77f759ca74b4ae7575b7">shifted</a>(-1); <span class="comment">// [0, 1, 2, 3]</span></div>
<div class="line">x = foo.<a class="code hl_function" href="classVc_1_1Vector.html#a5bdf5c1bbc0f77f759ca74b4ae7575b7">shifted</a>(-2); <span class="comment">// [0, 0, 1, 2]</span></div>
<div class="line">x = foo.<a class="code hl_function" href="classVc_1_1Vector.html#a5bdf5c1bbc0f77f759ca74b4ae7575b7">shifted</a>(-3); <span class="comment">// [0, 0, 0, 1]</span></div>
<div class="line">x = foo.<a class="code hl_function" href="classVc_1_1Vector.html#a5bdf5c1bbc0f77f759ca74b4ae7575b7">shifted</a>(-4); <span class="comment">// [0, 0, 0, 0]</span></div>
<div class="line"> </div>
<div class="line">x = foo.<a class="code hl_function" href="classVc_1_1Vector.html#aa2b7e7c8caa6d48d1bc887c53680940b">rotated</a>( 1); <span class="comment">// [2, 3, 4, 1]</span></div>
<div class="line">x = foo.<a class="code hl_function" href="classVc_1_1Vector.html#aa2b7e7c8caa6d48d1bc887c53680940b">rotated</a>( 2); <span class="comment">// [3, 4, 1, 2]</span></div>
<div class="line">x = foo.<a class="code hl_function" href="classVc_1_1Vector.html#aa2b7e7c8caa6d48d1bc887c53680940b">rotated</a>( 3); <span class="comment">// [4, 1, 2, 3]</span></div>
<div class="line">x = foo.<a class="code hl_function" href="classVc_1_1Vector.html#aa2b7e7c8caa6d48d1bc887c53680940b">rotated</a>( 4); <span class="comment">// [1, 2, 3, 4]</span></div>
<div class="line">x = foo.<a class="code hl_function" href="classVc_1_1Vector.html#aa2b7e7c8caa6d48d1bc887c53680940b">rotated</a>(-1); <span class="comment">// [4, 1, 2, 3]</span></div>
<div class="line">x = foo.<a class="code hl_function" href="classVc_1_1Vector.html#aa2b7e7c8caa6d48d1bc887c53680940b">rotated</a>(-2); <span class="comment">// [3, 4, 1, 2]</span></div>
<div class="line">x = foo.<a class="code hl_function" href="classVc_1_1Vector.html#aa2b7e7c8caa6d48d1bc887c53680940b">rotated</a>(-3); <span class="comment">// [2, 3, 4, 1]</span></div>
<div class="line">x = foo.<a class="code hl_function" href="classVc_1_1Vector.html#aa2b7e7c8caa6d48d1bc887c53680940b">rotated</a>(-4); <span class="comment">// [1, 2, 3, 4]</span></div>
<div class="ttc" id="aclassVc_1_1Vector_html_a493fd531cf26bec9f8b40740ab110eec"><div class="ttname"><a href="classVc_1_1Vector.html#a493fd531cf26bec9f8b40740ab110eec">Vc::Vector::IndexesFromZero</a></div><div class="ttdeci">static Vector IndexesFromZero()</div><div class="ttdoc">Returns a vector with the entries initialized to 0, 1, 2, 3, 4, 5, ...</div></div>
<div class="ttc" id="aclassVc_1_1Vector_html_a5bdf5c1bbc0f77f759ca74b4ae7575b7"><div class="ttname"><a href="classVc_1_1Vector.html#a5bdf5c1bbc0f77f759ca74b4ae7575b7">Vc::Vector::shifted</a></div><div class="ttdeci">Vector shifted(int amount) const</div><div class="ttdoc">Shift vector entries to the left by amount; shifting in zeros.</div></div>
<div class="ttc" id="aclassVc_1_1Vector_html_aa2b7e7c8caa6d48d1bc887c53680940b"><div class="ttname"><a href="classVc_1_1Vector.html#aa2b7e7c8caa6d48d1bc887c53680940b">Vc::Vector::rotated</a></div><div class="ttdeci">Vector rotated(int amount) const</div><div class="ttdoc">Rotate vector entries to the left by amount.</div></div>
<div class="ttc" id="anamespaceVc_html"><div class="ttname"><a href="namespaceVc.html">Vc</a></div><div class="ttdoc">Vector Classes Namespace.</div><div class="ttdef"><b>Definition:</b> <a href="dox_8h_source.html#l00584">dox.h:585</a></div></div>
</div><!-- fragment --><p >These functions are slightly related to the above swizzles. In any case, they are often useful for communication between SIMD lanes or binary decoding operations.</p>
<dl class="section warning"><dt>Warning</dt><dd>Use of these functions leads to less portable code. Consider the scalar implementation where every vector has only one entry. The shift and rotate functions have no useful task to fulfil there and you will almost certainly not get any useful results. It is recommended to add a static_assert for the assumed minimum vector size. </dd></dl>
</div></td></tr>
<tr class="memitem:a5bdf5c1bbc0f77f759ca74b4ae7575b7"><td class="memItemLeft" align="right" valign="top"><a id="a5bdf5c1bbc0f77f759ca74b4ae7575b7" name="a5bdf5c1bbc0f77f759ca74b4ae7575b7"></a>
<a class="el" href="classVc_1_1Vector.html">Vector</a>&#160;</td><td class="memItemRight" valign="bottom"><b>shifted</b> (int amount) const</td></tr>
<tr class="memdesc:a5bdf5c1bbc0f77f759ca74b4ae7575b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shift vector entries to the left by <code>amount</code>; shifting in zeros. <br /></td></tr>
<tr class="separator:a5bdf5c1bbc0f77f759ca74b4ae7575b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afdb6c4a5bfb9cd53ca1f4dff4757a334"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classVc_1_1Vector.html">Vector</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVc_1_1Vector.html#afdb6c4a5bfb9cd53ca1f4dff4757a334">shifted</a> (int amount, <a class="el" href="classVc_1_1Vector.html">Vector</a> shiftIn) const</td></tr>
<tr class="memdesc:afdb6c4a5bfb9cd53ca1f4dff4757a334"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shift vector entries to the left by <code>amount</code>; shifting in values from shiftIn (instead of zeros).  <a href="classVc_1_1Vector.html#afdb6c4a5bfb9cd53ca1f4dff4757a334">More...</a><br /></td></tr>
<tr class="separator:afdb6c4a5bfb9cd53ca1f4dff4757a334"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2b7e7c8caa6d48d1bc887c53680940b"><td class="memItemLeft" align="right" valign="top"><a id="aa2b7e7c8caa6d48d1bc887c53680940b" name="aa2b7e7c8caa6d48d1bc887c53680940b"></a>
<a class="el" href="classVc_1_1Vector.html">Vector</a>&#160;</td><td class="memItemRight" valign="bottom"><b>rotated</b> (int amount) const</td></tr>
<tr class="memdesc:aa2b7e7c8caa6d48d1bc887c53680940b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rotate vector entries to the left by <code>amount</code>. <br /></td></tr>
<tr class="separator:aa2b7e7c8caa6d48d1bc887c53680940b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6847c7c6abdaba8bc68c919fc995739"><td class="memItemLeft" align="right" valign="top"><a id="ac6847c7c6abdaba8bc68c919fc995739" name="ac6847c7c6abdaba8bc68c919fc995739"></a>
<a class="el" href="classVc_1_1Vector.html">Vector</a>&#160;</td><td class="memItemRight" valign="bottom"><b>reversed</b> () const</td></tr>
<tr class="memdesc:ac6847c7c6abdaba8bc68c919fc995739"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a vector with all components reversed. <br /></td></tr>
<tr class="separator:ac6847c7c6abdaba8bc68c919fc995739"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Apply/Call/Fill Functions</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p >There are still many situations where the code needs to switch from SIMD operations to scalar execution. In this case you can, of course rely on operator[]. But there are also a number of functions that can help with common patterns.</p>
<p >The apply functions expect a function that returns a scalar value, i.e. a function of the form "T f(T)". The call functions do not return a value and thus the function passed does not need a return value. The fill functions are used to serially set the entries of the vector from the return values of a function.</p>
<p >Example: </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> foo(<a class="code hl_class" href="classVc_1_1Vector.html">float_v</a> v) {</div>
<div class="line">  <a class="code hl_class" href="classVc_1_1Vector.html">float_v</a> logarithm = v.<a class="code hl_function" href="classVc_1_1Vector.html#a84ab055071e250a799aff117622e17c8">apply</a>(<a class="code hl_function" href="group__SimdArray.html#ga50ca5d42dc4bfd9125c82d9489785fb3">std::log</a>);</div>
<div class="line">  <a class="code hl_class" href="classVc_1_1Vector.html">float_v</a> exponential = v.<a class="code hl_function" href="classVc_1_1Vector.html#a84ab055071e250a799aff117622e17c8">apply</a>(<a class="code hl_function" href="group__SimdArray.html#ga10fdc8103aef52c55d562c3470dc9613">std::exp</a>);</div>
<div class="line">}</div>
<div class="ttc" id="aclassVc_1_1Vector_html_a84ab055071e250a799aff117622e17c8"><div class="ttname"><a href="classVc_1_1Vector.html#a84ab055071e250a799aff117622e17c8">Vc::Vector::apply</a></div><div class="ttdeci">Vector apply(F &amp;&amp;f) const</div><div class="ttdoc">Call f on every entry of the vector and return the results as a new vector.</div></div>
<div class="ttc" id="agroup__SimdArray_html_ga10fdc8103aef52c55d562c3470dc9613"><div class="ttname"><a href="group__SimdArray.html#ga10fdc8103aef52c55d562c3470dc9613">Vc::exp</a></div><div class="ttdeci">fixed_size_simd&lt; T, N &gt; exp(const SimdArray&lt; T, N, V, M &gt; &amp;x)</div><div class="ttdoc">Applies the std:: exp function component-wise and concurrently.</div><div class="ttdef"><b>Definition:</b> <a href="simdarray_8h_source.html#l01813">simdarray.h:1813</a></div></div>
<div class="ttc" id="agroup__SimdArray_html_ga50ca5d42dc4bfd9125c82d9489785fb3"><div class="ttname"><a href="group__SimdArray.html#ga50ca5d42dc4bfd9125c82d9489785fb3">Vc::log</a></div><div class="ttdeci">fixed_size_simd&lt; T, N &gt; log(const SimdArray&lt; T, N, V, M &gt; &amp;x)</div><div class="ttdoc">Applies the std:: log function component-wise and concurrently.</div><div class="ttdef"><b>Definition:</b> <a href="simdarray_8h_source.html#l01839">simdarray.h:1839</a></div></div>
</div><!-- fragment --><p >Of course, you can also use lambdas here: </p><div class="fragment"><div class="line"><a class="code hl_class" href="classVc_1_1Vector.html">float_v</a> power = v.<a class="code hl_function" href="classVc_1_1Vector.html#a84ab055071e250a799aff117622e17c8">apply</a>([](<span class="keywordtype">float</span> f) { <span class="keywordflow">return</span> std::pow(f, 0.6f); })</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>A functor: this can either be a function or an object that implements operator(). </td></tr>
  </table>
  </dd>
</dl>
</div></td></tr>
<tr class="memitem:a7bbbd599986b37877a01ddb346d7eb6b"><td class="memTemplParams" colspan="2"><a id="a7bbbd599986b37877a01ddb346d7eb6b" name="a7bbbd599986b37877a01ddb346d7eb6b"></a>
template&lt;typename F &gt; </td></tr>
<tr class="memitem:a7bbbd599986b37877a01ddb346d7eb6b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>callWithValuesSorted</b> (F &amp;&amp;f)</td></tr>
<tr class="memdesc:a7bbbd599986b37877a01ddb346d7eb6b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Call <code>f</code> sequentially, starting with the minimum up to the maximum value. <br /></td></tr>
<tr class="separator:a7bbbd599986b37877a01ddb346d7eb6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a625b4ad82b3faa6d38cc7a1807e168ce"><td class="memTemplParams" colspan="2"><a id="a625b4ad82b3faa6d38cc7a1807e168ce" name="a625b4ad82b3faa6d38cc7a1807e168ce"></a>
template&lt;typename F &gt; </td></tr>
<tr class="memitem:a625b4ad82b3faa6d38cc7a1807e168ce"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>call</b> (F &amp;&amp;f) const</td></tr>
<tr class="memdesc:a625b4ad82b3faa6d38cc7a1807e168ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Call <code>f</code> with the scalar entries of the vector. <br /></td></tr>
<tr class="separator:a625b4ad82b3faa6d38cc7a1807e168ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46c8bf4231a6a16dc0b3a118703ce866"><td class="memTemplParams" colspan="2"><a id="a46c8bf4231a6a16dc0b3a118703ce866" name="a46c8bf4231a6a16dc0b3a118703ce866"></a>
template&lt;typename F &gt; </td></tr>
<tr class="memitem:a46c8bf4231a6a16dc0b3a118703ce866"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>call</b> (F &amp;&amp;f, <a class="el" href="classVc_1_1Vector.html#a87ee111bfca7f15829e802bdf47c3b0e">MaskType</a> mask) const</td></tr>
<tr class="memdesc:a46c8bf4231a6a16dc0b3a118703ce866"><td class="mdescLeft">&#160;</td><td class="mdescRight">As above, but skip the entries where <code>mask</code> is not set. <br /></td></tr>
<tr class="separator:a46c8bf4231a6a16dc0b3a118703ce866"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84ab055071e250a799aff117622e17c8"><td class="memTemplParams" colspan="2"><a id="a84ab055071e250a799aff117622e17c8" name="a84ab055071e250a799aff117622e17c8"></a>
template&lt;typename F &gt; </td></tr>
<tr class="memitem:a84ab055071e250a799aff117622e17c8"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classVc_1_1Vector.html">Vector</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>apply</b> (F &amp;&amp;f) const</td></tr>
<tr class="memdesc:a84ab055071e250a799aff117622e17c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Call <code>f</code> on every entry of the vector and return the results as a new vector. <br /></td></tr>
<tr class="separator:a84ab055071e250a799aff117622e17c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32e471c5a08ae8be318a6a483edf45f5"><td class="memTemplParams" colspan="2"><a id="a32e471c5a08ae8be318a6a483edf45f5" name="a32e471c5a08ae8be318a6a483edf45f5"></a>
template&lt;typename F &gt; </td></tr>
<tr class="memitem:a32e471c5a08ae8be318a6a483edf45f5"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classVc_1_1Vector.html">Vector</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>apply</b> (F &amp;&amp;f, <a class="el" href="classVc_1_1Vector.html#a87ee111bfca7f15829e802bdf47c3b0e">MaskType</a> mask) const</td></tr>
<tr class="memdesc:a32e471c5a08ae8be318a6a483edf45f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">As above, but skip the entries where <code>mask</code> is not set. <br /></td></tr>
<tr class="separator:a32e471c5a08ae8be318a6a483edf45f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8edc8793d6e89447dd5de0d4327679f0"><td class="memTemplParams" colspan="2"><a id="a8edc8793d6e89447dd5de0d4327679f0" name="a8edc8793d6e89447dd5de0d4327679f0"></a>
template&lt;typename IndexT &gt; </td></tr>
<tr class="memitem:a8edc8793d6e89447dd5de0d4327679f0"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>fill</b> (<a class="el" href="classVc_1_1Vector.html#ae9cb6038cbd15cb0bdc596f5383c2b21">EntryType</a>(&amp;f)(IndexT))</td></tr>
<tr class="memdesc:a8edc8793d6e89447dd5de0d4327679f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fill the vector with the values [f(0), f(1), f(2), ...]. <br /></td></tr>
<tr class="separator:a8edc8793d6e89447dd5de0d4327679f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33560de8b962a95e9036d47ec195f3ab"><td class="memItemLeft" align="right" valign="top"><a id="a33560de8b962a95e9036d47ec195f3ab" name="a33560de8b962a95e9036d47ec195f3ab"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>fill</b> (<a class="el" href="classVc_1_1Vector.html#ae9cb6038cbd15cb0bdc596f5383c2b21">EntryType</a>(&amp;f)())</td></tr>
<tr class="memdesc:a33560de8b962a95e9036d47ec195f3ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fill the vector with the values [f(), f(), f(), ...]. <br /></td></tr>
<tr class="separator:a33560de8b962a95e9036d47ec195f3ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr><td colspan="2"><div class="groupHeader">new/delete overloads for correct alignment</div></td></tr>
<tr class="memitem:a160dcabc54bbecfc69484678cafadb81"><td class="memItemLeft" align="right" valign="top"><a id="a160dcabc54bbecfc69484678cafadb81" name="a160dcabc54bbecfc69484678cafadb81"></a>
void *&#160;</td><td class="memItemRight" valign="bottom"><b>operator new</b> (size_t <a class="el" href="classVc_1_1Vector.html#a1b5d7e2e663d7997796fd9f72b8af75a">size</a>)</td></tr>
<tr class="memdesc:a160dcabc54bbecfc69484678cafadb81"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocates correctly aligned memory. <br /></td></tr>
<tr class="separator:a160dcabc54bbecfc69484678cafadb81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac15c9ad7f49147e20d631483c08a35be"><td class="memItemLeft" align="right" valign="top"><a id="ac15c9ad7f49147e20d631483c08a35be" name="ac15c9ad7f49147e20d631483c08a35be"></a>
void *&#160;</td><td class="memItemRight" valign="bottom"><b>operator new</b> (size_t, void *p)</td></tr>
<tr class="memdesc:ac15c9ad7f49147e20d631483c08a35be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>p</code>. <br /></td></tr>
<tr class="separator:ac15c9ad7f49147e20d631483c08a35be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2243bb4c2126b7b2b393e06090fbe59"><td class="memItemLeft" align="right" valign="top"><a id="af2243bb4c2126b7b2b393e06090fbe59" name="af2243bb4c2126b7b2b393e06090fbe59"></a>
void *&#160;</td><td class="memItemRight" valign="bottom"><b>operator new[]</b> (size_t <a class="el" href="classVc_1_1Vector.html#a1b5d7e2e663d7997796fd9f72b8af75a">size</a>)</td></tr>
<tr class="memdesc:af2243bb4c2126b7b2b393e06090fbe59"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocates correctly aligned memory. <br /></td></tr>
<tr class="separator:af2243bb4c2126b7b2b393e06090fbe59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7029f8f4c92db165d922eb024b5a21ac"><td class="memItemLeft" align="right" valign="top"><a id="a7029f8f4c92db165d922eb024b5a21ac" name="a7029f8f4c92db165d922eb024b5a21ac"></a>
void *&#160;</td><td class="memItemRight" valign="bottom"><b>operator new[]</b> (size_t, void *p)</td></tr>
<tr class="memdesc:a7029f8f4c92db165d922eb024b5a21ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>p</code>. <br /></td></tr>
<tr class="separator:a7029f8f4c92db165d922eb024b5a21ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22999735d5b1e1cb645614d22f108611"><td class="memItemLeft" align="right" valign="top"><a id="a22999735d5b1e1cb645614d22f108611" name="a22999735d5b1e1cb645614d22f108611"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>operator delete</b> (void *ptr, size_t)</td></tr>
<tr class="memdesc:a22999735d5b1e1cb645614d22f108611"><td class="mdescLeft">&#160;</td><td class="mdescRight">Frees aligned memory. <br /></td></tr>
<tr class="separator:a22999735d5b1e1cb645614d22f108611"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41d83e8020f1d841b254be6ebeda92d2"><td class="memItemLeft" align="right" valign="top"><a id="a41d83e8020f1d841b254be6ebeda92d2" name="a41d83e8020f1d841b254be6ebeda92d2"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>operator delete</b> (void *, void *)</td></tr>
<tr class="memdesc:a41d83e8020f1d841b254be6ebeda92d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Does nothing. <br /></td></tr>
<tr class="separator:a41d83e8020f1d841b254be6ebeda92d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abefd12c9bd2fa9cd4a27cdabf64b03f8"><td class="memItemLeft" align="right" valign="top"><a id="abefd12c9bd2fa9cd4a27cdabf64b03f8" name="abefd12c9bd2fa9cd4a27cdabf64b03f8"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>operator delete[]</b> (void *ptr, size_t)</td></tr>
<tr class="memdesc:abefd12c9bd2fa9cd4a27cdabf64b03f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Frees aligned memory. <br /></td></tr>
<tr class="separator:abefd12c9bd2fa9cd4a27cdabf64b03f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afea8decef8f286c8d73c89a1a81d4555"><td class="memItemLeft" align="right" valign="top"><a id="afea8decef8f286c8d73c89a1a81d4555" name="afea8decef8f286c8d73c89a1a81d4555"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>operator delete[]</b> (void *, void *)</td></tr>
<tr class="memdesc:afea8decef8f286c8d73c89a1a81d4555"><td class="mdescLeft">&#160;</td><td class="mdescRight">Does nothing. <br /></td></tr>
<tr class="separator:afea8decef8f286c8d73c89a1a81d4555"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-methods" name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a1b5d7e2e663d7997796fd9f72b8af75a"><td class="memItemLeft" align="right" valign="top">static constexpr size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVc_1_1Vector.html#a1b5d7e2e663d7997796fd9f72b8af75a">size</a> ()</td></tr>
<tr class="memdesc:a1b5d7e2e663d7997796fd9f72b8af75a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of scalar components ( \(\mathcal{W}_\mathtt{T}\)) in a vector of this type.  <a href="classVc_1_1Vector.html#a1b5d7e2e663d7997796fd9f72b8af75a">More...</a><br /></td></tr>
<tr class="separator:a1b5d7e2e663d7997796fd9f72b8af75a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Generators</div></td></tr>
<tr class="memitem:af9c6cd3201b97b6c86d64a3b25e584d7"><td class="memItemLeft" align="right" valign="top"><a id="af9c6cd3201b97b6c86d64a3b25e584d7" name="af9c6cd3201b97b6c86d64a3b25e584d7"></a>
static <a class="el" href="classVc_1_1Vector.html">Vector</a>&#160;</td><td class="memItemRight" valign="bottom"><b>Zero</b> ()</td></tr>
<tr class="memdesc:af9c6cd3201b97b6c86d64a3b25e584d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a vector with the entries initialized to zero. <br /></td></tr>
<tr class="separator:af9c6cd3201b97b6c86d64a3b25e584d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b767a2e7fd19f79be9616be32128bea"><td class="memItemLeft" align="right" valign="top"><a id="a4b767a2e7fd19f79be9616be32128bea" name="a4b767a2e7fd19f79be9616be32128bea"></a>
static <a class="el" href="classVc_1_1Vector.html">Vector</a>&#160;</td><td class="memItemRight" valign="bottom"><b>One</b> ()</td></tr>
<tr class="memdesc:a4b767a2e7fd19f79be9616be32128bea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a vector with the entries initialized to one. <br /></td></tr>
<tr class="separator:a4b767a2e7fd19f79be9616be32128bea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a493fd531cf26bec9f8b40740ab110eec"><td class="memItemLeft" align="right" valign="top"><a id="a493fd531cf26bec9f8b40740ab110eec" name="a493fd531cf26bec9f8b40740ab110eec"></a>
static <a class="el" href="classVc_1_1Vector.html">Vector</a>&#160;</td><td class="memItemRight" valign="bottom"><b>IndexesFromZero</b> ()</td></tr>
<tr class="memdesc:a493fd531cf26bec9f8b40740ab110eec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a vector with the entries initialized to 0, 1, 2, 3, 4, 5, ... <br /></td></tr>
<tr class="separator:a493fd531cf26bec9f8b40740ab110eec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa7aece82798960b1144c030e4c8f6cc"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classVc_1_1Vector.html">Vector</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVc_1_1Vector.html#aaa7aece82798960b1144c030e4c8f6cc">Random</a> ()</td></tr>
<tr class="memdesc:aaa7aece82798960b1144c030e4c8f6cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a vector with pseudo-random entries.  <a href="classVc_1_1Vector.html#aaa7aece82798960b1144c030e4c8f6cc">More...</a><br /></td></tr>
<tr class="separator:aaa7aece82798960b1144c030e4c8f6cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa971522e6fe26e874ac131bf57990280"><td class="memTemplParams" colspan="2"><a id="aa971522e6fe26e874ac131bf57990280" name="aa971522e6fe26e874ac131bf57990280"></a>
template&lt;typename G &gt; </td></tr>
<tr class="memitem:aa971522e6fe26e874ac131bf57990280"><td class="memTemplItemLeft" align="right" valign="top">static <a class="el" href="classVc_1_1Vector.html">Vector</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>generate</b> (G gen)</td></tr>
<tr class="memdesc:aa971522e6fe26e874ac131bf57990280"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate a vector object from return values of <code>gen</code> (static variant of <a class="el" href="classVc_1_1Vector.html#a8edc8793d6e89447dd5de0d4327679f0">fill</a>). <br /></td></tr>
<tr class="separator:aa971522e6fe26e874ac131bf57990280"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-attribs" name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:a9d80568e435be601eb87ade3966eda21"><td class="memItemLeft" align="right" valign="top"><a id="a9d80568e435be601eb87ade3966eda21" name="a9d80568e435be601eb87ade3966eda21"></a>
static constexpr size_t&#160;</td><td class="memItemRight" valign="bottom"><b>MemoryAlignment</b> = VectorTraits&lt;T, Abi&gt;::memoryAlignment()</td></tr>
<tr class="memdesc:a9d80568e435be601eb87ade3966eda21"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specifies the alignment requirement for aligned load and store calls for objects of this vector type. <br /></td></tr>
<tr class="separator:a9d80568e435be601eb87ade3966eda21"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Deprecated Members</h2></td></tr>
<tr class="memitem:a879ad9933a419e4e04c8a59cc19a34fe"><td class="memItemLeft" align="right" valign="top">static constexpr size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVc_1_1Vector.html#a879ad9933a419e4e04c8a59cc19a34fe">Size</a> = VectorTraits&lt;T, Abi&gt;<a class="el" href="classVc_1_1Vector.html#a1b5d7e2e663d7997796fd9f72b8af75a">::size</a>()</td></tr>
<tr class="memdesc:a879ad9933a419e4e04c8a59cc19a34fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of scalar components ( \(\mathcal{W}_\mathtt{T}\)) in a vector of this type.  <a href="classVc_1_1Vector.html#a879ad9933a419e4e04c8a59cc19a34fe">More...</a><br /></td></tr>
<tr class="separator:a879ad9933a419e4e04c8a59cc19a34fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ad66c6a651853ac3ad5321ceb1df81a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classVc_1_1Vector.html">Vector</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVc_1_1Vector.html#a8ad66c6a651853ac3ad5321ceb1df81a">exponent</a> () const</td></tr>
<tr class="memdesc:a8ad66c6a651853ac3ad5321ceb1df81a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the exponents of the floating-point values in the vector.  <a href="classVc_1_1Vector.html#a8ad66c6a651853ac3ad5321ceb1df81a">More...</a><br /></td></tr>
<tr class="separator:a8ad66c6a651853ac3ad5321ceb1df81a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00a3bc44083d6e538e07480fd62e8706"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classVc_1_1Vector.html#a87ee111bfca7f15829e802bdf47c3b0e">MaskType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVc_1_1Vector.html#a00a3bc44083d6e538e07480fd62e8706">isNegative</a> () const</td></tr>
<tr class="memdesc:a00a3bc44083d6e538e07480fd62e8706"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether a value is negative.  <a href="classVc_1_1Vector.html#a00a3bc44083d6e538e07480fd62e8706">More...</a><br /></td></tr>
<tr class="separator:a00a3bc44083d6e538e07480fd62e8706"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c106f645d37a156a2f1d72762d8778d"><td class="memTemplParams" colspan="2">template&lt;typename V2 &gt; </td></tr>
<tr class="memitem:a6c106f645d37a156a2f1d72762d8778d"><td class="memTemplItemLeft" align="right" valign="top">V2&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classVc_1_1Vector.html#a6c106f645d37a156a2f1d72762d8778d">staticCast</a> () const</td></tr>
<tr class="memdesc:a6c106f645d37a156a2f1d72762d8778d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Casts the current object to <code>V2</code>.  <a href="classVc_1_1Vector.html#a6c106f645d37a156a2f1d72762d8778d">More...</a><br /></td></tr>
<tr class="separator:a6c106f645d37a156a2f1d72762d8778d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31613f5108247dee39ac6055cc96c22f"><td class="memTemplParams" colspan="2">template&lt;typename V2 &gt; </td></tr>
<tr class="memitem:a31613f5108247dee39ac6055cc96c22f"><td class="memTemplItemLeft" align="right" valign="top">V2&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classVc_1_1Vector.html#a31613f5108247dee39ac6055cc96c22f">reinterpretCast</a> () const</td></tr>
<tr class="memdesc:a31613f5108247dee39ac6055cc96c22f"><td class="mdescLeft">&#160;</td><td class="mdescRight">reinterpret_cast the vector components to construct a vector of type <code>V2</code>.  <a href="classVc_1_1Vector.html#a31613f5108247dee39ac6055cc96c22f">More...</a><br /></td></tr>
<tr class="separator:a31613f5108247dee39ac6055cc96c22f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a258c4bdfbbce0ee25b2642fdd7ba4b92"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classVc_1_1Vector.html">Vector</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVc_1_1Vector.html#a258c4bdfbbce0ee25b2642fdd7ba4b92">copySign</a> (<a class="el" href="classVc_1_1Vector.html">Vector</a> reference) const</td></tr>
<tr class="memdesc:a258c4bdfbbce0ee25b2642fdd7ba4b92"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies the signs of the components of <code>reference</code> to the components of the current vector, returning the result.  <a href="classVc_1_1Vector.html#a258c4bdfbbce0ee25b2642fdd7ba4b92">More...</a><br /></td></tr>
<tr class="separator:a258c4bdfbbce0ee25b2642fdd7ba4b92"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Member Typedef Documentation</h2>
<a id="af58a233cf0cdf62369686dd5798bd589" name="af58a233cf0cdf62369686dd5798bd589"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af58a233cf0cdf62369686dd5798bd589">&#9670;&nbsp;</a></span>value_type</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classVc_1_1Vector.html#af58a233cf0cdf62369686dd5798bd589">value_type</a> =  <a class="el" href="classVc_1_1Vector.html#ae9cb6038cbd15cb0bdc596f5383c2b21">EntryType</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The type of the entries in the vector. </p>

<p class="definition">Definition at line <a class="el" href="common_2vector_8h_source.html#l00156">156</a> of file <a class="el" href="common_2vector_8h_source.html">vector.h</a>.</p>

</div>
</div>
<a id="abffe464ff20f5933e5a50b699555fa5f" name="abffe464ff20f5933e5a50b699555fa5f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abffe464ff20f5933e5a50b699555fa5f">&#9670;&nbsp;</a></span>mask_type</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classVc_1_1Vector.html#abffe464ff20f5933e5a50b699555fa5f">mask_type</a> =  <a class="el" href="classVc_1_1Vector.html#a87ee111bfca7f15829e802bdf47c3b0e">MaskType</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The type of the mask used for masked operations and returned from comparisons. </p>

<p class="definition">Definition at line <a class="el" href="common_2vector_8h_source.html#l00171">171</a> of file <a class="el" href="common_2vector_8h_source.html">vector.h</a>.</p>

</div>
</div>
<a id="a2eaac791c05f06627d44f9438059b1ab" name="a2eaac791c05f06627d44f9438059b1ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2eaac791c05f06627d44f9438059b1ab">&#9670;&nbsp;</a></span>index_type</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classVc_1_1Vector.html#a2eaac791c05f06627d44f9438059b1ab">index_type</a> =  <a class="el" href="classVc_1_1Vector.html#a00b1721fbbac37b8c884b6347af3ce70">IndexType</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The type of the vector used for indexes in gather and scatter operations. </p>

<p class="definition">Definition at line <a class="el" href="common_2vector_8h_source.html#l00179">179</a> of file <a class="el" href="common_2vector_8h_source.html">vector.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="aba83f7828d95b601500471996fc8c3c0" name="aba83f7828d95b601500471996fc8c3c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba83f7828d95b601500471996fc8c3c0">&#9670;&nbsp;</a></span>Vector() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVc_1_1Vector.html">Vector</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct a zero-initialized vector object. </p>
<p >This constructor follows the behavior of the underlying arithmetic type <code>T</code> in that the expression <code>T()</code> zero-initializes the object. On the other hand the variable <code>x</code> in <code>T x;</code> is uninitialized. Since, for class types, both expressions call the default constructor <code><a class="el" href="classVc_1_1Vector.html" title="The main vector class for expressing data parallelism.">Vector</a>&lt;T&gt; x</code> must zero-initialize <code>x</code> as well. </p>

</div>
</div>
<a id="a4b959c60986675489b915cd33ffa1a65" name="a4b959c60986675489b915cd33ffa1a65"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b959c60986675489b915cd33ffa1a65">&#9670;&nbsp;</a></span>Vector() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVc_1_1Vector.html">Vector</a> </td>
          <td>(</td>
          <td class="paramtype">VectorSpecialInitializerZero&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct a vector with the entries initialized to zero. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__Utilities.html#gad24df8f04b4b68f7e992aeb8b449cdf2" title="The special object Vc::Zero can be used to construct Vector and Mask objects initialized to zero/fals...">Vc::Zero</a>, <a class="el" href="classVc_1_1Vector.html#af9c6cd3201b97b6c86d64a3b25e584d7" title="Returns a vector with the entries initialized to zero.">Zero()</a> </dd></dl>

</div>
</div>
<a id="ac6faca3e9ae02f4e213bad11cb860e20" name="ac6faca3e9ae02f4e213bad11cb860e20"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac6faca3e9ae02f4e213bad11cb860e20">&#9670;&nbsp;</a></span>Vector() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVc_1_1Vector.html">Vector</a> </td>
          <td>(</td>
          <td class="paramtype">VectorSpecialInitializerOne&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct a vector with the entries initialized to one. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__Utilities.html#ga7dc0e380f66c4c791b7bf95df154b3c6" title="The special object Vc::One can be used to construct Vector and Mask objects initialized to one/true.">Vc::One</a>, <a class="el" href="classVc_1_1Vector.html#a4b767a2e7fd19f79be9616be32128bea" title="Returns a vector with the entries initialized to one.">One()</a> </dd></dl>

</div>
</div>
<a id="a9c5bdbbb09e1851bcb9b35b286c76753" name="a9c5bdbbb09e1851bcb9b35b286c76753"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c5bdbbb09e1851bcb9b35b286c76753">&#9670;&nbsp;</a></span>Vector() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVc_1_1Vector.html">Vector</a> </td>
          <td>(</td>
          <td class="paramtype">VectorSpecialInitializerIndexesFromZero&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct a vector with the entries initialized to 0, 1, 2, 3, 4, 5, ... </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__Utilities.html#ga2fc610927782c03b1049f2898b2e5821" title="The special object Vc::IndexesFromZero can be used to construct Vector objects initialized to values ...">Vc::IndexesFromZero</a>, <a class="el" href="classVc_1_1Vector.html#a493fd531cf26bec9f8b40740ab110eec" title="Returns a vector with the entries initialized to 0, 1, 2, 3, 4, 5, ...">IndexesFromZero()</a> </dd></dl>

</div>
</div>
<a id="a7290079f3ee28150a310a6583b4eb3bd" name="a7290079f3ee28150a310a6583b4eb3bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7290079f3ee28150a310a6583b4eb3bd">&#9670;&nbsp;</a></span>Vector() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVc_1_1Vector.html">Vector</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classVc_1_1Vector.html">Vector</a>&lt; U, <a class="el" href="classVc_1_1Vector.html#abe9aa1f35fa46be781ae9e81d374a72b">abi</a> &gt;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enable_if&lt;!Traits::is_implicit_cast_allowed&lt; U, T &gt;::value &gt;&#160;</td>
          <td class="paramname"> = <code>nullarg</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Explicit conversion (i.e. </p>
<p ><code>static_cast</code>) from the remaining Vector&lt;U, Abi&gt; types.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>A vector object to use for initialization of the new vector object. If <code>x</code> contains more entries than the new object the high components will be ignored. If <code>x</code> contains fewer entries than the new object the high components of the new object will be zero-initialized. Type conversion is done according to the standard conversion rules for the underlying fundamental arithmetic types. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7e363c9b2d525293cfb1656e1498e796" name="a7e363c9b2d525293cfb1656e1498e796"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e363c9b2d525293cfb1656e1498e796">&#9670;&nbsp;</a></span>Vector() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVc_1_1Vector.html">Vector</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classVc_1_1Vector.html#ae9cb6038cbd15cb0bdc596f5383c2b21">EntryType</a>&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Broadcast Constructor. </p>
<p >Constructs a vector with all entries of the vector filled with the given value.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>The scalar value to broadcast to all entries of the constructed vector. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a1b5d7e2e663d7997796fd9f72b8af75a" name="a1b5d7e2e663d7997796fd9f72b8af75a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b5d7e2e663d7997796fd9f72b8af75a">&#9670;&nbsp;</a></span>size()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr size_t size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of scalar components ( \(\mathcal{W}_\mathtt{T}\)) in a vector of this type. </p>
<p >The size of the vector. I.e. the number of scalar entries in the vector. Do not make any assumptions about the size of vectors. If you need vectors of <code>float</code> and <code>int</code> types use <a class="el" href="classVc_1_1Vector.html#a00b1721fbbac37b8c884b6347af3ce70" title="The type of the vector used for indexes in gather and scatter operations.">Vector::IndexType</a> or <a class="el" href="classVc_1_1SimdArray.html" title="Data-parallel arithmetic type with user-defined number of elements.">SimdArray</a>.</p>
<p >You can easily use if clauses to compare <a class="el" href="classVc_1_1Vector.html" title="The main vector class for expressing data parallelism.">Vector</a> sizes. The compiler can statically evaluate and fully optimize dead code away (very much like #ifdef, but with syntax checking).</p>
<dl class="section return"><dt>Returns</dt><dd>The number of components (i.e. \(\mathcal{W}_\mathtt{T}\)) objects of this vector type store and manipulate. </dd></dl>

<p class="definition">Definition at line <a class="el" href="common_2vector_8h_source.html#l00142">142</a> of file <a class="el" href="common_2vector_8h_source.html">vector.h</a>.</p>

</div>
</div>
<a id="aaa7aece82798960b1144c030e4c8f6cc" name="aaa7aece82798960b1144c030e4c8f6cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa7aece82798960b1144c030e4c8f6cc">&#9670;&nbsp;</a></span>Random()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classVc_1_1Vector.html">Vector</a> Random </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a vector with pseudo-random entries. </p>
<p >Currently the state of the random number generator cannot be modified and starts off with the same state. Thus you will get the same sequence of numbers for the same sequence of calls.</p>
<dl class="section return"><dt>Returns</dt><dd>a new random vector. Floating-point values will be in the 0-1 range. Integers will use the full range the integer representation allows.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function may use a very small amount of state and thus will be a weak random number generator. </dd></dl>

</div>
</div>
<a id="a804d5492c78c2e5f9ca92f1d02c78c1b" name="a804d5492c78c2e5f9ca92f1d02c78c1b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a804d5492c78c2e5f9ca92f1d02c78c1b">&#9670;&nbsp;</a></span>setZero()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void setZero </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classVc_1_1Vector.html#a87ee111bfca7f15829e802bdf47c3b0e">MaskType</a>&#160;</td>
          <td class="paramname"><em>mask</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set all entries to zero where the mask is set. </p>
<p >A 4-vector with a mask of <code>[0111]</code> therefore would set the last three entries to 0.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mask</td><td>Selects the entries to be set to zero. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a10b3726d4ad99374f9448860fa5229d5" name="a10b3726d4ad99374f9448860fa5229d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a10b3726d4ad99374f9448860fa5229d5">&#9670;&nbsp;</a></span>setZeroInverted()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void setZeroInverted </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classVc_1_1Vector.html#a87ee111bfca7f15829e802bdf47c3b0e">MaskType</a>&#160;</td>
          <td class="paramname"><em>mask</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set all entries to zero where the mask is not set. </p>
<p >A 4-vector with a mask of <code>[0111]</code> therefore would set only the first entry to 0.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mask</td><td>Selects the entries to not be set to zero. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3b97acf03cd2b4e96eeed94c6bf6a3fa" name="a3b97acf03cd2b4e96eeed94c6bf6a3fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b97acf03cd2b4e96eeed94c6bf6a3fa">&#9670;&nbsp;</a></span>setQnan()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void setQnan </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classVc_1_1Vector.html#a87ee111bfca7f15829e802bdf47c3b0e">MaskType</a>&#160;</td>
          <td class="paramname"><em>mask</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set all entries to the bit representation of a QNaN where the mask is set. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mask</td><td>Selects the entries to be set to QNaN. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad9490a1dfe9ab280829a12edea2a858b" name="ad9490a1dfe9ab280829a12edea2a858b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad9490a1dfe9ab280829a12edea2a858b">&#9670;&nbsp;</a></span>operator[]() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">reference operator[] </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This operator can be used to modify scalar entries of the vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>A value between 0 and Size. This value is not checked internally so you must make/be sure it is in range.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to the vector entry at the given <code>index</code>.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>The use of this function may result in suboptimal performance. Please check whether you can find a more vector-friendly way to do what you intended. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>the returned object models the concept of a reference and as such it can exist longer than the data it is referencing. </dd>
<dd>
to avoid lifetime issues, we strongly advice not to store any reference objects. </dd></dl>

</div>
</div>
<a id="a3b07118e73a90c0bb93dceb209d5676e" name="a3b07118e73a90c0bb93dceb209d5676e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b07118e73a90c0bb93dceb209d5676e">&#9670;&nbsp;</a></span>operator[]() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVc_1_1Vector.html#ae9cb6038cbd15cb0bdc596f5383c2b21">EntryType</a> operator[] </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This operator can be used to read scalar entries of the vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>A value between 0 and Size. This value is not checked internally so you must make/be sure it is in range.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a copy of the vector entry at the given <code>index</code>. </dd></dl>

</div>
</div>
<a id="af75e76ccff4d4fa559902291c184c6ce" name="af75e76ccff4d4fa559902291c184c6ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af75e76ccff4d4fa559902291c184c6ce">&#9670;&nbsp;</a></span>operator!()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVc_1_1Vector.html#a87ee111bfca7f15829e802bdf47c3b0e">MaskType</a> operator! </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determine where the vector is null. </p>
<dl class="section return"><dt>Returns</dt><dd>a mask which denotes the zero entries of this vector object. </dd></dl>

</div>
</div>
<a id="a1dbbf2712d48879e963184d9627515e5" name="a1dbbf2712d48879e963184d9627515e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1dbbf2712d48879e963184d9627515e5">&#9670;&nbsp;</a></span>operator~()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVc_1_1Vector.html">Vector</a> operator~ </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inverts all bits. </p>
<dl class="section return"><dt>Returns</dt><dd>a new vector which has all bits inverted. I.e. <code>v &amp; ~v == 0</code>.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This operator is only defined for integral types <code>T</code>. </dd></dl>

</div>
</div>
<a id="abd478ea3c475c6821c2eee09d3b62e7c" name="abd478ea3c475c6821c2eee09d3b62e7c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd478ea3c475c6821c2eee09d3b62e7c">&#9670;&nbsp;</a></span>operator()()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Common::WriteMaskedVector&lt; <a class="el" href="classVc_1_1Vector.html">Vector</a>, <a class="el" href="classVc_1_1Vector.html#a87ee111bfca7f15829e802bdf47c3b0e">MaskType</a> &gt; operator() </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classVc_1_1Vector.html#a87ee111bfca7f15829e802bdf47c3b0e">MaskType</a>&#160;</td>
          <td class="paramname"><em>mask</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writemask the vector before an assignment. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mask</td><td>The writemask to be used.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an object that can be used for any kind of masked assignment.</dd></dl>
<p>The returned object is only to be used for assignments and should not be assigned to a variable.</p>
<p >Examples: </p><div class="fragment"><div class="line"><a class="code hl_class" href="classVc_1_1Vector.html">float_v</a> v = <a class="code hl_function" href="classVc_1_1Vector.html#af9c6cd3201b97b6c86d64a3b25e584d7">float_v::Zero</a>();         <span class="comment">// v  = [0, 0, 0, 0]</span></div>
<div class="line"><a class="code hl_class" href="classVc_1_1Vector.html">int_v</a> v2 = <a class="code hl_function" href="classVc_1_1Vector.html#a493fd531cf26bec9f8b40740ab110eec">int_v::IndexesFromZero</a>(); <span class="comment">// v2 = [0, 1, 2, 3]</span></div>
<div class="line">v(v2 &lt; 2) = 1.f;                     <span class="comment">// v  = [1, 1, 0, 0]</span></div>
<div class="line">v(v2 &lt; 3) += 1.f;                    <span class="comment">// v  = [2, 2, 1, 0]</span></div>
<div class="line">++v2(v &lt; 1.f);                       <span class="comment">// v2 = [0, 1, 2, 4]</span></div>
<div class="ttc" id="aclassVc_1_1Vector_html_af9c6cd3201b97b6c86d64a3b25e584d7"><div class="ttname"><a href="classVc_1_1Vector.html#af9c6cd3201b97b6c86d64a3b25e584d7">Vc::Vector::Zero</a></div><div class="ttdeci">static Vector Zero()</div><div class="ttdoc">Returns a vector with the entries initialized to zero.</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="afdb6c4a5bfb9cd53ca1f4dff4757a334" name="afdb6c4a5bfb9cd53ca1f4dff4757a334"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afdb6c4a5bfb9cd53ca1f4dff4757a334">&#9670;&nbsp;</a></span>shifted()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVc_1_1Vector.html">Vector</a> shifted </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>amount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classVc_1_1Vector.html">Vector</a>&lt; T, Abi &gt;&#160;</td>
          <td class="paramname"><em>shiftIn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Shift vector entries to the left by <code>amount</code>; shifting in values from shiftIn (instead of zeros). </p>
<p >This function can be used to create vectors from unaligned memory locations.</p>
<p >Example: </p><div class="fragment"><div class="line"><a class="code hl_class" href="classVc_1_1Common_1_1Memory.html">Vc::Memory&lt;int_v, 256&gt;</a> mem;</div>
<div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; 256; ++i) { mem[i] = i + 1; }</div>
<div class="line"><a class="code hl_class" href="classVc_1_1Vector.html">int_v</a> a = mem.<a class="code hl_function" href="classVc_1_1Common_1_1MemoryBase.html#ad6add6f299f1da6d1ad84d0003c3a387">vectorAt</a>(0);</div>
<div class="line"><a class="code hl_class" href="classVc_1_1Vector.html">int_v</a> b = mem.<a class="code hl_function" href="classVc_1_1Common_1_1MemoryBase.html#ad6add6f299f1da6d1ad84d0003c3a387">vectorAt</a>(<a class="code hl_variable" href="classVc_1_1Vector.html#a879ad9933a419e4e04c8a59cc19a34fe">int_v::Size</a>);</div>
<div class="line"><a class="code hl_class" href="classVc_1_1Vector.html">int_v</a> x = a.<a class="code hl_function" href="classVc_1_1Vector.html#a5bdf5c1bbc0f77f759ca74b4ae7575b7">shifted</a>(1, b);</div>
<div class="line"><span class="comment">// now x == mem.vectorAt(1, Vc::Unaligned)</span></div>
<div class="ttc" id="aclassVc_1_1Common_1_1MemoryBase_html_ad6add6f299f1da6d1ad84d0003c3a387"><div class="ttname"><a href="classVc_1_1Common_1_1MemoryBase.html#ad6add6f299f1da6d1ad84d0003c3a387">Vc::Common::MemoryBase::vectorAt</a></div><div class="ttdeci">vector_reference&lt; Flags &gt; vectorAt(size_t i, Flags flags=Flags())</div><div class="ttdef"><b>Definition:</b> <a href="memorybase_8h_source.html#l00475">memorybase.h:475</a></div></div>
<div class="ttc" id="aclassVc_1_1Common_1_1Memory_html"><div class="ttname"><a href="classVc_1_1Common_1_1Memory.html">Vc::Common::Memory</a></div><div class="ttdoc">A helper class for fixed-size two-dimensional arrays.</div><div class="ttdef"><b>Definition:</b> <a href="memory_8h_source.html#l00067">memory.h:69</a></div></div>
<div class="ttc" id="aclassVc_1_1Vector_html_a879ad9933a419e4e04c8a59cc19a34fe"><div class="ttname"><a href="classVc_1_1Vector.html#a879ad9933a419e4e04c8a59cc19a34fe">Vc::Vector::Size</a></div><div class="ttdeci">static constexpr size_t Size</div><div class="ttdoc">Returns the number of scalar components ( ) in a vector of this type.</div><div class="ttdef"><b>Definition:</b> <a href="common_2vector_8h_source.html#l00772">vector.h:772</a></div></div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">amount</td><td>The number of entries to shift by. <code>amount</code> must be between <code>-Size</code> and <code>Size</code>, otherwise the result is undefined. </td></tr>
    <tr><td class="paramname">shiftIn</td><td>The vector of values to shift in. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A new vector with values from <code>this</code> and <code>shiftIn</code> concatenated and then shifted by <code>amount</code>. </dd></dl>

</div>
</div>
<a id="abcbb1d306f41b8b282731ae6dee0df81" name="abcbb1d306f41b8b282731ae6dee0df81"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abcbb1d306f41b8b282731ae6dee0df81">&#9670;&nbsp;</a></span>sorted()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVc_1_1Vector.html">Vector</a> sorted </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a sorted copy of the vector. </p>
<dl class="section return"><dt>Returns</dt><dd>a sorted vector. The returned values are in ascending order: <pre class="fragment">v[0] &lt;= v[1] &lt;= v[2] &lt;= v[3] ...
</pre></dd></dl>
<dl class="section note"><dt>Note</dt><dd>If the vector contains NaNs the result is undefined.</dd></dl>
<p>Example: </p><div class="fragment"><div class="line"><a class="code hl_class" href="classVc_1_1Vector.html">int_v</a> v = <a class="code hl_function" href="classVc_1_1Vector.html#aaa7aece82798960b1144c030e4c8f6cc">int_v::Random</a>();</div>
<div class="line"><a class="code hl_class" href="classVc_1_1Vector.html">int_v</a> s = v.<a class="code hl_function" href="classVc_1_1Vector.html#abcbb1d306f41b8b282731ae6dee0df81">sorted</a>();</div>
<div class="line">std::cout &lt;&lt; v &lt;&lt; <span class="charliteral">&#39;\n&#39;</span> &lt;&lt; s &lt;&lt; <span class="charliteral">&#39;\n&#39;</span>;</div>
<div class="ttc" id="aclassVc_1_1Vector_html_aaa7aece82798960b1144c030e4c8f6cc"><div class="ttname"><a href="classVc_1_1Vector.html#aaa7aece82798960b1144c030e4c8f6cc">Vc::Vector::Random</a></div><div class="ttdeci">static Vector Random()</div><div class="ttdoc">Returns a vector with pseudo-random entries.</div></div>
<div class="ttc" id="aclassVc_1_1Vector_html_abcbb1d306f41b8b282731ae6dee0df81"><div class="ttname"><a href="classVc_1_1Vector.html#abcbb1d306f41b8b282731ae6dee0df81">Vc::Vector::sorted</a></div><div class="ttdeci">Vector sorted() const</div><div class="ttdoc">Return a sorted copy of the vector.</div></div>
</div><!-- fragment --><p >With SSE the output would be:</p>
<pre class="fragment">[1513634383, -963914658, 1763536262, -1285037745]
[-1285037745, -963914658, 1513634383, 1763536262]
</pre><p >With the Scalar implementation: </p><pre class="fragment">[1513634383]
[1513634383]
</pre> 
</div>
</div>
<a id="a8ad66c6a651853ac3ad5321ceb1df81a" name="a8ad66c6a651853ac3ad5321ceb1df81a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ad66c6a651853ac3ad5321ceb1df81a">&#9670;&nbsp;</a></span>exponent()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVc_1_1Vector.html">Vector</a> exponent </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the exponents of the floating-point values in the vector. </p>
<dl class="section return"><dt>Returns</dt><dd>A new vector object of the same type containing the exponents.</dd></dl>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000022">Deprecated:</a></b></dt><dd>use <a class="el" href="group__SimdArray.html#gafd60ed43c87e39c56d77a6372446cb7c" title="Applies the std:: exponent function component-wise and concurrently.">Vc::exponent</a> instead. </dd></dl>

</div>
</div>
<a id="a00a3bc44083d6e538e07480fd62e8706" name="a00a3bc44083d6e538e07480fd62e8706"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a00a3bc44083d6e538e07480fd62e8706">&#9670;&nbsp;</a></span>isNegative()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVc_1_1Vector.html#a87ee111bfca7f15829e802bdf47c3b0e">MaskType</a> isNegative </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns whether a value is negative. </p>
<dl class="section return"><dt>Returns</dt><dd>A new mask object indicating the sign of each vector element.</dd></dl>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000023">Deprecated:</a></b></dt><dd>use <a class="el" href="group__SimdArray.html#ga742ea12afe5302a00bd002f681788b75" title="Applies the std:: isnegative function component-wise and concurrently.">Vc::isnegative</a> instead. </dd></dl>

</div>
</div>
<a id="a6c106f645d37a156a2f1d72762d8778d" name="a6c106f645d37a156a2f1d72762d8778d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c106f645d37a156a2f1d72762d8778d">&#9670;&nbsp;</a></span>staticCast()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">V2 staticCast </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Casts the current object to <code>V2</code>. </p>
<dl class="section return"><dt>Returns</dt><dd>a converted object of type <code><a class="el" href="namespaceVc.html" title="Vector Classes Namespace.">Vc</a></code>.</dd></dl>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000025">Deprecated:</a></b></dt><dd>Use <a class="el" href="namespaceVc.html#a63bfcd6356c01e01296f5db3c86bd43a" title="Casts the argument x from type From to type To.">Vc::simd_cast</a> instead. </dd></dl>

</div>
</div>
<a id="a31613f5108247dee39ac6055cc96c22f" name="a31613f5108247dee39ac6055cc96c22f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a31613f5108247dee39ac6055cc96c22f">&#9670;&nbsp;</a></span>reinterpretCast()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">V2 reinterpretCast </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>reinterpret_cast the vector components to construct a vector of type <code>V2</code>. </p>
<dl class="section return"><dt>Returns</dt><dd>An object of type <code>V2</code> with the smae bit-representation.</dd></dl>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000026">Deprecated:</a></b></dt><dd>use <a class="el" href="group__Utilities.html#ga2757700841c3cd5df46343a3cbfc10d9" title="Constructs a new Vector object of type V from the Vector x, reinterpreting the bits of x for the new ...">Vc::reinterpret_components_cast</a> instead. </dd></dl>

</div>
</div>
<a id="a258c4bdfbbce0ee25b2642fdd7ba4b92" name="a258c4bdfbbce0ee25b2642fdd7ba4b92"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a258c4bdfbbce0ee25b2642fdd7ba4b92">&#9670;&nbsp;</a></span>copySign()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVc_1_1Vector.html">Vector</a> copySign </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classVc_1_1Vector.html">Vector</a>&lt; T, Abi &gt;&#160;</td>
          <td class="paramname"><em>reference</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies the signs of the components of <code>reference</code> to the components of the current vector, returning the result. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">reference</td><td>A vector object that determines the sign of the the result. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A new vector with sign taken from <code>reference</code> and absolute value taken from the current vector object.</dd></dl>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000027">Deprecated:</a></b></dt><dd>Use <a class="el" href="group__SimdArray.html#ga62b791fecb11fa3190ebbee40ed5e4d4" title="Applies the std:: copysign function component-wise and concurrently.">Vc::copysign</a> instead. </dd></dl>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a879ad9933a419e4e04c8a59cc19a34fe" name="a879ad9933a419e4e04c8a59cc19a34fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a879ad9933a419e4e04c8a59cc19a34fe">&#9670;&nbsp;</a></span>Size</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr size_t Size = VectorTraits&lt;T, Abi&gt;<a class="el" href="classVc_1_1Vector.html#a1b5d7e2e663d7997796fd9f72b8af75a">::size</a>()</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of scalar components ( \(\mathcal{W}_\mathtt{T}\)) in a vector of this type. </p>
<p >The size of the vector. I.e. the number of scalar entries in the vector. Do not make any assumptions about the size of vectors. If you need vectors of <code>float</code> and <code>int</code> types use <a class="el" href="classVc_1_1Vector.html#a00b1721fbbac37b8c884b6347af3ce70" title="The type of the vector used for indexes in gather and scatter operations.">Vector::IndexType</a> or <a class="el" href="classVc_1_1SimdArray.html" title="Data-parallel arithmetic type with user-defined number of elements.">SimdArray</a>.</p>
<p >You can easily use if clauses to compare <a class="el" href="classVc_1_1Vector.html" title="The main vector class for expressing data parallelism.">Vector</a> sizes. The compiler can statically evaluate and fully optimize dead code away (very much like #ifdef, but with syntax checking).</p>
<dl class="section return"><dt>Returns</dt><dd>The number of components (i.e. \(\mathcal{W}_\mathtt{T}\)) objects of this vector type store and manipulate. </dd></dl>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000024">Deprecated:</a></b></dt><dd>Use <a class="el" href="classVc_1_1Vector.html#a1b5d7e2e663d7997796fd9f72b8af75a" title="Returns the number of scalar components ( ) in a vector of this type.">Vc::Vector::size</a> instead. </dd></dl>

<p class="definition">Definition at line <a class="el" href="common_2vector_8h_source.html#l00772">772</a> of file <a class="el" href="common_2vector_8h_source.html">vector.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="IO_source.html#l00117">Vc::operator&lt;&lt;()</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>/home/axel/build/Vc/src/Vc/<a class="el" href="fwddecl_8h_source.html">fwddecl.h</a></li>
<li>/home/axel/build/Vc/src/Vc/common/<a class="el" href="common_2vector_8h_source.html">vector.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespaceVc.html">Vc</a></li><li class="navelem"><a class="el" href="classVc_1_1Vector.html">Vector</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.4 </li>
  </ul>
</div>
</body>
</html>
