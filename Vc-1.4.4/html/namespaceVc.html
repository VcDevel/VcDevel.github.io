<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.4"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Vc: Vc Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
  $(document).ready(function() { init_search(); });
/* @license-end */
</script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="logo_small.png"/></td>
  <td id="projectalign">
   <div id="projectname">Vc<span id="projectnumber">&#160;1.4.4</span>
   </div>
   <div id="projectbrief">SIMD Vector Classes for C++</div>
  </td>
    <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.svg"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.4 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('namespaceVc.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle"><div class="title">Vc Namespace Reference</div></div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p ><a class="el" href="classVc_1_1Vector.html" title="The main vector class for expressing data parallelism.">Vector</a> Classes Namespace. </p>
<p >All functions and types of Vc are defined inside the Vc namespace. </p>
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structVc_1_1AlignedBase.html">AlignedBase</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper class to ensure a given alignment.  <a href="structVc_1_1AlignedBase.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVc_1_1Allocator.html">Allocator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An allocator that uses global new and supports over-aligned types, as per [C++11 20.6.9].  <a href="classVc_1_1Allocator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structVc_1_1array.html">array</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is <code>std::array</code> with additional subscript operators supporting gather and scatter operations.  <a href="structVc_1_1array.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVc_1_1CpuId.html">CpuId</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class is available for x86 / AMD64 systems to read and interpret information about the CPU's capabilities.  <a href="classVc_1_1CpuId.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structVc_1_1Exclusive.html">Exclusive</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Hint for <a class="el" href="structVc_1_1Prefetch.html">Prefetch</a> to select prefetches that mark the memory as exclusive.  <a href="structVc_1_1Exclusive.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structVc_1_1ImplementationT.html">ImplementationT</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class identifies the specific implementation Vc uses in the current translation unit in terms of a type.  <a href="structVc_1_1ImplementationT.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVc_1_1Mask.html">Mask</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The main SIMD mask class.  <a href="classVc_1_1Mask.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structVc_1_1Prefetch.html">Prefetch</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structVc_1_1Shared.html">Shared</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Hint for <a class="el" href="structVc_1_1Prefetch.html">Prefetch</a> to select prefetches that mark the memory as shared.  <a href="structVc_1_1Shared.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVc_1_1SimdArray.html">SimdArray</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Data-parallel arithmetic type with user-defined number of elements.  <a href="classVc_1_1SimdArray.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVc_1_1SimdMaskArray.html">SimdMaskArray</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Data-parallel mask type with user-defined number of boolean elements.  <a href="classVc_1_1SimdMaskArray.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVc_1_1Vector.html">Vector</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The main vector class for expressing data parallelism.  <a href="classVc_1_1Vector.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="typedef-members" name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:gaf3e14167d841b235ddddfeee061e892f"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Utilities.html#gaf3e14167d841b235ddddfeee061e892f">CurrentImplementation</a> = <a class="el" href="structVc_1_1ImplementationT.html">ImplementationT</a>&lt; &gt;</td></tr>
<tr class="memdesc:gaf3e14167d841b235ddddfeee061e892f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Identifies the Vc implementation used in the current translation unit.  <a href="group__Utilities.html#gaf3e14167d841b235ddddfeee061e892f">More...</a><br /></td></tr>
<tr class="separator:gaf3e14167d841b235ddddfeee061e892f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga83d044f9c3ad372b41050be88e9dc80a"><td class="memTemplParams" colspan="2">template&lt;typename T , typename <a class="el" href="classVc_1_1Allocator.html">Allocator</a>  = std::allocator&lt;T&gt;&gt; </td></tr>
<tr class="memitem:ga83d044f9c3ad372b41050be88e9dc80a"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Containers.html#ga83d044f9c3ad372b41050be88e9dc80a">vector</a> = Common::AdaptSubscriptOperator&lt; std::vector&lt; T, <a class="el" href="classVc_1_1Allocator.html">Allocator</a> &gt; &gt;</td></tr>
<tr class="memdesc:ga83d044f9c3ad372b41050be88e9dc80a"><td class="mdescLeft">&#160;</td><td class="mdescRight">An adapted <code>std::vector</code> container with an additional subscript operator which implements gather and scatter operations.  <a href="group__Containers.html#ga83d044f9c3ad372b41050be88e9dc80a">More...</a><br /></td></tr>
<tr class="separator:ga83d044f9c3ad372b41050be88e9dc80a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae0b1347db1c228fa9eed28bb263b7ce1"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Utilities.html#gae0b1347db1c228fa9eed28bb263b7ce1">VectorAlignedBase</a> = <a class="el" href="structVc_1_1AlignedBase.html">AlignedBase</a>&lt; Detail::max(alignof(<a class="el" href="classVc_1_1Vector.html">Vector</a>&lt; float &gt;), alignof(<a class="el" href="classVc_1_1Vector.html">Vector</a>&lt; double &gt;), alignof(<a class="el" href="classVc_1_1Vector.html">Vector</a>&lt; <a class="el" href="group__Utilities.html#ga389d2ab33cbce94847a01e0b75f29627">ullong</a> &gt;), alignof(<a class="el" href="classVc_1_1Vector.html">Vector</a>&lt; <a class="el" href="group__Utilities.html#ga48d34e0d0fc1c5727f8bd72aba96b636">llong</a> &gt;), alignof(<a class="el" href="classVc_1_1Vector.html">Vector</a>&lt; <a class="el" href="group__Utilities.html#ga441b2f7db117201ab36246e7692a5974">ulong</a> &gt;), alignof(<a class="el" href="classVc_1_1Vector.html">Vector</a>&lt; long &gt;), alignof(<a class="el" href="classVc_1_1Vector.html">Vector</a>&lt; <a class="el" href="group__Utilities.html#ga69aa29b598b851b0640aa225a9e5d61d">uint</a> &gt;), alignof(<a class="el" href="classVc_1_1Vector.html">Vector</a>&lt; int &gt;), alignof(<a class="el" href="classVc_1_1Vector.html">Vector</a>&lt; <a class="el" href="group__Utilities.html#gae666ff9c44d45e6b7b6b8ed4340dd9c0">ushort</a> &gt;), alignof(<a class="el" href="classVc_1_1Vector.html">Vector</a>&lt; short &gt;), alignof(<a class="el" href="classVc_1_1Vector.html">Vector</a>&lt; <a class="el" href="group__Utilities.html#gae48ac2456c5ad6c956fef86e7bef3a21">uchar</a> &gt;), alignof(<a class="el" href="classVc_1_1Vector.html">Vector</a>&lt; <a class="el" href="group__Utilities.html#ga84375f7ee02e11ca98cc738c420f6fcf">schar</a> &gt;))&gt;</td></tr>
<tr class="memdesc:gae0b1347db1c228fa9eed28bb263b7ce1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper type to ensure suitable alignment for any Vc::Vector&lt;T&gt; type (using the default VectorAbi).  <a href="group__Utilities.html#gae0b1347db1c228fa9eed28bb263b7ce1">More...</a><br /></td></tr>
<tr class="separator:gae0b1347db1c228fa9eed28bb263b7ce1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaf50674e74fd61521eed0b6efc9fca66"><td class="memTemplParams" colspan="2">template&lt;typename V &gt; </td></tr>
<tr class="memitem:gaaf50674e74fd61521eed0b6efc9fca66"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Utilities.html#gaaf50674e74fd61521eed0b6efc9fca66">VectorAlignedBaseT</a> = <a class="el" href="structVc_1_1AlignedBase.html">AlignedBase</a>&lt; alignof(V)&gt;</td></tr>
<tr class="memdesc:gaaf50674e74fd61521eed0b6efc9fca66"><td class="mdescLeft">&#160;</td><td class="mdescRight">Variant of the above type ensuring suitable alignment only for the specified vector type <code>V</code>.  <a href="group__Utilities.html#gaaf50674e74fd61521eed0b6efc9fca66">More...</a><br /></td></tr>
<tr class="separator:gaaf50674e74fd61521eed0b6efc9fca66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga199bb5c0b1cdad984233700da70c7f72"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Utilities.html#ga199bb5c0b1cdad984233700da70c7f72">MemoryAlignedBase</a> = <a class="el" href="structVc_1_1AlignedBase.html">AlignedBase</a>&lt; Detail::max(<a class="el" href="classVc_1_1Vector.html">Vector</a>&lt; float &gt;<a class="el" href="group__Vectors.html#gaac286912729d28478c8c9a1ac97a92ac">::MemoryAlignment</a>, <a class="el" href="classVc_1_1Vector.html">Vector</a>&lt; double &gt;<a class="el" href="group__Vectors.html#gaac286912729d28478c8c9a1ac97a92ac">::MemoryAlignment</a>, <a class="el" href="classVc_1_1Vector.html">Vector</a>&lt; <a class="el" href="group__Utilities.html#ga389d2ab33cbce94847a01e0b75f29627">ullong</a> &gt;<a class="el" href="group__Vectors.html#gaac286912729d28478c8c9a1ac97a92ac">::MemoryAlignment</a>, <a class="el" href="classVc_1_1Vector.html">Vector</a>&lt; <a class="el" href="group__Utilities.html#ga48d34e0d0fc1c5727f8bd72aba96b636">llong</a> &gt;<a class="el" href="group__Vectors.html#gaac286912729d28478c8c9a1ac97a92ac">::MemoryAlignment</a>, <a class="el" href="classVc_1_1Vector.html">Vector</a>&lt; <a class="el" href="group__Utilities.html#ga441b2f7db117201ab36246e7692a5974">ulong</a> &gt;<a class="el" href="group__Vectors.html#gaac286912729d28478c8c9a1ac97a92ac">::MemoryAlignment</a>, <a class="el" href="classVc_1_1Vector.html">Vector</a>&lt; long &gt;<a class="el" href="group__Vectors.html#gaac286912729d28478c8c9a1ac97a92ac">::MemoryAlignment</a>, <a class="el" href="classVc_1_1Vector.html">Vector</a>&lt; <a class="el" href="group__Utilities.html#ga69aa29b598b851b0640aa225a9e5d61d">uint</a> &gt;<a class="el" href="group__Vectors.html#gaac286912729d28478c8c9a1ac97a92ac">::MemoryAlignment</a>, <a class="el" href="classVc_1_1Vector.html">Vector</a>&lt; int &gt;<a class="el" href="group__Vectors.html#gaac286912729d28478c8c9a1ac97a92ac">::MemoryAlignment</a>, <a class="el" href="classVc_1_1Vector.html">Vector</a>&lt; <a class="el" href="group__Utilities.html#gae666ff9c44d45e6b7b6b8ed4340dd9c0">ushort</a> &gt;<a class="el" href="group__Vectors.html#gaac286912729d28478c8c9a1ac97a92ac">::MemoryAlignment</a>, <a class="el" href="classVc_1_1Vector.html">Vector</a>&lt; short &gt;<a class="el" href="group__Vectors.html#gaac286912729d28478c8c9a1ac97a92ac">::MemoryAlignment</a>, <a class="el" href="classVc_1_1Vector.html">Vector</a>&lt; <a class="el" href="group__Utilities.html#gae48ac2456c5ad6c956fef86e7bef3a21">uchar</a> &gt;<a class="el" href="group__Vectors.html#gaac286912729d28478c8c9a1ac97a92ac">::MemoryAlignment</a>, <a class="el" href="classVc_1_1Vector.html">Vector</a>&lt; <a class="el" href="group__Utilities.html#ga84375f7ee02e11ca98cc738c420f6fcf">schar</a> &gt;<a class="el" href="group__Vectors.html#gaac286912729d28478c8c9a1ac97a92ac">::MemoryAlignment</a>)&gt;</td></tr>
<tr class="memdesc:ga199bb5c0b1cdad984233700da70c7f72"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper class to ensure suitable alignment for arrays of scalar objects for any Vc::Vector&lt;T&gt; type (using the default VectorAbi).  <a href="group__Utilities.html#ga199bb5c0b1cdad984233700da70c7f72">More...</a><br /></td></tr>
<tr class="separator:ga199bb5c0b1cdad984233700da70c7f72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga99b565288c63cae7e848763fd59f7fe3"><td class="memTemplParams" colspan="2">template&lt;typename V &gt; </td></tr>
<tr class="memitem:ga99b565288c63cae7e848763fd59f7fe3"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Utilities.html#ga99b565288c63cae7e848763fd59f7fe3">MemoryAlignedBaseT</a> = <a class="el" href="structVc_1_1AlignedBase.html">AlignedBase</a>&lt; V::MemoryAlignment &gt;</td></tr>
<tr class="memdesc:ga99b565288c63cae7e848763fd59f7fe3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Variant of the above type ensuring suitable alignment only for the specified vector type <code>V</code>.  <a href="group__Utilities.html#ga99b565288c63cae7e848763fd59f7fe3">More...</a><br /></td></tr>
<tr class="separator:ga99b565288c63cae7e848763fd59f7fe3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16cb0f3fcfe32601de1b5da10df5d59d"><td class="memItemLeft" align="right" valign="top"><a id="a16cb0f3fcfe32601de1b5da10df5d59d" name="a16cb0f3fcfe32601de1b5da10df5d59d"></a>
typedef UnalignedTag&#160;</td><td class="memItemRight" valign="bottom"><b>DefaultLoadTag</b></td></tr>
<tr class="memdesc:a16cb0f3fcfe32601de1b5da10df5d59d"><td class="mdescLeft">&#160;</td><td class="mdescRight">The default load tag type uses unaligned (non-streaming) loads. <br /></td></tr>
<tr class="separator:a16cb0f3fcfe32601de1b5da10df5d59d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d7c710aa2754261eefbc420320aaaa3"><td class="memItemLeft" align="right" valign="top"><a id="a4d7c710aa2754261eefbc420320aaaa3" name="a4d7c710aa2754261eefbc420320aaaa3"></a>
typedef UnalignedTag&#160;</td><td class="memItemRight" valign="bottom"><b>DefaultStoreTag</b></td></tr>
<tr class="memdesc:a4d7c710aa2754261eefbc420320aaaa3"><td class="mdescLeft">&#160;</td><td class="mdescRight">The default store tag type uses unaligned (non-streaming) stores. <br /></td></tr>
<tr class="separator:a4d7c710aa2754261eefbc420320aaaa3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3ac19e54411a781274a792efe3c3e319"><td class="memTemplParams" colspan="2">template&lt;typename T , size_t N = 0, typename MT  = void&gt; </td></tr>
<tr class="memitem:ga3ac19e54411a781274a792efe3c3e319"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Simdize.html#ga3ac19e54411a781274a792efe3c3e319">simdize</a> = SimdizeDetail::simdize&lt; T, N, MT &gt;</td></tr>
<tr class="separator:ga3ac19e54411a781274a792efe3c3e319"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab3e24ff44f51a475b91bc8ceb0b69106"><td class="memTemplParams" colspan="2">template&lt;typename T , ptrdiff_t Extent = dynamic_extent&gt; </td></tr>
<tr class="memitem:gab3e24ff44f51a475b91bc8ceb0b69106"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Containers.html#gab3e24ff44f51a475b91bc8ceb0b69106">span</a> = Common::AdaptSubscriptOperator&lt; Common::span&lt; T, Extent &gt; &gt;</td></tr>
<tr class="memdesc:gab3e24ff44f51a475b91bc8ceb0b69106"><td class="mdescLeft">&#160;</td><td class="mdescRight">An adapted <code>std::span</code> with additional subscript operators supporting gather and scatter operations.  <a href="group__Containers.html#gab3e24ff44f51a475b91bc8ceb0b69106">More...</a><br /></td></tr>
<tr class="separator:gab3e24ff44f51a475b91bc8ceb0b69106"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga48d34e0d0fc1c5727f8bd72aba96b636"><td class="memItemLeft" align="right" valign="top">
using&#160;</td><td class="memItemRight" valign="bottom"><b>llong</b> = long long</td></tr>
<tr class="memdesc:ga48d34e0d0fc1c5727f8bd72aba96b636"><td class="mdescLeft">&#160;</td><td class="mdescRight">long long shorthand <br /></td></tr>
<tr class="separator:ga48d34e0d0fc1c5727f8bd72aba96b636"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga389d2ab33cbce94847a01e0b75f29627"><td class="memItemLeft" align="right" valign="top">
using&#160;</td><td class="memItemRight" valign="bottom"><b>ullong</b> = unsigned long long</td></tr>
<tr class="memdesc:ga389d2ab33cbce94847a01e0b75f29627"><td class="mdescLeft">&#160;</td><td class="mdescRight">unsigned long long shorthand <br /></td></tr>
<tr class="separator:ga389d2ab33cbce94847a01e0b75f29627"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga441b2f7db117201ab36246e7692a5974"><td class="memItemLeft" align="right" valign="top">
using&#160;</td><td class="memItemRight" valign="bottom"><b>ulong</b> = unsigned long</td></tr>
<tr class="memdesc:ga441b2f7db117201ab36246e7692a5974"><td class="mdescLeft">&#160;</td><td class="mdescRight">unsigned long shorthand <br /></td></tr>
<tr class="separator:ga441b2f7db117201ab36246e7692a5974"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga69aa29b598b851b0640aa225a9e5d61d"><td class="memItemLeft" align="right" valign="top">
using&#160;</td><td class="memItemRight" valign="bottom"><b>uint</b> = unsigned int</td></tr>
<tr class="memdesc:ga69aa29b598b851b0640aa225a9e5d61d"><td class="mdescLeft">&#160;</td><td class="mdescRight">unsigned int shorthand <br /></td></tr>
<tr class="separator:ga69aa29b598b851b0640aa225a9e5d61d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae666ff9c44d45e6b7b6b8ed4340dd9c0"><td class="memItemLeft" align="right" valign="top">
using&#160;</td><td class="memItemRight" valign="bottom"><b>ushort</b> = unsigned short</td></tr>
<tr class="memdesc:gae666ff9c44d45e6b7b6b8ed4340dd9c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">unsigned short shorthand <br /></td></tr>
<tr class="separator:gae666ff9c44d45e6b7b6b8ed4340dd9c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae48ac2456c5ad6c956fef86e7bef3a21"><td class="memItemLeft" align="right" valign="top">
using&#160;</td><td class="memItemRight" valign="bottom"><b>uchar</b> = unsigned char</td></tr>
<tr class="memdesc:gae48ac2456c5ad6c956fef86e7bef3a21"><td class="mdescLeft">&#160;</td><td class="mdescRight">unsigned char shorthand <br /></td></tr>
<tr class="separator:gae48ac2456c5ad6c956fef86e7bef3a21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga84375f7ee02e11ca98cc738c420f6fcf"><td class="memItemLeft" align="right" valign="top">
using&#160;</td><td class="memItemRight" valign="bottom"><b>schar</b> = signed char</td></tr>
<tr class="memdesc:ga84375f7ee02e11ca98cc738c420f6fcf"><td class="mdescLeft">&#160;</td><td class="mdescRight">signed char shorthand <br /></td></tr>
<tr class="separator:ga84375f7ee02e11ca98cc738c420f6fcf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Vector Type Aliases</div></td></tr>
<tr class="memitem:ga0c29c10a0054260ee326ff12938243fa"><td class="memItemLeft" align="right" valign="top">
using&#160;</td><td class="memItemRight" valign="bottom"><b>double_v</b> = <a class="el" href="classVc_1_1Vector.html">Vector</a>&lt; double &gt;</td></tr>
<tr class="memdesc:ga0c29c10a0054260ee326ff12938243fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">vector of double precision <br /></td></tr>
<tr class="separator:ga0c29c10a0054260ee326ff12938243fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5cf7c5a0dadbbbbcb9b69c5e42ee0528"><td class="memItemLeft" align="right" valign="top">
using&#160;</td><td class="memItemRight" valign="bottom"><b>float_v</b> = <a class="el" href="classVc_1_1Vector.html">Vector</a>&lt; float &gt;</td></tr>
<tr class="memdesc:ga5cf7c5a0dadbbbbcb9b69c5e42ee0528"><td class="mdescLeft">&#160;</td><td class="mdescRight">vector of single precision <br /></td></tr>
<tr class="separator:ga5cf7c5a0dadbbbbcb9b69c5e42ee0528"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaff6f527c244d2e97ae290d2325de8ec0"><td class="memItemLeft" align="right" valign="top">
using&#160;</td><td class="memItemRight" valign="bottom"><b>int_v</b> = <a class="el" href="classVc_1_1Vector.html">Vector</a>&lt; int &gt;</td></tr>
<tr class="memdesc:gaff6f527c244d2e97ae290d2325de8ec0"><td class="mdescLeft">&#160;</td><td class="mdescRight">vector of signed integers <br /></td></tr>
<tr class="separator:gaff6f527c244d2e97ae290d2325de8ec0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab04f66a2e5672fe27f27e9fbff5afcbc"><td class="memItemLeft" align="right" valign="top">
using&#160;</td><td class="memItemRight" valign="bottom"><b>uint_v</b> = <a class="el" href="classVc_1_1Vector.html">Vector</a>&lt; <a class="el" href="group__Utilities.html#ga69aa29b598b851b0640aa225a9e5d61d">uint</a> &gt;</td></tr>
<tr class="memdesc:gab04f66a2e5672fe27f27e9fbff5afcbc"><td class="mdescLeft">&#160;</td><td class="mdescRight">vector of unsigned integers <br /></td></tr>
<tr class="separator:gab04f66a2e5672fe27f27e9fbff5afcbc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga357ea2ba8644fc80c7e7cf13069e6ed0"><td class="memItemLeft" align="right" valign="top">
using&#160;</td><td class="memItemRight" valign="bottom"><b>short_v</b> = <a class="el" href="classVc_1_1Vector.html">Vector</a>&lt; short &gt;</td></tr>
<tr class="memdesc:ga357ea2ba8644fc80c7e7cf13069e6ed0"><td class="mdescLeft">&#160;</td><td class="mdescRight">vector of signed short integers <br /></td></tr>
<tr class="separator:ga357ea2ba8644fc80c7e7cf13069e6ed0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga06b026f838dc9e1a7b8d76a89a852503"><td class="memItemLeft" align="right" valign="top">
using&#160;</td><td class="memItemRight" valign="bottom"><b>ushort_v</b> = <a class="el" href="classVc_1_1Vector.html">Vector</a>&lt; <a class="el" href="group__Utilities.html#gae666ff9c44d45e6b7b6b8ed4340dd9c0">ushort</a> &gt;</td></tr>
<tr class="memdesc:ga06b026f838dc9e1a7b8d76a89a852503"><td class="mdescLeft">&#160;</td><td class="mdescRight">vector of unsigned short integers <br /></td></tr>
<tr class="separator:ga06b026f838dc9e1a7b8d76a89a852503"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga988b6bf07c1a37d66c08a08f2791383e"><td class="memItemLeft" align="right" valign="top">
using&#160;</td><td class="memItemRight" valign="bottom"><b>llong_v</b> = <a class="el" href="classVc_1_1Vector.html">Vector</a>&lt; <a class="el" href="group__Utilities.html#ga48d34e0d0fc1c5727f8bd72aba96b636">llong</a> &gt;</td></tr>
<tr class="separator:ga988b6bf07c1a37d66c08a08f2791383e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4eebcf9c640d8df5b5ac350e598807d5"><td class="memItemLeft" align="right" valign="top">
using&#160;</td><td class="memItemRight" valign="bottom"><b>ullong_v</b> = <a class="el" href="classVc_1_1Vector.html">Vector</a>&lt; <a class="el" href="group__Utilities.html#ga389d2ab33cbce94847a01e0b75f29627">ullong</a> &gt;</td></tr>
<tr class="separator:ga4eebcf9c640d8df5b5ac350e598807d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9fe5b583fdb551d1e7ee312681b1d4cb"><td class="memItemLeft" align="right" valign="top">
using&#160;</td><td class="memItemRight" valign="bottom"><b>long_v</b> = <a class="el" href="classVc_1_1Vector.html">Vector</a>&lt; long &gt;</td></tr>
<tr class="separator:ga9fe5b583fdb551d1e7ee312681b1d4cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga789d7b335336bafb79b424f6f7097906"><td class="memItemLeft" align="right" valign="top">
using&#160;</td><td class="memItemRight" valign="bottom"><b>ulong_v</b> = <a class="el" href="classVc_1_1Vector.html">Vector</a>&lt; <a class="el" href="group__Utilities.html#ga441b2f7db117201ab36246e7692a5974">ulong</a> &gt;</td></tr>
<tr class="separator:ga789d7b335336bafb79b424f6f7097906"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5b993fda6b1c06a5298ca3907661e9ac"><td class="memItemLeft" align="right" valign="top">
using&#160;</td><td class="memItemRight" valign="bottom"><b>schar_v</b> = <a class="el" href="classVc_1_1Vector.html">Vector</a>&lt; <a class="el" href="group__Utilities.html#ga84375f7ee02e11ca98cc738c420f6fcf">schar</a> &gt;</td></tr>
<tr class="separator:ga5b993fda6b1c06a5298ca3907661e9ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga663b53d11d52c5351c1629f61021dcb2"><td class="memItemLeft" align="right" valign="top">
using&#160;</td><td class="memItemRight" valign="bottom"><b>uchar_v</b> = <a class="el" href="classVc_1_1Vector.html">Vector</a>&lt; <a class="el" href="group__Utilities.html#gae48ac2456c5ad6c956fef86e7bef3a21">uchar</a> &gt;</td></tr>
<tr class="separator:ga663b53d11d52c5351c1629f61021dcb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Mask Type Aliases</div></td></tr>
<tr class="memitem:ga786edb7297a37cee281c1270d72fd15e"><td class="memItemLeft" align="right" valign="top">
using&#160;</td><td class="memItemRight" valign="bottom"><b>double_m</b> = <a class="el" href="classVc_1_1Mask.html">Mask</a>&lt; double &gt;</td></tr>
<tr class="memdesc:ga786edb7297a37cee281c1270d72fd15e"><td class="mdescLeft">&#160;</td><td class="mdescRight">mask type for double_v vectors <br /></td></tr>
<tr class="separator:ga786edb7297a37cee281c1270d72fd15e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab9a61667770e6aa34fbf79bd866c6125"><td class="memItemLeft" align="right" valign="top">
using&#160;</td><td class="memItemRight" valign="bottom"><b>float_m</b> = <a class="el" href="classVc_1_1Mask.html">Mask</a>&lt; float &gt;</td></tr>
<tr class="memdesc:gab9a61667770e6aa34fbf79bd866c6125"><td class="mdescLeft">&#160;</td><td class="mdescRight">mask type for float_v vectors <br /></td></tr>
<tr class="separator:gab9a61667770e6aa34fbf79bd866c6125"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7a166e271ba59f9387294b2f6dd40681"><td class="memItemLeft" align="right" valign="top">
using&#160;</td><td class="memItemRight" valign="bottom"><b>llong_m</b> = <a class="el" href="classVc_1_1Mask.html">Mask</a>&lt; <a class="el" href="group__Utilities.html#ga48d34e0d0fc1c5727f8bd72aba96b636">llong</a> &gt;</td></tr>
<tr class="separator:ga7a166e271ba59f9387294b2f6dd40681"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga35432a2c3f42b0bf75cae2409991565a"><td class="memItemLeft" align="right" valign="top">
using&#160;</td><td class="memItemRight" valign="bottom"><b>ullong_m</b> = <a class="el" href="classVc_1_1Mask.html">Mask</a>&lt; <a class="el" href="group__Utilities.html#ga389d2ab33cbce94847a01e0b75f29627">ullong</a> &gt;</td></tr>
<tr class="separator:ga35432a2c3f42b0bf75cae2409991565a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga64fc01bf1e441e7f1eec0996494cca18"><td class="memItemLeft" align="right" valign="top">
using&#160;</td><td class="memItemRight" valign="bottom"><b>long_m</b> = <a class="el" href="classVc_1_1Mask.html">Mask</a>&lt; long &gt;</td></tr>
<tr class="separator:ga64fc01bf1e441e7f1eec0996494cca18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad5c5e8785f96abe52252cadbdaab7fac"><td class="memItemLeft" align="right" valign="top">
using&#160;</td><td class="memItemRight" valign="bottom"><b>ulong_m</b> = <a class="el" href="classVc_1_1Mask.html">Mask</a>&lt; <a class="el" href="group__Utilities.html#ga441b2f7db117201ab36246e7692a5974">ulong</a> &gt;</td></tr>
<tr class="separator:gad5c5e8785f96abe52252cadbdaab7fac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8f64c0d135eecd3d23614a429d2fe454"><td class="memItemLeft" align="right" valign="top">
using&#160;</td><td class="memItemRight" valign="bottom"><b>int_m</b> = <a class="el" href="classVc_1_1Mask.html">Mask</a>&lt; int &gt;</td></tr>
<tr class="memdesc:ga8f64c0d135eecd3d23614a429d2fe454"><td class="mdescLeft">&#160;</td><td class="mdescRight">mask type for int_v vectors <br /></td></tr>
<tr class="separator:ga8f64c0d135eecd3d23614a429d2fe454"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga08780441d72903fe2a78c1f2fdec59e9"><td class="memItemLeft" align="right" valign="top">
using&#160;</td><td class="memItemRight" valign="bottom"><b>uint_m</b> = <a class="el" href="classVc_1_1Mask.html">Mask</a>&lt; <a class="el" href="group__Utilities.html#ga69aa29b598b851b0640aa225a9e5d61d">uint</a> &gt;</td></tr>
<tr class="memdesc:ga08780441d72903fe2a78c1f2fdec59e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">mask type for uint_v vectors <br /></td></tr>
<tr class="separator:ga08780441d72903fe2a78c1f2fdec59e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga035870cea90d9dcece5b998431579679"><td class="memItemLeft" align="right" valign="top">
using&#160;</td><td class="memItemRight" valign="bottom"><b>short_m</b> = <a class="el" href="classVc_1_1Mask.html">Mask</a>&lt; short &gt;</td></tr>
<tr class="memdesc:ga035870cea90d9dcece5b998431579679"><td class="mdescLeft">&#160;</td><td class="mdescRight">mask type for short_v vectors <br /></td></tr>
<tr class="separator:ga035870cea90d9dcece5b998431579679"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadffad75d23efd4c964bfbcf98fca09ce"><td class="memItemLeft" align="right" valign="top">
using&#160;</td><td class="memItemRight" valign="bottom"><b>ushort_m</b> = <a class="el" href="classVc_1_1Mask.html">Mask</a>&lt; <a class="el" href="group__Utilities.html#gae666ff9c44d45e6b7b6b8ed4340dd9c0">ushort</a> &gt;</td></tr>
<tr class="memdesc:gadffad75d23efd4c964bfbcf98fca09ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">mask type for ushort_v vectors <br /></td></tr>
<tr class="separator:gadffad75d23efd4c964bfbcf98fca09ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga974d7b7703595763ce7f111a4aab24a5"><td class="memItemLeft" align="right" valign="top">
using&#160;</td><td class="memItemRight" valign="bottom"><b>schar_m</b> = <a class="el" href="classVc_1_1Mask.html">Mask</a>&lt; <a class="el" href="group__Utilities.html#ga84375f7ee02e11ca98cc738c420f6fcf">schar</a> &gt;</td></tr>
<tr class="separator:ga974d7b7703595763ce7f111a4aab24a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga553ea93edea37b48dd79fc1d6ac85860"><td class="memItemLeft" align="right" valign="top">
using&#160;</td><td class="memItemRight" valign="bottom"><b>uchar_m</b> = <a class="el" href="classVc_1_1Mask.html">Mask</a>&lt; <a class="el" href="group__Utilities.html#gae48ac2456c5ad6c956fef86e7bef3a21">uchar</a> &gt;</td></tr>
<tr class="separator:ga553ea93edea37b48dd79fc1d6ac85860"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="enum-members" name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:gaebce8b3227fdcca97fba94556a1b2461"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Utilities.html#gaebce8b3227fdcca97fba94556a1b2461">MallocAlignment</a> { <a class="el" href="group__Utilities.html#ggaebce8b3227fdcca97fba94556a1b2461aea1085049aede31b7bbb8c5a06815446">AlignOnVector</a>
, <a class="el" href="group__Utilities.html#ggaebce8b3227fdcca97fba94556a1b2461ae5f918b27baba790e8931d2f1173905f">AlignOnCacheline</a>
, <a class="el" href="group__Utilities.html#ggaebce8b3227fdcca97fba94556a1b2461ae4cff9800dfef630b91432a0eda00f4b">AlignOnPage</a>
 }</td></tr>
<tr class="memdesc:gaebce8b3227fdcca97fba94556a1b2461"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enum that specifies the alignment and padding restrictions to use for memory allocation with <a class="el" href="group__Utilities.html#ga0edd4f5b27c3713aaa0f9950b60e6026" title="Allocates memory on the Heap with alignment and padding suitable for vectorized access.">Vc::malloc</a>.  <a href="group__Utilities.html#gaebce8b3227fdcca97fba94556a1b2461">More...</a><br /></td></tr>
<tr class="separator:gaebce8b3227fdcca97fba94556a1b2461"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga169eae84f24c38906074ff8edde32fd8"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Utilities.html#ga169eae84f24c38906074ff8edde32fd8">Implementation</a> : std::uint_least32_t { <br />
&#160;&#160;<a class="el" href="group__Utilities.html#gga169eae84f24c38906074ff8edde32fd8af8eadb5528c544043ceb2e0bbe1615ac">ScalarImpl</a>
, <a class="el" href="group__Utilities.html#gga169eae84f24c38906074ff8edde32fd8a96e70e00d8209faf9f4f5d45d5fb2c91">SSE2Impl</a>
, <a class="el" href="group__Utilities.html#gga169eae84f24c38906074ff8edde32fd8a7d172cb38b02af566e6e256bc3c9fc6f">SSE3Impl</a>
, <a class="el" href="group__Utilities.html#gga169eae84f24c38906074ff8edde32fd8a4f2b8ddd973d24ac7984678bf4a9bf7a">SSSE3Impl</a>
, <br />
&#160;&#160;<a class="el" href="group__Utilities.html#gga169eae84f24c38906074ff8edde32fd8a42c84ad8cf63407232d74ccef344d1b4">SSE41Impl</a>
, <a class="el" href="group__Utilities.html#gga169eae84f24c38906074ff8edde32fd8a9ebefe4bccb3fb7ae762b9513f7d1f3e">SSE42Impl</a>
, <a class="el" href="group__Utilities.html#gga169eae84f24c38906074ff8edde32fd8a43a1748f49066bcfb077da5844e5ac19">AVXImpl</a>
, <a class="el" href="group__Utilities.html#gga169eae84f24c38906074ff8edde32fd8a0ec1beefc339f966fe6bc79f29157417">AVX2Impl</a>
, <br />
&#160;&#160;<a class="el" href="group__Utilities.html#gga169eae84f24c38906074ff8edde32fd8a19fd24b45f41c9b525248c256328b67c">MICImpl</a>
, <b>ImplementationMask</b> = 0xfff
<br />
 }</td></tr>
<tr class="memdesc:ga169eae84f24c38906074ff8edde32fd8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enum to identify a certain SIMD instruction set.  <a href="group__Utilities.html#ga169eae84f24c38906074ff8edde32fd8">More...</a><br /></td></tr>
<tr class="separator:ga169eae84f24c38906074ff8edde32fd8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4922572a6b9846b8c22af338b9441229"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Utilities.html#ga4922572a6b9846b8c22af338b9441229">ExtraInstructions</a> : std::uint_least32_t { <br />
&#160;&#160;<a class="el" href="group__Utilities.html#gga4922572a6b9846b8c22af338b9441229acaab28ad7711fd8542454766cef23f2c">Float16cInstructions</a> = 0x01000
, <a class="el" href="group__Utilities.html#gga4922572a6b9846b8c22af338b9441229a785542afdf7805511a1c0d1679a9d6ea">Fma4Instructions</a> = 0x02000
, <a class="el" href="group__Utilities.html#gga4922572a6b9846b8c22af338b9441229a439e5c3106f696004e78b4f79e5918b6">XopInstructions</a> = 0x04000
, <a class="el" href="group__Utilities.html#gga4922572a6b9846b8c22af338b9441229aee6cf7ebb69a99ec4ffbdea63d0d7a76">PopcntInstructions</a> = 0x08000
, <br />
&#160;&#160;<a class="el" href="group__Utilities.html#gga4922572a6b9846b8c22af338b9441229af7a4407dc74ee8444bffedca74ca942d">Sse4aInstructions</a> = 0x10000
, <a class="el" href="group__Utilities.html#gga4922572a6b9846b8c22af338b9441229a84146480ab7df66c222fdda2f7a513da">FmaInstructions</a> = 0x20000
, <a class="el" href="group__Utilities.html#gga4922572a6b9846b8c22af338b9441229ab32e7f3ac1f6c7aac5d6d20ae435f84a">VexInstructions</a> = 0x40000
, <a class="el" href="group__Utilities.html#gga4922572a6b9846b8c22af338b9441229a28c60a6d86220ee7bbbbbecac4db015f">Bmi2Instructions</a> = 0x80000
, <br />
&#160;&#160;<b>ExtraInstructionsMask</b> = 0xfffff000u
<br />
 }</td></tr>
<tr class="memdesc:ga4922572a6b9846b8c22af338b9441229"><td class="mdescLeft">&#160;</td><td class="mdescRight">The list of available instructions is not easily described by a linear list of instruction sets.  <a href="group__Utilities.html#ga4922572a6b9846b8c22af338b9441229">More...</a><br /></td></tr>
<tr class="separator:ga4922572a6b9846b8c22af338b9441229"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gad8b1e885028993da5830464a001123d2"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Utilities.html#gad8b1e885028993da5830464a001123d2">versionString</a> ()</td></tr>
<tr class="separator:gad8b1e885028993da5830464a001123d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga10a6a21a4d2522fe9101344eca0848d9"><td class="memItemLeft" align="right" valign="top">constexpr unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Utilities.html#ga10a6a21a4d2522fe9101344eca0848d9">versionNumber</a> ()</td></tr>
<tr class="separator:ga10a6a21a4d2522fe9101344eca0848d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4f7cc29beb3735b74ef138a66a4329ac"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Abi &gt; </td></tr>
<tr class="memitem:ga4f7cc29beb3735b74ef138a66a4329ac"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Vectors.html#ga4f7cc29beb3735b74ef138a66a4329ac">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classVc_1_1Vector.html">Vc::Vector</a>&lt; T, Abi &gt; &amp;v)</td></tr>
<tr class="memdesc:ga4f7cc29beb3735b74ef138a66a4329ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints the contents of a vector into a stream object.  <a href="group__Vectors.html#ga4f7cc29beb3735b74ef138a66a4329ac">More...</a><br /></td></tr>
<tr class="separator:ga4f7cc29beb3735b74ef138a66a4329ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9f36123339ef60273ae1cf717ae0bc3e"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Abi &gt; </td></tr>
<tr class="memitem:ga9f36123339ef60273ae1cf717ae0bc3e"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Masks.html#ga9f36123339ef60273ae1cf717ae0bc3e">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classVc_1_1Mask.html">Vc::Mask</a>&lt; T, Abi &gt; &amp;m)</td></tr>
<tr class="memdesc:ga9f36123339ef60273ae1cf717ae0bc3e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints the contents of a mask into a stream object.  <a href="group__Masks.html#ga9f36123339ef60273ae1cf717ae0bc3e">More...</a><br /></td></tr>
<tr class="separator:ga9f36123339ef60273ae1cf717ae0bc3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga10c3796ebe8e9402589ebcdc3d7f291e"><td class="memTemplParams" colspan="2">template&lt;class InputIt , class UnaryFunction &gt; </td></tr>
<tr class="memitem:ga10c3796ebe8e9402589ebcdc3d7f291e"><td class="memTemplItemLeft" align="right" valign="top">UnaryFunction&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Utilities.html#ga10c3796ebe8e9402589ebcdc3d7f291e">simd_for_each</a> (InputIt first, InputIt last, UnaryFunction f)</td></tr>
<tr class="memdesc:ga10c3796ebe8e9402589ebcdc3d7f291e"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="namespaceVc.html" title="Vector Classes Namespace.">Vc</a> variant of the <code>std::for_each</code> algorithm.  <a href="group__Utilities.html#ga10c3796ebe8e9402589ebcdc3d7f291e">More...</a><br /></td></tr>
<tr class="separator:ga10c3796ebe8e9402589ebcdc3d7f291e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1ece12006bd1f9558c4e6370abe5c5f0"><td class="memTemplParams" colspan="2">template&lt;typename V , typename M , typename A &gt; </td></tr>
<tr class="memitem:ga1ece12006bd1f9558c4e6370abe5c5f0"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Vectors.html#ga1ece12006bd1f9558c4e6370abe5c5f0">deinterleave</a> (V *a, V *b, const M *memory, A align)</td></tr>
<tr class="separator:ga1ece12006bd1f9558c4e6370abe5c5f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga522eef0739b7d2ec6f15279c99be3608"><td class="memTemplParams" colspan="2">template&lt;typename <a class="el" href="classVc_1_1Mask.html">Mask</a> , typename T &gt; </td></tr>
<tr class="memitem:ga522eef0739b7d2ec6f15279c99be3608"><td class="memTemplItemLeft" align="right" valign="top">enable_if&lt; is_simd_mask&lt; <a class="el" href="classVc_1_1Mask.html">Mask</a> &gt;::value &amp;&amp;is_simd_vector&lt; T &gt;::value, T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Utilities.html#ga522eef0739b7d2ec6f15279c99be3608">iif</a> (const <a class="el" href="classVc_1_1Mask.html">Mask</a> &amp;condition, const T &amp;trueValue, const T &amp;falseValue)</td></tr>
<tr class="memdesc:ga522eef0739b7d2ec6f15279c99be3608"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to mimic the ternary operator '?:' (inline-if).  <a href="group__Utilities.html#ga522eef0739b7d2ec6f15279c99be3608">More...</a><br /></td></tr>
<tr class="separator:ga522eef0739b7d2ec6f15279c99be3608"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga522eef0739b7d2ec6f15279c99be3608"><td class="memTemplParams" colspan="2">template&lt;typename <a class="el" href="classVc_1_1Mask.html">Mask</a> , typename T &gt; </td></tr>
<tr class="memitem:ga522eef0739b7d2ec6f15279c99be3608"><td class="memTemplItemLeft" align="right" valign="top">enable_if&lt; is_simd_mask&lt; <a class="el" href="classVc_1_1Mask.html">Mask</a> &gt;::value &amp;&amp;!is_simd_vector&lt; T &gt;::value, T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Utilities.html#ga522eef0739b7d2ec6f15279c99be3608">iif</a> (const <a class="el" href="classVc_1_1Mask.html">Mask</a> &amp;, const T &amp;, const T &amp;)=delete</td></tr>
<tr class="memdesc:ga522eef0739b7d2ec6f15279c99be3608"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to mimic the ternary operator '?:' (inline-if).  <a href="group__Utilities.html#ga522eef0739b7d2ec6f15279c99be3608">More...</a><br /></td></tr>
<tr class="separator:ga522eef0739b7d2ec6f15279c99be3608"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacf6ecc8fd6b6bc8978ab3328ffdbdf62"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:gacf6ecc8fd6b6bc8978ab3328ffdbdf62"><td class="memTemplItemLeft" align="right" valign="top">constexpr T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Utilities.html#gacf6ecc8fd6b6bc8978ab3328ffdbdf62">iif</a> (bool condition, const T &amp;trueValue, const T &amp;falseValue)</td></tr>
<tr class="memdesc:gacf6ecc8fd6b6bc8978ab3328ffdbdf62"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overload of the above for boolean conditions.  <a href="group__Utilities.html#gacf6ecc8fd6b6bc8978ab3328ffdbdf62">More...</a><br /></td></tr>
<tr class="separator:gacf6ecc8fd6b6bc8978ab3328ffdbdf62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa80969d72f5a3dc0b1b20f9db9035c48"><td class="memTemplParams" colspan="2">template&lt;typename V , typename  = enable_if&lt;Traits::is_simd_vector&lt;V&gt;::value&gt;&gt; </td></tr>
<tr class="memitem:gaa80969d72f5a3dc0b1b20f9db9035c48"><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; V, V &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Utilities.html#gaa80969d72f5a3dc0b1b20f9db9035c48">interleave</a> (const V &amp;a, const V &amp;b)</td></tr>
<tr class="memdesc:gaa80969d72f5a3dc0b1b20f9db9035c48"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interleaves the entries from <code>a</code> and <code>b</code> into two vectors of the same type.  <a href="group__Utilities.html#gaa80969d72f5a3dc0b1b20f9db9035c48">More...</a><br /></td></tr>
<tr class="separator:gaa80969d72f5a3dc0b1b20f9db9035c48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad57f0f0c05f766cb58c01a6d831ebdab"><td class="memTemplParams" colspan="2">template&lt;typename V , typename S &gt; </td></tr>
<tr class="memitem:ad57f0f0c05f766cb58c01a6d831ebdab"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classVc_1_1Common_1_1InterleavedMemoryWrapper.html">Common::InterleavedMemoryWrapper</a>&lt; S, V &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceVc.html#ad57f0f0c05f766cb58c01a6d831ebdab">make_interleave_wrapper</a> (S *s)</td></tr>
<tr class="memdesc:ad57f0f0c05f766cb58c01a6d831ebdab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an adapter around a given array of structure (AoS) that enables optimized loads.  <a href="namespaceVc.html#ad57f0f0c05f766cb58c01a6d831ebdab">More...</a><br /></td></tr>
<tr class="separator:ad57f0f0c05f766cb58c01a6d831ebdab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8f111591b38ea2110c202b66abd3abd8"><td class="memTemplParams" colspan="2">template&lt;typename Container , typename T &gt; </td></tr>
<tr class="memitem:ga8f111591b38ea2110c202b66abd3abd8"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Containers.html#ga8f111591b38ea2110c202b66abd3abd8">makeContainer</a> (std::initializer_list&lt; T &gt; list) -&gt; decltype(make_container_helper&lt; Container, T &gt;::help(list))</td></tr>
<tr class="memdesc:ga8f111591b38ea2110c202b66abd3abd8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a container of <a class="el" href="namespaceVc.html" title="Vector Classes Namespace.">Vc</a> vectors from a std::initializer_list of scalar entries.  <a href="group__Containers.html#ga8f111591b38ea2110c202b66abd3abd8">More...</a><br /></td></tr>
<tr class="separator:ga8f111591b38ea2110c202b66abd3abd8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0edd4f5b27c3713aaa0f9950b60e6026"><td class="memTemplParams" colspan="2">template&lt;typename T , <a class="el" href="group__Utilities.html#gaebce8b3227fdcca97fba94556a1b2461">Vc::MallocAlignment</a> A&gt; </td></tr>
<tr class="memitem:ga0edd4f5b27c3713aaa0f9950b60e6026"><td class="memTemplItemLeft" align="right" valign="top">T *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Utilities.html#ga0edd4f5b27c3713aaa0f9950b60e6026">malloc</a> (size_t n)</td></tr>
<tr class="memdesc:ga0edd4f5b27c3713aaa0f9950b60e6026"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocates memory on the Heap with alignment and padding suitable for vectorized access.  <a href="group__Utilities.html#ga0edd4f5b27c3713aaa0f9950b60e6026">More...</a><br /></td></tr>
<tr class="separator:ga0edd4f5b27c3713aaa0f9950b60e6026"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga02df2f4144ab266d7f9e65fa3aef070b"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga02df2f4144ab266d7f9e65fa3aef070b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Utilities.html#ga02df2f4144ab266d7f9e65fa3aef070b">free</a> (T *p)</td></tr>
<tr class="memdesc:ga02df2f4144ab266d7f9e65fa3aef070b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Frees memory that was allocated with <a class="el" href="group__Utilities.html#ga0edd4f5b27c3713aaa0f9950b60e6026" title="Allocates memory on the Heap with alignment and padding suitable for vectorized access.">Vc::malloc</a>.  <a href="group__Utilities.html#ga02df2f4144ab266d7f9e65fa3aef070b">More...</a><br /></td></tr>
<tr class="separator:ga02df2f4144ab266d7f9e65fa3aef070b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63bfcd6356c01e01296f5db3c86bd43a"><td class="memTemplParams" colspan="2">template&lt;typename To , typename From &gt; </td></tr>
<tr class="memitem:a63bfcd6356c01e01296f5db3c86bd43a"><td class="memTemplItemLeft" align="right" valign="top">To&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceVc.html#a63bfcd6356c01e01296f5db3c86bd43a">simd_cast</a> (From &amp;&amp;x, enable_if&lt; std::is_same&lt; To, Traits::decay&lt; From &gt; &gt;::value &gt;=nullarg)</td></tr>
<tr class="memdesc:a63bfcd6356c01e01296f5db3c86bd43a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Casts the argument <code>x</code> from type <code>From</code> to type <code>To</code>.  <a href="namespaceVc.html#a63bfcd6356c01e01296f5db3c86bd43a">More...</a><br /></td></tr>
<tr class="separator:a63bfcd6356c01e01296f5db3c86bd43a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb4e7042030e56e39539a1433e8c03e0"><td class="memTemplParams" colspan="2">template&lt;typename To &gt; </td></tr>
<tr class="memitem:adb4e7042030e56e39539a1433e8c03e0"><td class="memTemplItemLeft" align="right" valign="top">To&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceVc.html#adb4e7042030e56e39539a1433e8c03e0">simd_cast</a> ()</td></tr>
<tr class="memdesc:adb4e7042030e56e39539a1433e8c03e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">A cast from nothing results in default-initialization of <code>To</code>.  <a href="namespaceVc.html#adb4e7042030e56e39539a1433e8c03e0">More...</a><br /></td></tr>
<tr class="separator:adb4e7042030e56e39539a1433e8c03e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2490610651e58a7734cfaef7435152d"><td class="memTemplParams" colspan="2"><a id="af2490610651e58a7734cfaef7435152d" name="af2490610651e58a7734cfaef7435152d"></a>
template&lt;typename S , typename T , size_t N&gt; </td></tr>
<tr class="memitem:af2490610651e58a7734cfaef7435152d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>assign</b> (SimdizeDetail::Adapter&lt; S, T, N &gt; &amp;a, size_t i, const S &amp;x)</td></tr>
<tr class="memdesc:af2490610651e58a7734cfaef7435152d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assigns one scalar object <code>x</code> to a SIMD slot at offset <code>i</code> in the simdized object <code>a</code>. <br /></td></tr>
<tr class="separator:af2490610651e58a7734cfaef7435152d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d06abca5f5c4923802bddfe443855fd"><td class="memTemplParams" colspan="2"><a id="a4d06abca5f5c4923802bddfe443855fd" name="a4d06abca5f5c4923802bddfe443855fd"></a>
template&lt;typename S , typename T , size_t N&gt; </td></tr>
<tr class="memitem:a4d06abca5f5c4923802bddfe443855fd"><td class="memTemplItemLeft" align="right" valign="top">S&#160;</td><td class="memTemplItemRight" valign="bottom"><b>extract</b> (const SimdizeDetail::Adapter&lt; S, T, N &gt; &amp;a, size_t i)</td></tr>
<tr class="memdesc:a4d06abca5f5c4923802bddfe443855fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts and returns one scalar object from a SIMD slot at offset <code>i</code> in the simdized object <code>a</code>. <br /></td></tr>
<tr class="separator:a4d06abca5f5c4923802bddfe443855fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0a26b8891c8c2ab217c734c1dce2590e"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Abi &gt; </td></tr>
<tr class="memitem:ga0a26b8891c8c2ab217c734c1dce2590e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classVc_1_1Vector.html">Vector</a>&lt; T, detail::not_fixed_size_abi&lt; Abi &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Math.html#ga0a26b8891c8c2ab217c734c1dce2590e">sin</a> (const <a class="el" href="classVc_1_1Vector.html">Vector</a>&lt; T, Abi &gt; &amp;x)</td></tr>
<tr class="memdesc:ga0a26b8891c8c2ab217c734c1dce2590e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the sine of all input values in <code>x</code>.  <a href="group__Math.html#ga0a26b8891c8c2ab217c734c1dce2590e">More...</a><br /></td></tr>
<tr class="separator:ga0a26b8891c8c2ab217c734c1dce2590e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0045b39ca118119c04c08decf6867728"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Abi &gt; </td></tr>
<tr class="memitem:ga0045b39ca118119c04c08decf6867728"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classVc_1_1Vector.html">Vector</a>&lt; T, detail::not_fixed_size_abi&lt; Abi &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Math.html#ga0045b39ca118119c04c08decf6867728">cos</a> (const <a class="el" href="classVc_1_1Vector.html">Vector</a>&lt; T, Abi &gt; &amp;x)</td></tr>
<tr class="memdesc:ga0045b39ca118119c04c08decf6867728"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the cosine of all input values in <code>x</code>.  <a href="group__Math.html#ga0045b39ca118119c04c08decf6867728">More...</a><br /></td></tr>
<tr class="separator:ga0045b39ca118119c04c08decf6867728"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga90b3d243df19919d9abb752fd956be5a"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Abi &gt; </td></tr>
<tr class="memitem:ga90b3d243df19919d9abb752fd956be5a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classVc_1_1Vector.html">Vector</a>&lt; T, detail::not_fixed_size_abi&lt; Abi &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Math.html#ga90b3d243df19919d9abb752fd956be5a">asin</a> (const <a class="el" href="classVc_1_1Vector.html">Vector</a>&lt; T, Abi &gt; &amp;x)</td></tr>
<tr class="memdesc:ga90b3d243df19919d9abb752fd956be5a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the arcsine of all input values in <code>x</code>.  <a href="group__Math.html#ga90b3d243df19919d9abb752fd956be5a">More...</a><br /></td></tr>
<tr class="separator:ga90b3d243df19919d9abb752fd956be5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga991ff9c7d88834e55576b171bb63cbc0"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Abi &gt; </td></tr>
<tr class="memitem:ga991ff9c7d88834e55576b171bb63cbc0"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classVc_1_1Vector.html">Vector</a>&lt; T, detail::not_fixed_size_abi&lt; Abi &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Math.html#ga991ff9c7d88834e55576b171bb63cbc0">atan</a> (const <a class="el" href="classVc_1_1Vector.html">Vector</a>&lt; T, Abi &gt; &amp;x)</td></tr>
<tr class="memdesc:ga991ff9c7d88834e55576b171bb63cbc0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the arctangent of all input values in <code>x</code>.  <a href="group__Math.html#ga991ff9c7d88834e55576b171bb63cbc0">More...</a><br /></td></tr>
<tr class="separator:ga991ff9c7d88834e55576b171bb63cbc0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad3ad5fd6cfc833464d4957dd2a39424a"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Abi &gt; </td></tr>
<tr class="memitem:gad3ad5fd6cfc833464d4957dd2a39424a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classVc_1_1Vector.html">Vector</a>&lt; T, detail::not_fixed_size_abi&lt; Abi &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Math.html#gad3ad5fd6cfc833464d4957dd2a39424a">atan2</a> (const <a class="el" href="classVc_1_1Vector.html">Vector</a>&lt; T, Abi &gt; &amp;y, const <a class="el" href="classVc_1_1Vector.html">Vector</a>&lt; T, Abi &gt; &amp;x)</td></tr>
<tr class="memdesc:gad3ad5fd6cfc833464d4957dd2a39424a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the arctangent of all input values in <code>x</code> and <code>y</code>.  <a href="group__Math.html#gad3ad5fd6cfc833464d4957dd2a39424a">More...</a><br /></td></tr>
<tr class="separator:gad3ad5fd6cfc833464d4957dd2a39424a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacb03e010b36fb653c42fca336673cad6"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Abi &gt; </td></tr>
<tr class="memitem:gacb03e010b36fb653c42fca336673cad6"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Math.html#gacb03e010b36fb653c42fca336673cad6">sincos</a> (const <a class="el" href="classVc_1_1Vector.html">Vector</a>&lt; T, Abi &gt; &amp;x, <a class="el" href="classVc_1_1Vector.html">Vector</a>&lt; T, detail::not_fixed_size_abi&lt; Abi &gt; &gt; *<a class="el" href="group__SimdArray.html#ga47ded4a72c2f1452d789c528e7b094dc">sin</a>, <a class="el" href="classVc_1_1Vector.html">Vector</a>&lt; T, Abi &gt; *<a class="el" href="group__SimdArray.html#ga69b999a4bbde0b766930400dab181b3c">cos</a>)</td></tr>
<tr class="separator:gacb03e010b36fb653c42fca336673cad6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6347f1ac77d8f0bad0d25776196b0ea0"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Abi , typename  = enable_if&lt;std::is_floating_point&lt;T&gt;::value &amp;&amp;                               !detail::is_fixed_size_abi&lt;Abi&gt;::value&gt;&gt; </td></tr>
<tr class="memitem:ga6347f1ac77d8f0bad0d25776196b0ea0"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classVc_1_1Vector.html">Vector</a>&lt; T, Abi &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Math.html#ga6347f1ac77d8f0bad0d25776196b0ea0">copysign</a> (<a class="el" href="classVc_1_1Vector.html">Vector</a>&lt; T, Abi &gt; magnitude, <a class="el" href="classVc_1_1Vector.html">Vector</a>&lt; T, Abi &gt; sign)</td></tr>
<tr class="memdesc:ga6347f1ac77d8f0bad0d25776196b0ea0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies the sign(s) of <code>sign</code> to the value(s) in <code>magnitude</code> and returns the resulting vector.  <a href="group__Math.html#ga6347f1ac77d8f0bad0d25776196b0ea0">More...</a><br /></td></tr>
<tr class="separator:ga6347f1ac77d8f0bad0d25776196b0ea0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga271993627ffa60fd01e49b864610af12"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Abi , typename  = enable_if&lt;std::is_floating_point&lt;T&gt;::value &amp;&amp;                               !detail::is_fixed_size_abi&lt;Abi&gt;::value&gt;&gt; </td></tr>
<tr class="memitem:ga271993627ffa60fd01e49b864610af12"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classVc_1_1Vector.html">Vector</a>&lt; T, Abi &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Math.html#ga271993627ffa60fd01e49b864610af12">exponent</a> (<a class="el" href="classVc_1_1Vector.html">Vector</a>&lt; T, Abi &gt; x)</td></tr>
<tr class="memdesc:ga271993627ffa60fd01e49b864610af12"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts the exponent of each floating-point vector component.  <a href="group__Math.html#ga271993627ffa60fd01e49b864610af12">More...</a><br /></td></tr>
<tr class="separator:ga271993627ffa60fd01e49b864610af12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7a0e5039343271c87b94fd9a0651adbb"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Abi &gt; </td></tr>
<tr class="memitem:ga7a0e5039343271c87b94fd9a0651adbb"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classVc_1_1Vector.html">Vector</a>&lt; T, detail::not_fixed_size_abi&lt; Abi &gt; &gt;::MaskType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Math.html#ga7a0e5039343271c87b94fd9a0651adbb">isnegative</a> (<a class="el" href="classVc_1_1Vector.html">Vector</a>&lt; T, Abi &gt; x)</td></tr>
<tr class="memdesc:ga7a0e5039343271c87b94fd9a0651adbb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns for each vector component whether it stores a negative value.  <a href="group__Math.html#ga7a0e5039343271c87b94fd9a0651adbb">More...</a><br /></td></tr>
<tr class="separator:ga7a0e5039343271c87b94fd9a0651adbb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2757700841c3cd5df46343a3cbfc10d9"><td class="memTemplParams" colspan="2">template&lt;typename V , typename T , typename Abi &gt; </td></tr>
<tr class="memitem:ga2757700841c3cd5df46343a3cbfc10d9"><td class="memTemplItemLeft" align="right" valign="top">enable_if&lt;(V::size()==<a class="el" href="classVc_1_1Vector.html">Vector</a>&lt; T, Abi &gt;::size() &amp;&amp;sizeof(typename V::VectorEntryType)==sizeof(typename <a class="el" href="classVc_1_1Vector.html">Vector</a>&lt; T, Abi &gt;::VectorEntryType) &amp;&amp;sizeof(V)==sizeof(<a class="el" href="classVc_1_1Vector.html">Vector</a>&lt; T, Abi &gt;) &amp;&amp;alignof(V)&lt;=alignof(<a class="el" href="classVc_1_1Vector.html">Vector</a>&lt; T, Abi &gt;)), V &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Utilities.html#ga2757700841c3cd5df46343a3cbfc10d9">reinterpret_components_cast</a> (const <a class="el" href="classVc_1_1Vector.html">Vector</a>&lt; T, Abi &gt; &amp;x)</td></tr>
<tr class="memdesc:ga2757700841c3cd5df46343a3cbfc10d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a new <a class="el" href="classVc_1_1Vector.html" title="The main vector class for expressing data parallelism.">Vector</a> object of type <code>V</code> from the <a class="el" href="classVc_1_1Vector.html" title="The main vector class for expressing data parallelism.">Vector</a> <code>x</code>, reinterpreting the bits of <code>x</code> for the new type <code>V</code>.  <a href="group__Utilities.html#ga2757700841c3cd5df46343a3cbfc10d9">More...</a><br /></td></tr>
<tr class="separator:ga2757700841c3cd5df46343a3cbfc10d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga27306798525d378031e6e7933addc928"><td class="memTemplParams" colspan="2">template&lt;typename M &gt; </td></tr>
<tr class="memitem:ga27306798525d378031e6e7933addc928"><td class="memTemplItemLeft" align="right" valign="top">constexpr WhereImpl::WhereMask&lt; M &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Utilities.html#ga27306798525d378031e6e7933addc928">where</a> (const M &amp;mask)</td></tr>
<tr class="memdesc:ga27306798525d378031e6e7933addc928"><td class="mdescLeft">&#160;</td><td class="mdescRight">Conditional assignment.  <a href="group__Utilities.html#ga27306798525d378031e6e7933addc928">More...</a><br /></td></tr>
<tr class="separator:ga27306798525d378031e6e7933addc928"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Micro-Architecture Feature Tests</div></td></tr>
<tr class="memitem:ga0494be780a8f52b408e0e06195ea8c21"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Utilities.html#ga0494be780a8f52b408e0e06195ea8c21">extraInstructionsSupported</a> ()</td></tr>
<tr class="memdesc:ga0494be780a8f52b408e0e06195ea8c21"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines the extra instructions supported by the current CPU.  <a href="group__Utilities.html#ga0494be780a8f52b408e0e06195ea8c21">More...</a><br /></td></tr>
<tr class="separator:ga0494be780a8f52b408e0e06195ea8c21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab884a7bd8c51ecfbafd6dbea18bb89da"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Utilities.html#gab884a7bd8c51ecfbafd6dbea18bb89da">isImplementationSupported</a> (<a class="el" href="group__Utilities.html#ga169eae84f24c38906074ff8edde32fd8">Vc::Implementation</a> impl)</td></tr>
<tr class="memdesc:gab884a7bd8c51ecfbafd6dbea18bb89da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tests whether the given implementation is supported by the system the code is executing on.  <a href="group__Utilities.html#gab884a7bd8c51ecfbafd6dbea18bb89da">More...</a><br /></td></tr>
<tr class="separator:gab884a7bd8c51ecfbafd6dbea18bb89da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa45419820f4ea76d4de6fd9d50a99fdd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__Utilities.html#ga169eae84f24c38906074ff8edde32fd8">Vc::Implementation</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Utilities.html#gaa45419820f4ea76d4de6fd9d50a99fdd">bestImplementationSupported</a> ()</td></tr>
<tr class="memdesc:gaa45419820f4ea76d4de6fd9d50a99fdd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines the best supported implementation for the current system.  <a href="group__Utilities.html#gaa45419820f4ea76d4de6fd9d50a99fdd">More...</a><br /></td></tr>
<tr class="separator:gaa45419820f4ea76d4de6fd9d50a99fdd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga99b49ea15bcdc5244d4f1b30e596cfcf"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Utilities.html#ga99b49ea15bcdc5244d4f1b30e596cfcf">currentImplementationSupported</a> ()</td></tr>
<tr class="memdesc:ga99b49ea15bcdc5244d4f1b30e596cfcf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tests that the CPU and Operating System support the vector unit which was compiled for.  <a href="group__Utilities.html#ga99b49ea15bcdc5244d4f1b30e596cfcf">More...</a><br /></td></tr>
<tr class="separator:ga99b49ea15bcdc5244d4f1b30e596cfcf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">non-member begin &amp; end</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p >Implement the non-member begin &amp; end functions in the Vc namespace so that ADL works and <code>begin(some_vc_array)</code> always works. </p>
</div></td></tr>
<tr class="memitem:aa288fa22b1a17ae1cec0ffd0f4f35860"><td class="memTemplParams" colspan="2"><a id="aa288fa22b1a17ae1cec0ffd0f4f35860" name="aa288fa22b1a17ae1cec0ffd0f4f35860"></a>
template&lt;typename T , std::size_t N&gt; </td></tr>
<tr class="memitem:aa288fa22b1a17ae1cec0ffd0f4f35860"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>begin</b> (<a class="el" href="structVc_1_1array.html">array</a>&lt; T, N &gt; &amp;arr) -&gt; decltype(arr.begin())</td></tr>
<tr class="separator:aa288fa22b1a17ae1cec0ffd0f4f35860"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b093c5902e875ef17b4fe9e79e6a11d"><td class="memTemplParams" colspan="2"><a id="a6b093c5902e875ef17b4fe9e79e6a11d" name="a6b093c5902e875ef17b4fe9e79e6a11d"></a>
template&lt;typename T , std::size_t N&gt; </td></tr>
<tr class="memitem:a6b093c5902e875ef17b4fe9e79e6a11d"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>begin</b> (const <a class="el" href="structVc_1_1array.html">array</a>&lt; T, N &gt; &amp;arr) -&gt; decltype(arr.begin())</td></tr>
<tr class="separator:a6b093c5902e875ef17b4fe9e79e6a11d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61145e59850213da319ac08b7c3c9e5d"><td class="memTemplParams" colspan="2"><a id="a61145e59850213da319ac08b7c3c9e5d" name="a61145e59850213da319ac08b7c3c9e5d"></a>
template&lt;typename T , std::size_t N&gt; </td></tr>
<tr class="memitem:a61145e59850213da319ac08b7c3c9e5d"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>end</b> (<a class="el" href="structVc_1_1array.html">array</a>&lt; T, N &gt; &amp;arr) -&gt; decltype(arr.end())</td></tr>
<tr class="separator:a61145e59850213da319ac08b7c3c9e5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad299263439e85b1430f4395a0ab49dc3"><td class="memTemplParams" colspan="2"><a id="ad299263439e85b1430f4395a0ab49dc3" name="ad299263439e85b1430f4395a0ab49dc3"></a>
template&lt;typename T , std::size_t N&gt; </td></tr>
<tr class="memitem:ad299263439e85b1430f4395a0ab49dc3"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>end</b> (const <a class="el" href="structVc_1_1array.html">array</a>&lt; T, N &gt; &amp;arr) -&gt; decltype(arr.end())</td></tr>
<tr class="separator:ad299263439e85b1430f4395a0ab49dc3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Boolean Reductions</div></td></tr>
<tr class="memitem:gaff53f2c94209b49c88ef19d7004d1225"><td class="memTemplParams" colspan="2">
template&lt;typename <a class="el" href="classVc_1_1Mask.html">Mask</a> &gt; </td></tr>
<tr class="memitem:gaff53f2c94209b49c88ef19d7004d1225"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>all_of</b> (const <a class="el" href="classVc_1_1Mask.html">Mask</a> &amp;m)</td></tr>
<tr class="memdesc:gaff53f2c94209b49c88ef19d7004d1225"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether all entries in the mask <code>m</code> are <code>true</code>. <br /></td></tr>
<tr class="separator:gaff53f2c94209b49c88ef19d7004d1225"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5c11d2373ee63b998032086ca8eff990"><td class="memItemLeft" align="right" valign="top">
constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><b>all_of</b> (bool b)</td></tr>
<tr class="memdesc:ga5c11d2373ee63b998032086ca8eff990"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>b</code>. <br /></td></tr>
<tr class="separator:ga5c11d2373ee63b998032086ca8eff990"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6c419070cb21f3f9698041332c311dd4"><td class="memTemplParams" colspan="2">
template&lt;typename <a class="el" href="classVc_1_1Mask.html">Mask</a> &gt; </td></tr>
<tr class="memitem:ga6c419070cb21f3f9698041332c311dd4"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>any_of</b> (const <a class="el" href="classVc_1_1Mask.html">Mask</a> &amp;m)</td></tr>
<tr class="memdesc:ga6c419070cb21f3f9698041332c311dd4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether at least one entry in the mask <code>m</code> is <code>true</code>. <br /></td></tr>
<tr class="separator:ga6c419070cb21f3f9698041332c311dd4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga987ef53cca76351756ac45f24c653365"><td class="memItemLeft" align="right" valign="top">
constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><b>any_of</b> (bool b)</td></tr>
<tr class="memdesc:ga987ef53cca76351756ac45f24c653365"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>b</code>. <br /></td></tr>
<tr class="separator:ga987ef53cca76351756ac45f24c653365"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf08f66c6cce8a6745d462d7dcbe9148d"><td class="memTemplParams" colspan="2">
template&lt;typename <a class="el" href="classVc_1_1Mask.html">Mask</a> &gt; </td></tr>
<tr class="memitem:gaf08f66c6cce8a6745d462d7dcbe9148d"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>none_of</b> (const <a class="el" href="classVc_1_1Mask.html">Mask</a> &amp;m)</td></tr>
<tr class="memdesc:gaf08f66c6cce8a6745d462d7dcbe9148d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether all entries in the mask <code>m</code> are <code>false</code>. <br /></td></tr>
<tr class="separator:gaf08f66c6cce8a6745d462d7dcbe9148d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8ceb42d4e7446fe6895b875a7bf81b34"><td class="memItemLeft" align="right" valign="top">
constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><b>none_of</b> (bool b)</td></tr>
<tr class="memdesc:ga8ceb42d4e7446fe6895b875a7bf81b34"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>!b</code>. <br /></td></tr>
<tr class="separator:ga8ceb42d4e7446fe6895b875a7bf81b34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7f671db27bd9c478afe3e80b3f8111a3"><td class="memTemplParams" colspan="2">
template&lt;typename <a class="el" href="classVc_1_1Mask.html">Mask</a> &gt; </td></tr>
<tr class="memitem:ga7f671db27bd9c478afe3e80b3f8111a3"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>some_of</b> (const <a class="el" href="classVc_1_1Mask.html">Mask</a> &amp;m)</td></tr>
<tr class="memdesc:ga7f671db27bd9c478afe3e80b3f8111a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether at least one entry in <code>m</code> is <code>true</code> and at least one entry in <code>m</code> is <code>false</code>. <br /></td></tr>
<tr class="separator:ga7f671db27bd9c478afe3e80b3f8111a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf2f19c87677614a7cb67a88f74b1bced"><td class="memItemLeft" align="right" valign="top">
constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><b>some_of</b> (bool)</td></tr>
<tr class="memdesc:gaf2f19c87677614a7cb67a88f74b1bced"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>false</code>. <br /></td></tr>
<tr class="separator:gaf2f19c87677614a7cb67a88f74b1bced"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Math functions</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p >These functions evaluate the </p>
</div></td></tr>
<tr class="memitem:ga2aab75e4afa35c3331deb8639e2b0000"><td class="memTemplParams" colspan="2">
template&lt;typename T , std::size_t N, typename V , std::size_t M&gt; </td></tr>
<tr class="memitem:ga2aab75e4afa35c3331deb8639e2b0000"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classVc_1_1Vector.html">fixed_size_simd</a>&lt; T, N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>min</b> (const <a class="el" href="classVc_1_1SimdArray.html">SimdArray</a>&lt; T, N, V, M &gt; &amp;x, const <a class="el" href="classVc_1_1SimdArray.html">SimdArray</a>&lt; T, N, V, M &gt; &amp;y)</td></tr>
<tr class="memdesc:ga2aab75e4afa35c3331deb8639e2b0000"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the std:: min function component-wise and concurrently. <br /></td></tr>
<tr class="separator:ga2aab75e4afa35c3331deb8639e2b0000"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga253756bfaa995b548006eca952694c3a"><td class="memTemplParams" colspan="2">
template&lt;typename T , std::size_t N, typename V , std::size_t M&gt; </td></tr>
<tr class="memitem:ga253756bfaa995b548006eca952694c3a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classVc_1_1Vector.html">fixed_size_simd</a>&lt; T, N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>max</b> (const <a class="el" href="classVc_1_1SimdArray.html">SimdArray</a>&lt; T, N, V, M &gt; &amp;x, const <a class="el" href="classVc_1_1SimdArray.html">SimdArray</a>&lt; T, N, V, M &gt; &amp;y)</td></tr>
<tr class="memdesc:ga253756bfaa995b548006eca952694c3a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the std:: max function component-wise and concurrently. <br /></td></tr>
<tr class="separator:ga253756bfaa995b548006eca952694c3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaca60c415008bf8fa7584b96d63273bc9"><td class="memTemplParams" colspan="2">
template&lt;typename T , std::size_t N, typename V , std::size_t M&gt; </td></tr>
<tr class="memitem:gaca60c415008bf8fa7584b96d63273bc9"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classVc_1_1Vector.html">fixed_size_simd</a>&lt; T, N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>abs</b> (const <a class="el" href="classVc_1_1SimdArray.html">SimdArray</a>&lt; T, N, V, M &gt; &amp;x)</td></tr>
<tr class="memdesc:gaca60c415008bf8fa7584b96d63273bc9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the std:: abs function component-wise and concurrently. <br /></td></tr>
<tr class="separator:gaca60c415008bf8fa7584b96d63273bc9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga66eb0701d2ded4d78e6d40cdb7ce3c04"><td class="memTemplParams" colspan="2">
template&lt;class T , int N&gt; </td></tr>
<tr class="memitem:ga66eb0701d2ded4d78e6d40cdb7ce3c04"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classVc_1_1Vector.html">fixed_size_simd</a>&lt; T, N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>abs</b> (const <a class="el" href="classVc_1_1Vector.html">fixed_size_simd</a>&lt; T, N &gt; &amp;x)</td></tr>
<tr class="separator:ga66eb0701d2ded4d78e6d40cdb7ce3c04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8d20c72a003514c3dc9bb46a07b77479"><td class="memTemplParams" colspan="2">
template&lt;typename T , std::size_t N, typename V , std::size_t M&gt; </td></tr>
<tr class="memitem:ga8d20c72a003514c3dc9bb46a07b77479"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classVc_1_1Vector.html">fixed_size_simd</a>&lt; T, N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>asin</b> (const <a class="el" href="classVc_1_1SimdArray.html">SimdArray</a>&lt; T, N, V, M &gt; &amp;x)</td></tr>
<tr class="memdesc:ga8d20c72a003514c3dc9bb46a07b77479"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the std:: asin function component-wise and concurrently. <br /></td></tr>
<tr class="separator:ga8d20c72a003514c3dc9bb46a07b77479"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaace621d70ae5ddabd864d4730d415d17"><td class="memTemplParams" colspan="2">
template&lt;class T , int N&gt; </td></tr>
<tr class="memitem:gaace621d70ae5ddabd864d4730d415d17"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classVc_1_1Vector.html">fixed_size_simd</a>&lt; T, N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>asin</b> (const <a class="el" href="classVc_1_1Vector.html">fixed_size_simd</a>&lt; T, N &gt; &amp;x)</td></tr>
<tr class="separator:gaace621d70ae5ddabd864d4730d415d17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6a4d1542a5f997ce28e470f64d89783b"><td class="memTemplParams" colspan="2">
template&lt;typename T , std::size_t N, typename V , std::size_t M&gt; </td></tr>
<tr class="memitem:ga6a4d1542a5f997ce28e470f64d89783b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classVc_1_1Vector.html">fixed_size_simd</a>&lt; T, N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>atan</b> (const <a class="el" href="classVc_1_1SimdArray.html">SimdArray</a>&lt; T, N, V, M &gt; &amp;x)</td></tr>
<tr class="memdesc:ga6a4d1542a5f997ce28e470f64d89783b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the std:: atan function component-wise and concurrently. <br /></td></tr>
<tr class="separator:ga6a4d1542a5f997ce28e470f64d89783b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga27142226a69ac9c006ae1e16e39933f5"><td class="memTemplParams" colspan="2">
template&lt;class T , int N&gt; </td></tr>
<tr class="memitem:ga27142226a69ac9c006ae1e16e39933f5"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classVc_1_1Vector.html">fixed_size_simd</a>&lt; T, N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>atan</b> (const <a class="el" href="classVc_1_1Vector.html">fixed_size_simd</a>&lt; T, N &gt; &amp;x)</td></tr>
<tr class="separator:ga27142226a69ac9c006ae1e16e39933f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0ac6d145a987be25120dc4dfbd909a05"><td class="memTemplParams" colspan="2">
template&lt;typename T , std::size_t N, typename V , std::size_t M&gt; </td></tr>
<tr class="memitem:ga0ac6d145a987be25120dc4dfbd909a05"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classVc_1_1Vector.html">fixed_size_simd</a>&lt; T, N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>atan2</b> (const <a class="el" href="classVc_1_1SimdArray.html">SimdArray</a>&lt; T, N, V, M &gt; &amp;x, const <a class="el" href="classVc_1_1SimdArray.html">SimdArray</a>&lt; T, N, V, M &gt; &amp;y)</td></tr>
<tr class="memdesc:ga0ac6d145a987be25120dc4dfbd909a05"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the std:: atan2 function component-wise and concurrently. <br /></td></tr>
<tr class="separator:ga0ac6d145a987be25120dc4dfbd909a05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga232616ce5323c40c7f6edf5e3bc9a187"><td class="memTemplParams" colspan="2">
template&lt;typename T , std::size_t N, typename V , std::size_t M&gt; </td></tr>
<tr class="memitem:ga232616ce5323c40c7f6edf5e3bc9a187"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classVc_1_1Vector.html">fixed_size_simd</a>&lt; T, N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ceil</b> (const <a class="el" href="classVc_1_1SimdArray.html">SimdArray</a>&lt; T, N, V, M &gt; &amp;x)</td></tr>
<tr class="memdesc:ga232616ce5323c40c7f6edf5e3bc9a187"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the std:: ceil function component-wise and concurrently. <br /></td></tr>
<tr class="separator:ga232616ce5323c40c7f6edf5e3bc9a187"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga91bb3853022cdcc9e0851890819dd593"><td class="memTemplParams" colspan="2">
template&lt;class T , int N&gt; </td></tr>
<tr class="memitem:ga91bb3853022cdcc9e0851890819dd593"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classVc_1_1Vector.html">fixed_size_simd</a>&lt; T, N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ceil</b> (const <a class="el" href="classVc_1_1Vector.html">fixed_size_simd</a>&lt; T, N &gt; &amp;x)</td></tr>
<tr class="separator:ga91bb3853022cdcc9e0851890819dd593"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga62b791fecb11fa3190ebbee40ed5e4d4"><td class="memTemplParams" colspan="2">
template&lt;typename T , std::size_t N, typename V , std::size_t M&gt; </td></tr>
<tr class="memitem:ga62b791fecb11fa3190ebbee40ed5e4d4"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classVc_1_1Vector.html">fixed_size_simd</a>&lt; T, N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>copysign</b> (const <a class="el" href="classVc_1_1SimdArray.html">SimdArray</a>&lt; T, N, V, M &gt; &amp;x, const <a class="el" href="classVc_1_1SimdArray.html">SimdArray</a>&lt; T, N, V, M &gt; &amp;y)</td></tr>
<tr class="memdesc:ga62b791fecb11fa3190ebbee40ed5e4d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the std:: copysign function component-wise and concurrently. <br /></td></tr>
<tr class="separator:ga62b791fecb11fa3190ebbee40ed5e4d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga69b999a4bbde0b766930400dab181b3c"><td class="memTemplParams" colspan="2">
template&lt;typename T , std::size_t N, typename V , std::size_t M&gt; </td></tr>
<tr class="memitem:ga69b999a4bbde0b766930400dab181b3c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classVc_1_1Vector.html">fixed_size_simd</a>&lt; T, N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>cos</b> (const <a class="el" href="classVc_1_1SimdArray.html">SimdArray</a>&lt; T, N, V, M &gt; &amp;x)</td></tr>
<tr class="memdesc:ga69b999a4bbde0b766930400dab181b3c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the std:: cos function component-wise and concurrently. <br /></td></tr>
<tr class="separator:ga69b999a4bbde0b766930400dab181b3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaff406f8d130178c14d16a1477586c2cf"><td class="memTemplParams" colspan="2">
template&lt;class T , int N&gt; </td></tr>
<tr class="memitem:gaff406f8d130178c14d16a1477586c2cf"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classVc_1_1Vector.html">fixed_size_simd</a>&lt; T, N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>cos</b> (const <a class="el" href="classVc_1_1Vector.html">fixed_size_simd</a>&lt; T, N &gt; &amp;x)</td></tr>
<tr class="separator:gaff406f8d130178c14d16a1477586c2cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga10fdc8103aef52c55d562c3470dc9613"><td class="memTemplParams" colspan="2">
template&lt;typename T , std::size_t N, typename V , std::size_t M&gt; </td></tr>
<tr class="memitem:ga10fdc8103aef52c55d562c3470dc9613"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classVc_1_1Vector.html">fixed_size_simd</a>&lt; T, N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>exp</b> (const <a class="el" href="classVc_1_1SimdArray.html">SimdArray</a>&lt; T, N, V, M &gt; &amp;x)</td></tr>
<tr class="memdesc:ga10fdc8103aef52c55d562c3470dc9613"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the std:: exp function component-wise and concurrently. <br /></td></tr>
<tr class="separator:ga10fdc8103aef52c55d562c3470dc9613"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga16ee2690aa7f23ff2f2c650c07a2e80b"><td class="memTemplParams" colspan="2">
template&lt;class T , int N&gt; </td></tr>
<tr class="memitem:ga16ee2690aa7f23ff2f2c650c07a2e80b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classVc_1_1Vector.html">fixed_size_simd</a>&lt; T, N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>exp</b> (const <a class="el" href="classVc_1_1Vector.html">fixed_size_simd</a>&lt; T, N &gt; &amp;x)</td></tr>
<tr class="separator:ga16ee2690aa7f23ff2f2c650c07a2e80b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafd60ed43c87e39c56d77a6372446cb7c"><td class="memTemplParams" colspan="2">
template&lt;typename T , std::size_t N, typename V , std::size_t M&gt; </td></tr>
<tr class="memitem:gafd60ed43c87e39c56d77a6372446cb7c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classVc_1_1Vector.html">fixed_size_simd</a>&lt; T, N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>exponent</b> (const <a class="el" href="classVc_1_1SimdArray.html">SimdArray</a>&lt; T, N, V, M &gt; &amp;x)</td></tr>
<tr class="memdesc:gafd60ed43c87e39c56d77a6372446cb7c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the std:: exponent function component-wise and concurrently. <br /></td></tr>
<tr class="separator:gafd60ed43c87e39c56d77a6372446cb7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga51e5eb4cc8e6289d44bf4701557591f3"><td class="memTemplParams" colspan="2">
template&lt;class T , int N&gt; </td></tr>
<tr class="memitem:ga51e5eb4cc8e6289d44bf4701557591f3"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classVc_1_1Vector.html">fixed_size_simd</a>&lt; T, N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>exponent</b> (const <a class="el" href="classVc_1_1Vector.html">fixed_size_simd</a>&lt; T, N &gt; &amp;x)</td></tr>
<tr class="separator:ga51e5eb4cc8e6289d44bf4701557591f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga87d15fc96c6fe5a36df45ec7a0af46a6"><td class="memTemplParams" colspan="2">
template&lt;typename T , std::size_t N, typename V , std::size_t M&gt; </td></tr>
<tr class="memitem:ga87d15fc96c6fe5a36df45ec7a0af46a6"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classVc_1_1Vector.html">fixed_size_simd</a>&lt; T, N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>floor</b> (const <a class="el" href="classVc_1_1SimdArray.html">SimdArray</a>&lt; T, N, V, M &gt; &amp;x)</td></tr>
<tr class="memdesc:ga87d15fc96c6fe5a36df45ec7a0af46a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the std:: floor function component-wise and concurrently. <br /></td></tr>
<tr class="separator:ga87d15fc96c6fe5a36df45ec7a0af46a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7fd4bb5014a7f95ada586fabacdaa484"><td class="memTemplParams" colspan="2">
template&lt;class T , int N&gt; </td></tr>
<tr class="memitem:ga7fd4bb5014a7f95ada586fabacdaa484"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classVc_1_1Vector.html">fixed_size_simd</a>&lt; T, N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>floor</b> (const <a class="el" href="classVc_1_1Vector.html">fixed_size_simd</a>&lt; T, N &gt; &amp;x)</td></tr>
<tr class="separator:ga7fd4bb5014a7f95ada586fabacdaa484"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga55df0d76ce69e713bb167c5f33aa4ecb"><td class="memTemplParams" colspan="2">
template&lt;typename T , std::size_t N&gt; </td></tr>
<tr class="memitem:ga55df0d76ce69e713bb167c5f33aa4ecb"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classVc_1_1SimdArray.html">SimdArray</a>&lt; T, N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>fma</b> (const <a class="el" href="classVc_1_1SimdArray.html">SimdArray</a>&lt; T, N &gt; &amp;a, const <a class="el" href="classVc_1_1SimdArray.html">SimdArray</a>&lt; T, N &gt; &amp;b, const <a class="el" href="classVc_1_1SimdArray.html">SimdArray</a>&lt; T, N &gt; &amp;c)</td></tr>
<tr class="memdesc:ga55df0d76ce69e713bb167c5f33aa4ecb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the std::fma function component-wise and concurrently. <br /></td></tr>
<tr class="separator:ga55df0d76ce69e713bb167c5f33aa4ecb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadd36270b7d578c98faf6d5bb84effec5"><td class="memTemplParams" colspan="2">
template&lt;typename T , std::size_t N, typename V , std::size_t M&gt; </td></tr>
<tr class="memitem:gadd36270b7d578c98faf6d5bb84effec5"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classVc_1_1Mask.html">fixed_size_simd_mask</a>&lt; T, N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>isfinite</b> (const <a class="el" href="classVc_1_1SimdArray.html">SimdArray</a>&lt; T, N, V, M &gt; &amp;x)</td></tr>
<tr class="memdesc:gadd36270b7d578c98faf6d5bb84effec5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the std:: isfinite function component-wise and concurrently. <br /></td></tr>
<tr class="separator:gadd36270b7d578c98faf6d5bb84effec5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7a6a6322998b5c53a4e9b6430956e28c"><td class="memTemplParams" colspan="2">
template&lt;class T , int N&gt; </td></tr>
<tr class="memitem:ga7a6a6322998b5c53a4e9b6430956e28c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classVc_1_1Mask.html">fixed_size_simd_mask</a>&lt; T, N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>isfinite</b> (const <a class="el" href="classVc_1_1Vector.html">fixed_size_simd</a>&lt; T, N &gt; &amp;x)</td></tr>
<tr class="separator:ga7a6a6322998b5c53a4e9b6430956e28c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3382e6db83580758f941712598d4b0bf"><td class="memTemplParams" colspan="2">
template&lt;typename T , std::size_t N, typename V , std::size_t M&gt; </td></tr>
<tr class="memitem:ga3382e6db83580758f941712598d4b0bf"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classVc_1_1Mask.html">fixed_size_simd_mask</a>&lt; T, N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>isinf</b> (const <a class="el" href="classVc_1_1SimdArray.html">SimdArray</a>&lt; T, N, V, M &gt; &amp;x)</td></tr>
<tr class="memdesc:ga3382e6db83580758f941712598d4b0bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the std:: isinf function component-wise and concurrently. <br /></td></tr>
<tr class="separator:ga3382e6db83580758f941712598d4b0bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5ffd21d71cef507ea0bd18464850a0d1"><td class="memTemplParams" colspan="2">
template&lt;class T , int N&gt; </td></tr>
<tr class="memitem:ga5ffd21d71cef507ea0bd18464850a0d1"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classVc_1_1Mask.html">fixed_size_simd_mask</a>&lt; T, N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>isinf</b> (const <a class="el" href="classVc_1_1Vector.html">fixed_size_simd</a>&lt; T, N &gt; &amp;x)</td></tr>
<tr class="separator:ga5ffd21d71cef507ea0bd18464850a0d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaae7b193c02d5519390426f667a53f51f"><td class="memTemplParams" colspan="2">
template&lt;typename T , std::size_t N, typename V , std::size_t M&gt; </td></tr>
<tr class="memitem:gaae7b193c02d5519390426f667a53f51f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classVc_1_1Mask.html">fixed_size_simd_mask</a>&lt; T, N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>isnan</b> (const <a class="el" href="classVc_1_1SimdArray.html">SimdArray</a>&lt; T, N, V, M &gt; &amp;x)</td></tr>
<tr class="memdesc:gaae7b193c02d5519390426f667a53f51f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the std:: isnan function component-wise and concurrently. <br /></td></tr>
<tr class="separator:gaae7b193c02d5519390426f667a53f51f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae4b3e8173b8a5e6054a36ed4554422b6"><td class="memTemplParams" colspan="2">
template&lt;class T , int N&gt; </td></tr>
<tr class="memitem:gae4b3e8173b8a5e6054a36ed4554422b6"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classVc_1_1Mask.html">fixed_size_simd_mask</a>&lt; T, N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>isnan</b> (const <a class="el" href="classVc_1_1Vector.html">fixed_size_simd</a>&lt; T, N &gt; &amp;x)</td></tr>
<tr class="separator:gae4b3e8173b8a5e6054a36ed4554422b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga742ea12afe5302a00bd002f681788b75"><td class="memTemplParams" colspan="2">
template&lt;typename T , std::size_t N, typename V , std::size_t M&gt; </td></tr>
<tr class="memitem:ga742ea12afe5302a00bd002f681788b75"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classVc_1_1Mask.html">fixed_size_simd_mask</a>&lt; T, N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>isnegative</b> (const <a class="el" href="classVc_1_1SimdArray.html">SimdArray</a>&lt; T, N, V, M &gt; &amp;x)</td></tr>
<tr class="memdesc:ga742ea12afe5302a00bd002f681788b75"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the std:: isnegative function component-wise and concurrently. <br /></td></tr>
<tr class="separator:ga742ea12afe5302a00bd002f681788b75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5215147200238117bace34ffd1b23f7b"><td class="memTemplParams" colspan="2">
template&lt;class T , int N&gt; </td></tr>
<tr class="memitem:ga5215147200238117bace34ffd1b23f7b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classVc_1_1Mask.html">fixed_size_simd_mask</a>&lt; T, N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>isnegative</b> (const <a class="el" href="classVc_1_1Vector.html">fixed_size_simd</a>&lt; T, N &gt; &amp;x)</td></tr>
<tr class="separator:ga5215147200238117bace34ffd1b23f7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacf1ec0827117429126da573dc28ede39"><td class="memTemplParams" colspan="2">
template&lt;typename T , std::size_t N&gt; </td></tr>
<tr class="memitem:gacf1ec0827117429126da573dc28ede39"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classVc_1_1SimdArray.html">SimdArray</a>&lt; T, N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>frexp</b> (const <a class="el" href="classVc_1_1SimdArray.html">SimdArray</a>&lt; T, N &gt; &amp;x, <a class="el" href="classVc_1_1SimdArray.html">SimdArray</a>&lt; int, N &gt; *e)</td></tr>
<tr class="memdesc:gacf1ec0827117429126da573dc28ede39"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the std::frexp function component-wise and concurrently. <br /></td></tr>
<tr class="separator:gacf1ec0827117429126da573dc28ede39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafd5008f63774d4d2a28b60c7094b5a9f"><td class="memTemplParams" colspan="2">
template&lt;typename T , std::size_t N&gt; </td></tr>
<tr class="memitem:gafd5008f63774d4d2a28b60c7094b5a9f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classVc_1_1SimdArray.html">SimdArray</a>&lt; T, N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ldexp</b> (const <a class="el" href="classVc_1_1SimdArray.html">SimdArray</a>&lt; T, N &gt; &amp;x, const <a class="el" href="classVc_1_1SimdArray.html">SimdArray</a>&lt; int, N &gt; &amp;e)</td></tr>
<tr class="memdesc:gafd5008f63774d4d2a28b60c7094b5a9f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the std::ldexp function component-wise and concurrently. <br /></td></tr>
<tr class="separator:gafd5008f63774d4d2a28b60c7094b5a9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga50ca5d42dc4bfd9125c82d9489785fb3"><td class="memTemplParams" colspan="2">
template&lt;typename T , std::size_t N, typename V , std::size_t M&gt; </td></tr>
<tr class="memitem:ga50ca5d42dc4bfd9125c82d9489785fb3"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classVc_1_1Vector.html">fixed_size_simd</a>&lt; T, N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>log</b> (const <a class="el" href="classVc_1_1SimdArray.html">SimdArray</a>&lt; T, N, V, M &gt; &amp;x)</td></tr>
<tr class="memdesc:ga50ca5d42dc4bfd9125c82d9489785fb3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the std:: log function component-wise and concurrently. <br /></td></tr>
<tr class="separator:ga50ca5d42dc4bfd9125c82d9489785fb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga995e8c203d21f66a485a97d5d7bd1e7f"><td class="memTemplParams" colspan="2">
template&lt;class T , int N&gt; </td></tr>
<tr class="memitem:ga995e8c203d21f66a485a97d5d7bd1e7f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classVc_1_1Vector.html">fixed_size_simd</a>&lt; T, N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>log</b> (const <a class="el" href="classVc_1_1Vector.html">fixed_size_simd</a>&lt; T, N &gt; &amp;x)</td></tr>
<tr class="separator:ga995e8c203d21f66a485a97d5d7bd1e7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6a8e40c7956fd0cf5c5d5a81dc462ed6"><td class="memTemplParams" colspan="2">
template&lt;typename T , std::size_t N, typename V , std::size_t M&gt; </td></tr>
<tr class="memitem:ga6a8e40c7956fd0cf5c5d5a81dc462ed6"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classVc_1_1Vector.html">fixed_size_simd</a>&lt; T, N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>log10</b> (const <a class="el" href="classVc_1_1SimdArray.html">SimdArray</a>&lt; T, N, V, M &gt; &amp;x)</td></tr>
<tr class="memdesc:ga6a8e40c7956fd0cf5c5d5a81dc462ed6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the std:: log10 function component-wise and concurrently. <br /></td></tr>
<tr class="separator:ga6a8e40c7956fd0cf5c5d5a81dc462ed6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6298eda6e850347729704748829f94a5"><td class="memTemplParams" colspan="2">
template&lt;class T , int N&gt; </td></tr>
<tr class="memitem:ga6298eda6e850347729704748829f94a5"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classVc_1_1Vector.html">fixed_size_simd</a>&lt; T, N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>log10</b> (const <a class="el" href="classVc_1_1Vector.html">fixed_size_simd</a>&lt; T, N &gt; &amp;x)</td></tr>
<tr class="separator:ga6298eda6e850347729704748829f94a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa399f72ba9d55f3b265f87e3b5dbfccf"><td class="memTemplParams" colspan="2">
template&lt;typename T , std::size_t N, typename V , std::size_t M&gt; </td></tr>
<tr class="memitem:gaa399f72ba9d55f3b265f87e3b5dbfccf"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classVc_1_1Vector.html">fixed_size_simd</a>&lt; T, N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>log2</b> (const <a class="el" href="classVc_1_1SimdArray.html">SimdArray</a>&lt; T, N, V, M &gt; &amp;x)</td></tr>
<tr class="memdesc:gaa399f72ba9d55f3b265f87e3b5dbfccf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the std:: log2 function component-wise and concurrently. <br /></td></tr>
<tr class="separator:gaa399f72ba9d55f3b265f87e3b5dbfccf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7f50d7b0718e79bbb712d4d1c02c4e1f"><td class="memTemplParams" colspan="2">
template&lt;class T , int N&gt; </td></tr>
<tr class="memitem:ga7f50d7b0718e79bbb712d4d1c02c4e1f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classVc_1_1Vector.html">fixed_size_simd</a>&lt; T, N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>log2</b> (const <a class="el" href="classVc_1_1Vector.html">fixed_size_simd</a>&lt; T, N &gt; &amp;x)</td></tr>
<tr class="separator:ga7f50d7b0718e79bbb712d4d1c02c4e1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga36ee147be9812d939978395e96ca9653"><td class="memTemplParams" colspan="2">
template&lt;typename T , std::size_t N, typename V , std::size_t M&gt; </td></tr>
<tr class="memitem:ga36ee147be9812d939978395e96ca9653"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classVc_1_1Vector.html">fixed_size_simd</a>&lt; T, N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>reciprocal</b> (const <a class="el" href="classVc_1_1SimdArray.html">SimdArray</a>&lt; T, N, V, M &gt; &amp;x)</td></tr>
<tr class="memdesc:ga36ee147be9812d939978395e96ca9653"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the std:: reciprocal function component-wise and concurrently. <br /></td></tr>
<tr class="separator:ga36ee147be9812d939978395e96ca9653"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga684dc28708a18267c6fcddccde392234"><td class="memTemplParams" colspan="2">
template&lt;class T , int N&gt; </td></tr>
<tr class="memitem:ga684dc28708a18267c6fcddccde392234"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classVc_1_1Vector.html">fixed_size_simd</a>&lt; T, N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>reciprocal</b> (const <a class="el" href="classVc_1_1Vector.html">fixed_size_simd</a>&lt; T, N &gt; &amp;x)</td></tr>
<tr class="separator:ga684dc28708a18267c6fcddccde392234"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae2d0e4660b71feddde552a2974db3896"><td class="memTemplParams" colspan="2">
template&lt;typename T , std::size_t N, typename V , std::size_t M&gt; </td></tr>
<tr class="memitem:gae2d0e4660b71feddde552a2974db3896"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classVc_1_1Vector.html">fixed_size_simd</a>&lt; T, N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>round</b> (const <a class="el" href="classVc_1_1SimdArray.html">SimdArray</a>&lt; T, N, V, M &gt; &amp;x)</td></tr>
<tr class="memdesc:gae2d0e4660b71feddde552a2974db3896"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the std:: round function component-wise and concurrently. <br /></td></tr>
<tr class="separator:gae2d0e4660b71feddde552a2974db3896"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacb51be7258e8eee1ab778a5614c4767b"><td class="memTemplParams" colspan="2">
template&lt;class T , int N&gt; </td></tr>
<tr class="memitem:gacb51be7258e8eee1ab778a5614c4767b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classVc_1_1Vector.html">fixed_size_simd</a>&lt; T, N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>round</b> (const <a class="el" href="classVc_1_1Vector.html">fixed_size_simd</a>&lt; T, N &gt; &amp;x)</td></tr>
<tr class="separator:gacb51be7258e8eee1ab778a5614c4767b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaea57cafc480c6afed73429b1c0f7d8f9"><td class="memTemplParams" colspan="2">
template&lt;typename T , std::size_t N, typename V , std::size_t M&gt; </td></tr>
<tr class="memitem:gaea57cafc480c6afed73429b1c0f7d8f9"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classVc_1_1Vector.html">fixed_size_simd</a>&lt; T, N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>rsqrt</b> (const <a class="el" href="classVc_1_1SimdArray.html">SimdArray</a>&lt; T, N, V, M &gt; &amp;x)</td></tr>
<tr class="memdesc:gaea57cafc480c6afed73429b1c0f7d8f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the std:: rsqrt function component-wise and concurrently. <br /></td></tr>
<tr class="separator:gaea57cafc480c6afed73429b1c0f7d8f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga33eca930b570f7f1eea00a54ab3a3828"><td class="memTemplParams" colspan="2">
template&lt;class T , int N&gt; </td></tr>
<tr class="memitem:ga33eca930b570f7f1eea00a54ab3a3828"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classVc_1_1Vector.html">fixed_size_simd</a>&lt; T, N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>rsqrt</b> (const <a class="el" href="classVc_1_1Vector.html">fixed_size_simd</a>&lt; T, N &gt; &amp;x)</td></tr>
<tr class="separator:ga33eca930b570f7f1eea00a54ab3a3828"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga47ded4a72c2f1452d789c528e7b094dc"><td class="memTemplParams" colspan="2">
template&lt;typename T , std::size_t N, typename V , std::size_t M&gt; </td></tr>
<tr class="memitem:ga47ded4a72c2f1452d789c528e7b094dc"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classVc_1_1Vector.html">fixed_size_simd</a>&lt; T, N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>sin</b> (const <a class="el" href="classVc_1_1SimdArray.html">SimdArray</a>&lt; T, N, V, M &gt; &amp;x)</td></tr>
<tr class="memdesc:ga47ded4a72c2f1452d789c528e7b094dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the std:: sin function component-wise and concurrently. <br /></td></tr>
<tr class="separator:ga47ded4a72c2f1452d789c528e7b094dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga63479b858d4f7e350d134a1d8a7a4364"><td class="memTemplParams" colspan="2">
template&lt;class T , int N&gt; </td></tr>
<tr class="memitem:ga63479b858d4f7e350d134a1d8a7a4364"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classVc_1_1Vector.html">fixed_size_simd</a>&lt; T, N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>sin</b> (const <a class="el" href="classVc_1_1Vector.html">fixed_size_simd</a>&lt; T, N &gt; &amp;x)</td></tr>
<tr class="separator:ga63479b858d4f7e350d134a1d8a7a4364"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga966c8787de0b75905d6a0bcac439cd38"><td class="memTemplParams" colspan="2">
template&lt;typename T , std::size_t N&gt; </td></tr>
<tr class="memitem:ga966c8787de0b75905d6a0bcac439cd38"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>sincos</b> (const <a class="el" href="classVc_1_1SimdArray.html">SimdArray</a>&lt; T, N &gt; &amp;x, <a class="el" href="classVc_1_1SimdArray.html">SimdArray</a>&lt; T, N &gt; *<a class="el" href="group__SimdArray.html#ga47ded4a72c2f1452d789c528e7b094dc">sin</a>, <a class="el" href="classVc_1_1SimdArray.html">SimdArray</a>&lt; T, N &gt; *<a class="el" href="group__SimdArray.html#ga69b999a4bbde0b766930400dab181b3c">cos</a>)</td></tr>
<tr class="memdesc:ga966c8787de0b75905d6a0bcac439cd38"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines sine and cosine concurrently and component-wise on <code>x</code>. <br /></td></tr>
<tr class="separator:ga966c8787de0b75905d6a0bcac439cd38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7a6c5f5edc8022f95100272604ca7674"><td class="memTemplParams" colspan="2">
template&lt;typename T , std::size_t N, typename V , std::size_t M&gt; </td></tr>
<tr class="memitem:ga7a6c5f5edc8022f95100272604ca7674"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classVc_1_1Vector.html">fixed_size_simd</a>&lt; T, N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>sqrt</b> (const <a class="el" href="classVc_1_1SimdArray.html">SimdArray</a>&lt; T, N, V, M &gt; &amp;x)</td></tr>
<tr class="memdesc:ga7a6c5f5edc8022f95100272604ca7674"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the std:: sqrt function component-wise and concurrently. <br /></td></tr>
<tr class="separator:ga7a6c5f5edc8022f95100272604ca7674"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa0362cafbb351063609936bb49e64af8"><td class="memTemplParams" colspan="2">
template&lt;class T , int N&gt; </td></tr>
<tr class="memitem:gaa0362cafbb351063609936bb49e64af8"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classVc_1_1Vector.html">fixed_size_simd</a>&lt; T, N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>sqrt</b> (const <a class="el" href="classVc_1_1Vector.html">fixed_size_simd</a>&lt; T, N &gt; &amp;x)</td></tr>
<tr class="separator:gaa0362cafbb351063609936bb49e64af8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga12d14666e1baee24304e4770f0276b14"><td class="memTemplParams" colspan="2">
template&lt;typename T , std::size_t N, typename V , std::size_t M&gt; </td></tr>
<tr class="memitem:ga12d14666e1baee24304e4770f0276b14"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classVc_1_1Vector.html">fixed_size_simd</a>&lt; T, N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>trunc</b> (const <a class="el" href="classVc_1_1SimdArray.html">SimdArray</a>&lt; T, N, V, M &gt; &amp;x)</td></tr>
<tr class="memdesc:ga12d14666e1baee24304e4770f0276b14"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the std:: trunc function component-wise and concurrently. <br /></td></tr>
<tr class="separator:ga12d14666e1baee24304e4770f0276b14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga362e4b83252c29670d35f88c4068f65c"><td class="memTemplParams" colspan="2">
template&lt;class T , int N&gt; </td></tr>
<tr class="memitem:ga362e4b83252c29670d35f88c4068f65c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classVc_1_1Vector.html">fixed_size_simd</a>&lt; T, N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>trunc</b> (const <a class="el" href="classVc_1_1Vector.html">fixed_size_simd</a>&lt; T, N &gt; &amp;x)</td></tr>
<tr class="separator:ga362e4b83252c29670d35f88c4068f65c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Arithmetic and Bitwise Operators</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p >Applies the operator component-wise and concurrently on <code>lhs</code> and <code>rhs</code> and returns a new <a class="el" href="classVc_1_1SimdArray.html" title="Data-parallel arithmetic type with user-defined number of elements.">SimdArray</a> object containing the result values.</p>
<p >This operator only participates in overload resolution if: </p><ul>
<li>At least one of the template parameters <code>L</code> or <code>R</code> is a <a class="el" href="classVc_1_1SimdArray.html" title="Data-parallel arithmetic type with user-defined number of elements.">SimdArray</a> type. </li>
<li>Either <code>L</code> or <code>R</code> is a fundamental arithmetic type but not an integral type larger than <code>int</code> <br  />
 or <br  />
 <code>L</code> or <code>R</code> is a <a class="el" href="classVc_1_1Vector.html" title="The main vector class for expressing data parallelism.">Vc::Vector</a> type with equal number of elements (<a class="el" href="classVc_1_1Vector.html#a1b5d7e2e663d7997796fd9f72b8af75a" title="Returns the number of scalar components ( ) in a vector of this type.">Vector::size()</a> == <a class="el" href="classVc_1_1SimdArray.html#a5e99fb015bfbc024a4b785135b34dee7" title="Returns N, the number of scalar components in an object of this type.">SimdArray::size()</a>).</li>
</ul>
<p>The return type of the operator is a <a class="el" href="classVc_1_1SimdArray.html" title="Data-parallel arithmetic type with user-defined number of elements.">SimdArray</a> type using the more precise EntryType of <code>L</code> or <code>R</code> and the same number of elements as the <a class="el" href="classVc_1_1SimdArray.html" title="Data-parallel arithmetic type with user-defined number of elements.">SimdArray</a> argument(s). </p>
</div></td></tr>
<tr class="memitem:ga80b968160a571d3b623d975e0ae534ad"><td class="memTemplParams" colspan="2">
template&lt;typename L , typename R &gt; </td></tr>
<tr class="memitem:ga80b968160a571d3b623d975e0ae534ad"><td class="memTemplItemLeft" align="right" valign="top">result_vector_type&lt; L, R &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator+</b> (L &amp;&amp;lhs, R &amp;&amp;rhs)</td></tr>
<tr class="memdesc:ga80b968160a571d3b623d975e0ae534ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies + component-wise and concurrently. <br  />
 <br /></td></tr>
<tr class="separator:ga80b968160a571d3b623d975e0ae534ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6285d807d3c5f9de8f2c0253bdfc43b0"><td class="memTemplParams" colspan="2">
template&lt;typename L , typename R &gt; </td></tr>
<tr class="memitem:ga6285d807d3c5f9de8f2c0253bdfc43b0"><td class="memTemplItemLeft" align="right" valign="top">result_vector_type&lt; L, R &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator-</b> (L &amp;&amp;lhs, R &amp;&amp;rhs)</td></tr>
<tr class="memdesc:ga6285d807d3c5f9de8f2c0253bdfc43b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies - component-wise and concurrently. <br  />
 <br /></td></tr>
<tr class="separator:ga6285d807d3c5f9de8f2c0253bdfc43b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga77fd8e8ad57334f44ef418e47a744c5a"><td class="memTemplParams" colspan="2">
template&lt;typename L , typename R &gt; </td></tr>
<tr class="memitem:ga77fd8e8ad57334f44ef418e47a744c5a"><td class="memTemplItemLeft" align="right" valign="top">result_vector_type&lt; L, R &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator*</b> (L &amp;&amp;lhs, R &amp;&amp;rhs)</td></tr>
<tr class="memdesc:ga77fd8e8ad57334f44ef418e47a744c5a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies * component-wise and concurrently. <br  />
 <br /></td></tr>
<tr class="separator:ga77fd8e8ad57334f44ef418e47a744c5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4ed64945c6ce6249d2da3bd0167a70bf"><td class="memTemplParams" colspan="2">
template&lt;typename L , typename R &gt; </td></tr>
<tr class="memitem:ga4ed64945c6ce6249d2da3bd0167a70bf"><td class="memTemplItemLeft" align="right" valign="top">result_vector_type&lt; L, R &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator/</b> (L &amp;&amp;lhs, R &amp;&amp;rhs)</td></tr>
<tr class="memdesc:ga4ed64945c6ce6249d2da3bd0167a70bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies / component-wise and concurrently. <br  />
 <br /></td></tr>
<tr class="separator:ga4ed64945c6ce6249d2da3bd0167a70bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacc40395260df985dd651c548ecb71fce"><td class="memTemplParams" colspan="2">
template&lt;typename L , typename R &gt; </td></tr>
<tr class="memitem:gacc40395260df985dd651c548ecb71fce"><td class="memTemplItemLeft" align="right" valign="top">result_vector_type&lt; L, R &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator%</b> (L &amp;&amp;lhs, R &amp;&amp;rhs)</td></tr>
<tr class="memdesc:gacc40395260df985dd651c548ecb71fce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies % component-wise and concurrently. <br  />
 <br /></td></tr>
<tr class="separator:gacc40395260df985dd651c548ecb71fce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7573fd09a39db6c6e6a250cd5a19e590"><td class="memTemplParams" colspan="2">
template&lt;typename L , typename R &gt; </td></tr>
<tr class="memitem:ga7573fd09a39db6c6e6a250cd5a19e590"><td class="memTemplItemLeft" align="right" valign="top">result_vector_type&lt; L, R &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator|</b> (L &amp;&amp;lhs, R &amp;&amp;rhs)</td></tr>
<tr class="memdesc:ga7573fd09a39db6c6e6a250cd5a19e590"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies | component-wise and concurrently. <br  />
 <br /></td></tr>
<tr class="separator:ga7573fd09a39db6c6e6a250cd5a19e590"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadf855a2bfef6e84c14040e33ce94ea46"><td class="memTemplParams" colspan="2">
template&lt;typename L , typename R &gt; </td></tr>
<tr class="memitem:gadf855a2bfef6e84c14040e33ce94ea46"><td class="memTemplItemLeft" align="right" valign="top">result_vector_type&lt; L, R &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&amp;</b> (L &amp;&amp;lhs, R &amp;&amp;rhs)</td></tr>
<tr class="memdesc:gadf855a2bfef6e84c14040e33ce94ea46"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies &amp; component-wise and concurrently. <br  />
 <br /></td></tr>
<tr class="separator:gadf855a2bfef6e84c14040e33ce94ea46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf548f2963027b17a46bcf450b71a22c0"><td class="memTemplParams" colspan="2">
template&lt;typename L , typename R &gt; </td></tr>
<tr class="memitem:gaf548f2963027b17a46bcf450b71a22c0"><td class="memTemplItemLeft" align="right" valign="top">result_vector_type&lt; L, R &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator^</b> (L &amp;&amp;lhs, R &amp;&amp;rhs)</td></tr>
<tr class="memdesc:gaf548f2963027b17a46bcf450b71a22c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies ^ component-wise and concurrently. <br  />
 <br /></td></tr>
<tr class="separator:gaf548f2963027b17a46bcf450b71a22c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Compare Operators</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p >Applies the operator component-wise and concurrently on <code>lhs</code> and <code>rhs</code> and returns a new <a class="el" href="classVc_1_1SimdMaskArray.html" title="Data-parallel mask type with user-defined number of boolean elements.">SimdMaskArray</a> object containing the result values.</p>
<p >This operator only participates in overload resolution if (same rules as above): </p><ul>
<li>At least one of the template parameters <code>L</code> or <code>R</code> is a <a class="el" href="classVc_1_1SimdArray.html" title="Data-parallel arithmetic type with user-defined number of elements.">SimdArray</a> type. </li>
<li>Either <code>L</code> or <code>R</code> is a fundamental arithmetic type but not an integral type larger than <code>int</code> <br  />
 or <br  />
 <code>L</code> or <code>R</code> is a <a class="el" href="classVc_1_1Vector.html" title="The main vector class for expressing data parallelism.">Vc::Vector</a> type with equal number of elements (<a class="el" href="classVc_1_1Vector.html#a1b5d7e2e663d7997796fd9f72b8af75a" title="Returns the number of scalar components ( ) in a vector of this type.">Vector::size()</a> == <a class="el" href="classVc_1_1SimdArray.html#a5e99fb015bfbc024a4b785135b34dee7" title="Returns N, the number of scalar components in an object of this type.">SimdArray::size()</a>).</li>
</ul>
<p>The return type of the operator is a <a class="el" href="classVc_1_1SimdMaskArray.html" title="Data-parallel mask type with user-defined number of boolean elements.">SimdMaskArray</a> type using the more precise EntryType of <code>L</code> or <code>R</code> and the same number of elements as the <a class="el" href="classVc_1_1SimdArray.html" title="Data-parallel arithmetic type with user-defined number of elements.">SimdArray</a> argument(s). </p>
</div></td></tr>
<tr class="memitem:gafc47c0cdf2eafb9335b55353fe529854"><td class="memTemplParams" colspan="2">
template&lt;typename L , typename R &gt; </td></tr>
<tr class="memitem:gafc47c0cdf2eafb9335b55353fe529854"><td class="memTemplItemLeft" align="right" valign="top">result_vector_type&lt; L, R &gt;::mask_type&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator==</b> (L &amp;&amp;lhs, R &amp;&amp;rhs)</td></tr>
<tr class="memdesc:gafc47c0cdf2eafb9335b55353fe529854"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies == component-wise and concurrently. <br  />
 <br /></td></tr>
<tr class="separator:gafc47c0cdf2eafb9335b55353fe529854"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae682ac4f5a88d97c32e7a44e955172da"><td class="memTemplParams" colspan="2">
template&lt;typename L , typename R &gt; </td></tr>
<tr class="memitem:gae682ac4f5a88d97c32e7a44e955172da"><td class="memTemplItemLeft" align="right" valign="top">result_vector_type&lt; L, R &gt;::mask_type&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator!=</b> (L &amp;&amp;lhs, R &amp;&amp;rhs)</td></tr>
<tr class="memdesc:gae682ac4f5a88d97c32e7a44e955172da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies != component-wise and concurrently. <br  />
 <br /></td></tr>
<tr class="separator:gae682ac4f5a88d97c32e7a44e955172da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga99162763213932a50a0a4edb1003d49e"><td class="memTemplParams" colspan="2">
template&lt;typename L , typename R &gt; </td></tr>
<tr class="memitem:ga99162763213932a50a0a4edb1003d49e"><td class="memTemplItemLeft" align="right" valign="top">result_vector_type&lt; L, R &gt;::mask_type&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;=</b> (L &amp;&amp;lhs, R &amp;&amp;rhs)</td></tr>
<tr class="memdesc:ga99162763213932a50a0a4edb1003d49e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies &lt;= component-wise and concurrently. <br  />
 <br /></td></tr>
<tr class="separator:ga99162763213932a50a0a4edb1003d49e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga46470081be873074c4c58b53bfed4ce1"><td class="memTemplParams" colspan="2">
template&lt;typename L , typename R &gt; </td></tr>
<tr class="memitem:ga46470081be873074c4c58b53bfed4ce1"><td class="memTemplItemLeft" align="right" valign="top">result_vector_type&lt; L, R &gt;::mask_type&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&gt;=</b> (L &amp;&amp;lhs, R &amp;&amp;rhs)</td></tr>
<tr class="memdesc:ga46470081be873074c4c58b53bfed4ce1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies &gt;= component-wise and concurrently. <br  />
 <br /></td></tr>
<tr class="separator:ga46470081be873074c4c58b53bfed4ce1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga489fa9274b7127370c1f14740ecc420b"><td class="memTemplParams" colspan="2">
template&lt;typename L , typename R &gt; </td></tr>
<tr class="memitem:ga489fa9274b7127370c1f14740ecc420b"><td class="memTemplItemLeft" align="right" valign="top">result_vector_type&lt; L, R &gt;::mask_type&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;</b> (L &amp;&amp;lhs, R &amp;&amp;rhs)</td></tr>
<tr class="memdesc:ga489fa9274b7127370c1f14740ecc420b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies &lt; component-wise and concurrently. <br  />
 <br /></td></tr>
<tr class="separator:ga489fa9274b7127370c1f14740ecc420b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa9afb59ea3d267bbd773650016dcf1dd"><td class="memTemplParams" colspan="2">
template&lt;typename L , typename R &gt; </td></tr>
<tr class="memitem:gaa9afb59ea3d267bbd773650016dcf1dd"><td class="memTemplItemLeft" align="right" valign="top">result_vector_type&lt; L, R &gt;::mask_type&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&gt;</b> (L &amp;&amp;lhs, R &amp;&amp;rhs)</td></tr>
<tr class="memdesc:gaa9afb59ea3d267bbd773650016dcf1dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies &gt; component-wise and concurrently. <br  />
 <br /></td></tr>
<tr class="separator:gaa9afb59ea3d267bbd773650016dcf1dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="var-members" name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:gab31cdcfd0e89e57edf426bfbf3ca843b"><td class="memItemLeft" align="right" valign="top">constexpr std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#gab31cdcfd0e89e57edf426bfbf3ca843b">VectorAlignment</a> = alignof(<a class="el" href="group__Utilities.html#gae0b1347db1c228fa9eed28bb263b7ce1">VectorAlignedBase</a>)</td></tr>
<tr class="memdesc:gab31cdcfd0e89e57edf426bfbf3ca843b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specifies the most conservative memory alignment necessary for Vector&lt;T&gt; objects with default VectorAbi.  <a href="group__Vectors.html#gab31cdcfd0e89e57edf426bfbf3ca843b">More...</a><br /></td></tr>
<tr class="separator:gab31cdcfd0e89e57edf426bfbf3ca843b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaac286912729d28478c8c9a1ac97a92ac"><td class="memItemLeft" align="right" valign="top">constexpr std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#gaac286912729d28478c8c9a1ac97a92ac">MemoryAlignment</a> = alignof(<a class="el" href="group__Utilities.html#ga199bb5c0b1cdad984233700da70c7f72">MemoryAlignedBase</a>)</td></tr>
<tr class="memdesc:gaac286912729d28478c8c9a1ac97a92ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specifies the most conservative memory alignment necessary for aligned loads and stores of <a class="el" href="classVc_1_1Vector.html" title="The main vector class for expressing data parallelism.">Vector</a> types.  <a href="group__Vectors.html#gaac286912729d28478c8c9a1ac97a92ac">More...</a><br /></td></tr>
<tr class="separator:gaac286912729d28478c8c9a1ac97a92ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9e53bd74b9a47cb8f16bf12018c3670e"><td class="memItemLeft" align="right" valign="top">constexpr AlignedTag&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Utilities.html#ga9e53bd74b9a47cb8f16bf12018c3670e">Aligned</a></td></tr>
<tr class="memdesc:ga9e53bd74b9a47cb8f16bf12018c3670e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Use this object for a <code>flags</code> parameter to request aligned loads and stores.  <a href="group__Utilities.html#ga9e53bd74b9a47cb8f16bf12018c3670e">More...</a><br /></td></tr>
<tr class="separator:ga9e53bd74b9a47cb8f16bf12018c3670e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga91774bc3f3fc00d22deff300919d811c"><td class="memItemLeft" align="right" valign="top">constexpr UnalignedTag&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Utilities.html#ga91774bc3f3fc00d22deff300919d811c">Unaligned</a></td></tr>
<tr class="memdesc:ga91774bc3f3fc00d22deff300919d811c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Use this object for a <code>flags</code> parameter to request unaligned loads and stores.  <a href="group__Utilities.html#ga91774bc3f3fc00d22deff300919d811c">More...</a><br /></td></tr>
<tr class="separator:ga91774bc3f3fc00d22deff300919d811c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadc83bcfec8f15d1d02fb53baa3f38185"><td class="memItemLeft" align="right" valign="top">constexpr StreamingTag&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Utilities.html#gadc83bcfec8f15d1d02fb53baa3f38185">Streaming</a></td></tr>
<tr class="memdesc:gadc83bcfec8f15d1d02fb53baa3f38185"><td class="mdescLeft">&#160;</td><td class="mdescRight">Use this object for a <code>flags</code> parameter to request streaming loads and stores.  <a href="group__Utilities.html#gadc83bcfec8f15d1d02fb53baa3f38185">More...</a><br /></td></tr>
<tr class="separator:gadc83bcfec8f15d1d02fb53baa3f38185"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3bed7ba639e9ef78c79421c801b43e59"><td class="memItemLeft" align="right" valign="top">
constexpr LoadStoreFlags::LoadStoreFlags&lt; PrefetchFlag&lt;&gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>PrefetchDefault</b></td></tr>
<tr class="memdesc:ga3bed7ba639e9ef78c79421c801b43e59"><td class="mdescLeft">&#160;</td><td class="mdescRight">Use this object for a <code>flags</code> parameter to request default software prefetches to be emitted. <br /></td></tr>
<tr class="separator:ga3bed7ba639e9ef78c79421c801b43e59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad24df8f04b4b68f7e992aeb8b449cdf2"><td class="memItemLeft" align="right" valign="top">
constexpr VectorSpecialInitializerZero&#160;</td><td class="memItemRight" valign="bottom"><b>Zero</b> = {}</td></tr>
<tr class="memdesc:gad24df8f04b4b68f7e992aeb8b449cdf2"><td class="mdescLeft">&#160;</td><td class="mdescRight">The special object <code><a class="el" href="group__Utilities.html#gad24df8f04b4b68f7e992aeb8b449cdf2" title="The special object Vc::Zero can be used to construct Vector and Mask objects initialized to zero/fals...">Vc::Zero</a></code> can be used to construct <a class="el" href="classVc_1_1Vector.html" title="The main vector class for expressing data parallelism.">Vector</a> and <a class="el" href="classVc_1_1Mask.html" title="The main SIMD mask class.">Mask</a> objects initialized to zero/<code>false</code>. <br /></td></tr>
<tr class="separator:gad24df8f04b4b68f7e992aeb8b449cdf2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7dc0e380f66c4c791b7bf95df154b3c6"><td class="memItemLeft" align="right" valign="top">
constexpr VectorSpecialInitializerOne&#160;</td><td class="memItemRight" valign="bottom"><b>One</b> = {}</td></tr>
<tr class="memdesc:ga7dc0e380f66c4c791b7bf95df154b3c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">The special object <code><a class="el" href="group__Utilities.html#ga7dc0e380f66c4c791b7bf95df154b3c6" title="The special object Vc::One can be used to construct Vector and Mask objects initialized to one/true.">Vc::One</a></code> can be used to construct <a class="el" href="classVc_1_1Vector.html" title="The main vector class for expressing data parallelism.">Vector</a> and <a class="el" href="classVc_1_1Mask.html" title="The main SIMD mask class.">Mask</a> objects initialized to one/<code>true</code>. <br /></td></tr>
<tr class="separator:ga7dc0e380f66c4c791b7bf95df154b3c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2fc610927782c03b1049f2898b2e5821"><td class="memItemLeft" align="right" valign="top">
constexpr VectorSpecialInitializerIndexesFromZero&#160;</td><td class="memItemRight" valign="bottom"><b>IndexesFromZero</b> = {}</td></tr>
<tr class="memdesc:ga2fc610927782c03b1049f2898b2e5821"><td class="mdescLeft">&#160;</td><td class="mdescRight">The special object <code><a class="el" href="group__Utilities.html#ga2fc610927782c03b1049f2898b2e5821" title="The special object Vc::IndexesFromZero can be used to construct Vector objects initialized to values ...">Vc::IndexesFromZero</a></code> can be used to construct <a class="el" href="classVc_1_1Vector.html" title="The main vector class for expressing data parallelism.">Vector</a> objects initialized to values 0, 1, 2, 3, 4, ... <br /></td></tr>
<tr class="separator:ga2fc610927782c03b1049f2898b2e5821"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Function Documentation</h2>
<a id="ad57f0f0c05f766cb58c01a6d831ebdab" name="ad57f0f0c05f766cb58c01a6d831ebdab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad57f0f0c05f766cb58c01a6d831ebdab">&#9670;&nbsp;</a></span>make_interleave_wrapper()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVc_1_1Common_1_1InterleavedMemoryWrapper.html">Common::InterleavedMemoryWrapper</a>&lt; S, V &gt; make_interleave_wrapper </td>
          <td>(</td>
          <td class="paramtype">S *&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates an adapter around a given array of structure (AoS) that enables optimized loads. </p>
<ul>
<li>deinterleaving operations / interleaving operations + stores for vector access (using <code>V</code>).</li>
</ul>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">V</td><td>The <code><a class="el" href="classVc_1_1Vector.html" title="The main vector class for expressing data parallelism.">Vc::Vector</a>&lt;T&gt;</code> type to use per element of the structure. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>A pointer to an array of structures containing data members of type <code>T</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classVc_1_1Common_1_1InterleavedMemoryWrapper.html" title="Wraps a pointer to memory with convenience functions to access it via vectors.">Vc::Common::InterleavedMemoryWrapper</a></dd></dl>

<p class="definition">Definition at line <a class="el" href="interleavedmemory_8h_source.html#l00345">345</a> of file <a class="el" href="interleavedmemory_8h_source.html">interleavedmemory.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="interleavedmemory_8h_source.html#l00345">make_interleave_wrapper()</a>.</p>

</div>
</div>
<a id="a63bfcd6356c01e01296f5db3c86bd43a" name="a63bfcd6356c01e01296f5db3c86bd43a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63bfcd6356c01e01296f5db3c86bd43a">&#9670;&nbsp;</a></span>simd_cast() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">To simd_cast </td>
          <td>(</td>
          <td class="paramtype">From &amp;&amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enable_if&lt; std::is_same&lt; To, Traits::decay&lt; From &gt; &gt;::value &gt;&#160;</td>
          <td class="paramname"> = <code>nullarg</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Casts the argument <code>x</code> from type <code>From</code> to type <code>To</code>. </p>
<p >This function implements the trivial case where <code>To</code> and <code>From</code> are the same type.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>The object of type <code>From</code> to be converted to type <code>To</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An object of type <code>To</code> with all vector components converted according to standard conversion behavior as mandated by the C++ standard for the underlying arithmetic types. </dd></dl>

<p class="definition">Definition at line <a class="el" href="simd__cast_8h_source.html#l00052">52</a> of file <a class="el" href="simd__cast_8h_source.html">simd_cast.h</a>.</p>

</div>
</div>
<a id="adb4e7042030e56e39539a1433e8c03e0" name="adb4e7042030e56e39539a1433e8c03e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb4e7042030e56e39539a1433e8c03e0">&#9670;&nbsp;</a></span>simd_cast() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">To simd_cast </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A cast from nothing results in default-initialization of <code>To</code>. </p>
<p >This function can be useful in generic code where a parameter pack expands to nothing.</p>
<dl class="section return"><dt>Returns</dt><dd>A zero-initialized object of type <code>To</code>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="simd__cast_8h_source.html#l00064">64</a> of file <a class="el" href="simd__cast_8h_source.html">simd_cast.h</a>.</p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespaceVc.html">Vc</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.4 </li>
  </ul>
</div>
</body>
</html>
