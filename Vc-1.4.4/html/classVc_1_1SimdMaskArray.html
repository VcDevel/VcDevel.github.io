<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.4"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Vc: SimdMaskArray&lt; T, N, V, Wt &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
  $(document).ready(function() { init_search(); });
/* @license-end */
</script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="logo_small.png"/></td>
  <td id="projectalign">
   <div id="projectname">Vc<span id="projectnumber">&#160;1.4.4</span>
   </div>
   <div id="projectbrief">SIMD Vector Classes for C++</div>
  </td>
    <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.svg"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.4 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('classVc_1_1SimdMaskArray.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="classVc_1_1SimdMaskArray-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">SimdMaskArray&lt; T, N, V, Wt &gt; Class Template Reference<div class="ingroups"><a class="el" href="group__SimdArray.html">SIMD Array</a></div></div></div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;typename T, size_t N, typename V, size_t Wt&gt;<br />
class Vc::SimdMaskArray&lt; T, N, V, Wt &gt;</div><p >Data-parallel mask type with user-defined number of boolean elements. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The value type of the corresponding <a class="el" href="classVc_1_1SimdArray.html" title="Data-parallel arithmetic type with user-defined number of elements.">SimdArray</a>. Depending on the target platform this type determines a different bit representation to work most efficient with <a class="el" href="classVc_1_1SimdArray.html" title="Data-parallel arithmetic type with user-defined number of elements.">SimdArray</a> types instantiated for <code>T</code>.</td></tr>
    <tr><td class="paramname">N</td><td>The number of boolean elements to store and process concurrently. You can choose an arbitrary number, though not every number is a good idea. Generally, a power of two value or the sum of two power of two values might work efficiently, though this depends a lot on the target system.</td></tr>
    <tr><td class="paramname">V</td><td>Don't change the default value unless you really know what you are doing. This type is set to the underlying native <a class="el" href="classVc_1_1Vector.html" title="The main vector class for expressing data parallelism.">Vc::Vector</a> type used in the implementation of the type. Having it as part of the type name guards against some cases of ODR violations (i.e. linking incompatible translation units / libraries).</td></tr>
    <tr><td class="paramname">Wt</td><td>Don't ever change the default value. This parameter is an unfortunate implementation detail shining through. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="simdmaskarray_8h_source.html#l00323">323</a> of file <a class="el" href="simdmaskarray_8h_source.html">simdmaskarray.h</a>.</p>
</div>
<p><code>#include &lt;<a class="el" href="simdmaskarray_8h_source.html">Vc/SimdArray</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a1361e8e9cce10205928db7c5d49c76dc"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVc_1_1SimdMaskArray.html#a1361e8e9cce10205928db7c5d49c76dc">value_type</a> = typename <a class="el" href="classVc_1_1Mask.html#af8d79876e53834654a2c408d3a3bca6a">storage_type0::EntryType</a></td></tr>
<tr class="memdesc:a1361e8e9cce10205928db7c5d49c76dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <code>EntryType</code> of masks is always <code>bool</code>, independent of <code>T</code>.  <a href="classVc_1_1SimdMaskArray.html#a1361e8e9cce10205928db7c5d49c76dc">More...</a><br /></td></tr>
<tr class="separator:a1361e8e9cce10205928db7c5d49c76dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a197e6d613393324683e71a9bbc4b1d36"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVc_1_1SimdMaskArray.html#a197e6d613393324683e71a9bbc4b1d36">MaskType</a> = <a class="el" href="classVc_1_1SimdMaskArray.html">mask_type</a></td></tr>
<tr class="memdesc:a197e6d613393324683e71a9bbc4b1d36"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a zero-initialized vector object.  <a href="classVc_1_1SimdMaskArray.html#a197e6d613393324683e71a9bbc4b1d36">More...</a><br /></td></tr>
<tr class="separator:a197e6d613393324683e71a9bbc4b1d36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54e5ed8e98d92aac3ac40647db1c17bf"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVc_1_1SimdMaskArray.html#a54e5ed8e98d92aac3ac40647db1c17bf">VectorEntryType</a> = vectorentry_type</td></tr>
<tr class="memdesc:a54e5ed8e98d92aac3ac40647db1c17bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <code>VectorEntryType</code>, in contrast to <code>EntryType</code>, reveals information about the SIMD implementation.  <a href="classVc_1_1SimdMaskArray.html#a54e5ed8e98d92aac3ac40647db1c17bf">More...</a><br /></td></tr>
<tr class="separator:a54e5ed8e98d92aac3ac40647db1c17bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae01209df02a8750be9c3aca4728e056d"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVc_1_1SimdMaskArray.html#ae01209df02a8750be9c3aca4728e056d">EntryType</a> = <a class="el" href="classVc_1_1SimdMaskArray.html#a1361e8e9cce10205928db7c5d49c76dc">value_type</a></td></tr>
<tr class="memdesc:ae01209df02a8750be9c3aca4728e056d"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <code>EntryType</code> of masks is always <code>bool</code>, independent of <code>T</code>.  <a href="classVc_1_1SimdMaskArray.html#ae01209df02a8750be9c3aca4728e056d">More...</a><br /></td></tr>
<tr class="separator:ae01209df02a8750be9c3aca4728e056d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a841b1b3a66f9457f3161e9b171af29f4"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVc_1_1SimdMaskArray.html#a841b1b3a66f9457f3161e9b171af29f4">EntryReference</a> = Vc::Detail::ElementReference&lt; <a class="el" href="classVc_1_1SimdMaskArray.html">SimdMaskArray</a> &gt;</td></tr>
<tr class="memdesc:a841b1b3a66f9457f3161e9b171af29f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">The reference wrapper type used for accessing individual mask components.  <a href="classVc_1_1SimdMaskArray.html#a841b1b3a66f9457f3161e9b171af29f4">More...</a><br /></td></tr>
<tr class="separator:a841b1b3a66f9457f3161e9b171af29f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41e2d619436c709fe4d989bd519c75c4"><td class="memItemLeft" align="right" valign="top"><a id="a41e2d619436c709fe4d989bd519c75c4" name="a41e2d619436c709fe4d989bd519c75c4"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>Vector</b> = <a class="el" href="classVc_1_1Vector.html">fixed_size_simd</a>&lt; T, N &gt;</td></tr>
<tr class="memdesc:a41e2d619436c709fe4d989bd519c75c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">An alias for the corresponding <a class="el" href="classVc_1_1SimdArray.html" title="Data-parallel arithmetic type with user-defined number of elements.">SimdArray</a> type. <br /></td></tr>
<tr class="separator:a41e2d619436c709fe4d989bd519c75c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ac3726a8e8149927942c1a1dcee279597"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVc_1_1SimdMaskArray.html#ac3726a8e8149927942c1a1dcee279597">SimdMaskArray</a> ()=default</td></tr>
<tr class="memdesc:ac3726a8e8149927942c1a1dcee279597"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a zero-initialized vector object.  <a href="classVc_1_1SimdMaskArray.html#ac3726a8e8149927942c1a1dcee279597">More...</a><br /></td></tr>
<tr class="separator:ac3726a8e8149927942c1a1dcee279597"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7cb2c66758351e600a2b63a6447bdd17"><td class="memItemLeft" align="right" valign="top"><a id="a7cb2c66758351e600a2b63a6447bdd17" name="a7cb2c66758351e600a2b63a6447bdd17"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>SimdMaskArray</b> (VectorSpecialInitializerOne one)</td></tr>
<tr class="memdesc:a7cb2c66758351e600a2b63a6447bdd17"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize the new mask object to one (<code>true</code>). <br /></td></tr>
<tr class="separator:a7cb2c66758351e600a2b63a6447bdd17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af532e5e145f96b14e411852b7491cbdb"><td class="memItemLeft" align="right" valign="top"><a id="af532e5e145f96b14e411852b7491cbdb" name="af532e5e145f96b14e411852b7491cbdb"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>SimdMaskArray</b> (VectorSpecialInitializerZero zero)</td></tr>
<tr class="memdesc:af532e5e145f96b14e411852b7491cbdb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Zero-initialize the new mask object (<code>false</code>). <br /></td></tr>
<tr class="separator:af532e5e145f96b14e411852b7491cbdb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0558e628a2e7e2511b250e724a5a82bc"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVc_1_1SimdMaskArray.html#a0558e628a2e7e2511b250e724a5a82bc">SimdMaskArray</a> (bool b)</td></tr>
<tr class="memdesc:a0558e628a2e7e2511b250e724a5a82bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Broadcast constructor.  <a href="classVc_1_1SimdMaskArray.html#a0558e628a2e7e2511b250e724a5a82bc">More...</a><br /></td></tr>
<tr class="separator:a0558e628a2e7e2511b250e724a5a82bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc2d88f2435a2c3c341730f6a1621f2c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVc_1_1SimdMaskArray.html#adc2d88f2435a2c3c341730f6a1621f2c">operator==</a> (const <a class="el" href="classVc_1_1SimdMaskArray.html">SimdMaskArray</a> &amp;mask) const</td></tr>
<tr class="memdesc:adc2d88f2435a2c3c341730f6a1621f2c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether the two masks are equal in all components.  <a href="classVc_1_1SimdMaskArray.html#adc2d88f2435a2c3c341730f6a1621f2c">More...</a><br /></td></tr>
<tr class="separator:adc2d88f2435a2c3c341730f6a1621f2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55081def08b7e959e40961186be9b63c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVc_1_1SimdMaskArray.html#a55081def08b7e959e40961186be9b63c">operator!=</a> (const <a class="el" href="classVc_1_1SimdMaskArray.html">SimdMaskArray</a> &amp;mask) const</td></tr>
<tr class="memdesc:a55081def08b7e959e40961186be9b63c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether the two masks are different in at least one component.  <a href="classVc_1_1SimdMaskArray.html#a55081def08b7e959e40961186be9b63c">More...</a><br /></td></tr>
<tr class="separator:a55081def08b7e959e40961186be9b63c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab3980bf7455cc37b683bee2bf88e93f"><td class="memItemLeft" align="right" valign="top"><a id="aab3980bf7455cc37b683bee2bf88e93f" name="aab3980bf7455cc37b683bee2bf88e93f"></a>
<a class="el" href="classVc_1_1Mask.html">fixed_size_simd_mask</a>&lt; T, N &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>operator!</b> () const</td></tr>
<tr class="memdesc:aab3980bf7455cc37b683bee2bf88e93f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a mask with inverted components. <br /></td></tr>
<tr class="separator:aab3980bf7455cc37b683bee2bf88e93f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4efe92f6c228e34f5cd11cd56a5ca2a"><td class="memItemLeft" align="right" valign="top"><a id="af4efe92f6c228e34f5cd11cd56a5ca2a" name="af4efe92f6c228e34f5cd11cd56a5ca2a"></a>
<a class="el" href="classVc_1_1SimdMaskArray.html">SimdMaskArray</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator&amp;=</b> (const <a class="el" href="classVc_1_1SimdMaskArray.html">SimdMaskArray</a> &amp;rhs)</td></tr>
<tr class="memdesc:af4efe92f6c228e34f5cd11cd56a5ca2a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Modifies the mask using an <code>AND</code> operation with <code>mask</code>. <br /></td></tr>
<tr class="separator:af4efe92f6c228e34f5cd11cd56a5ca2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23098b20d7ae5ccdbb5b3126c2c1bd08"><td class="memItemLeft" align="right" valign="top"><a id="a23098b20d7ae5ccdbb5b3126c2c1bd08" name="a23098b20d7ae5ccdbb5b3126c2c1bd08"></a>
<a class="el" href="classVc_1_1SimdMaskArray.html">SimdMaskArray</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator|=</b> (const <a class="el" href="classVc_1_1SimdMaskArray.html">SimdMaskArray</a> &amp;rhs)</td></tr>
<tr class="memdesc:a23098b20d7ae5ccdbb5b3126c2c1bd08"><td class="mdescLeft">&#160;</td><td class="mdescRight">Modifies the mask using an <code>OR</code> operation with <code>mask</code>. <br /></td></tr>
<tr class="separator:a23098b20d7ae5ccdbb5b3126c2c1bd08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8bb64fd6e0c6af453a9d883989f57f94"><td class="memItemLeft" align="right" valign="top"><a id="a8bb64fd6e0c6af453a9d883989f57f94" name="a8bb64fd6e0c6af453a9d883989f57f94"></a>
<a class="el" href="classVc_1_1SimdMaskArray.html">SimdMaskArray</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator^=</b> (const <a class="el" href="classVc_1_1SimdMaskArray.html">SimdMaskArray</a> &amp;rhs)</td></tr>
<tr class="memdesc:a8bb64fd6e0c6af453a9d883989f57f94"><td class="mdescLeft">&#160;</td><td class="mdescRight">Modifies the mask using an <code>XOR</code> operation with <code>mask</code>. <br /></td></tr>
<tr class="separator:a8bb64fd6e0c6af453a9d883989f57f94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a011ca319c87d03b5bc1b7e3e6ae33d95"><td class="memItemLeft" align="right" valign="top"><a id="a011ca319c87d03b5bc1b7e3e6ae33d95" name="a011ca319c87d03b5bc1b7e3e6ae33d95"></a>
<a class="el" href="classVc_1_1Mask.html">fixed_size_simd_mask</a>&lt; T, N &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>operator&amp;</b> (const <a class="el" href="classVc_1_1SimdMaskArray.html">SimdMaskArray</a> &amp;rhs) const</td></tr>
<tr class="memdesc:a011ca319c87d03b5bc1b7e3e6ae33d95"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the component-wise application of a binary <code>AND</code> to <code>mask</code>. <br /></td></tr>
<tr class="separator:a011ca319c87d03b5bc1b7e3e6ae33d95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc1935d774a6d97cbf2a92d4f1d1c923"><td class="memItemLeft" align="right" valign="top"><a id="afc1935d774a6d97cbf2a92d4f1d1c923" name="afc1935d774a6d97cbf2a92d4f1d1c923"></a>
<a class="el" href="classVc_1_1Mask.html">fixed_size_simd_mask</a>&lt; T, N &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>operator|</b> (const <a class="el" href="classVc_1_1SimdMaskArray.html">SimdMaskArray</a> &amp;rhs) const</td></tr>
<tr class="memdesc:afc1935d774a6d97cbf2a92d4f1d1c923"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the component-wise application of a binary <code>OR</code> to <code>mask</code>. <br /></td></tr>
<tr class="separator:afc1935d774a6d97cbf2a92d4f1d1c923"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b4c80390a969582d98b08a22e32c7d0"><td class="memItemLeft" align="right" valign="top"><a id="a3b4c80390a969582d98b08a22e32c7d0" name="a3b4c80390a969582d98b08a22e32c7d0"></a>
<a class="el" href="classVc_1_1Mask.html">fixed_size_simd_mask</a>&lt; T, N &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>operator^</b> (const <a class="el" href="classVc_1_1SimdMaskArray.html">SimdMaskArray</a> &amp;rhs) const</td></tr>
<tr class="memdesc:a3b4c80390a969582d98b08a22e32c7d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the component-wise application of a binary <code>XOR</code> to <code>mask</code>. <br /></td></tr>
<tr class="separator:a3b4c80390a969582d98b08a22e32c7d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f234309ef366f9bd15c83e6ddfaa622"><td class="memItemLeft" align="right" valign="top"><a id="a6f234309ef366f9bd15c83e6ddfaa622" name="a6f234309ef366f9bd15c83e6ddfaa622"></a>
<a class="el" href="classVc_1_1Mask.html">fixed_size_simd_mask</a>&lt; T, N &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>operator&amp;&amp;</b> (const <a class="el" href="classVc_1_1SimdMaskArray.html">SimdMaskArray</a> &amp;rhs) const</td></tr>
<tr class="memdesc:a6f234309ef366f9bd15c83e6ddfaa622"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the component-wise application of a logical <code>AND</code> to <code>mask</code>. <br /></td></tr>
<tr class="separator:a6f234309ef366f9bd15c83e6ddfaa622"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89051f875b138487adc98ae7ff912ddc"><td class="memItemLeft" align="right" valign="top"><a id="a89051f875b138487adc98ae7ff912ddc" name="a89051f875b138487adc98ae7ff912ddc"></a>
<a class="el" href="classVc_1_1Mask.html">fixed_size_simd_mask</a>&lt; T, N &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>operator||</b> (const <a class="el" href="classVc_1_1SimdMaskArray.html">SimdMaskArray</a> &amp;rhs) const</td></tr>
<tr class="memdesc:a89051f875b138487adc98ae7ff912ddc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the component-wise application of a logical <code>OR</code> to <code>mask</code>. <br /></td></tr>
<tr class="separator:a89051f875b138487adc98ae7ff912ddc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad753310e7ebeac80873cea6766ad1e60"><td class="memItemLeft" align="right" valign="top"><a id="ad753310e7ebeac80873cea6766ad1e60" name="ad753310e7ebeac80873cea6766ad1e60"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>isFull</b> () const</td></tr>
<tr class="memdesc:ad753310e7ebeac80873cea6766ad1e60"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a logical <code>AND</code> of all components. <br /></td></tr>
<tr class="separator:ad753310e7ebeac80873cea6766ad1e60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47e00abdf43d5bda786659b43b26ffb3"><td class="memItemLeft" align="right" valign="top"><a id="a47e00abdf43d5bda786659b43b26ffb3" name="a47e00abdf43d5bda786659b43b26ffb3"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>isNotEmpty</b> () const</td></tr>
<tr class="memdesc:a47e00abdf43d5bda786659b43b26ffb3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a logical <code>OR</code> of all components. <br /></td></tr>
<tr class="separator:a47e00abdf43d5bda786659b43b26ffb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf82f9b2937375c7b1cf3dccb3df3312"><td class="memItemLeft" align="right" valign="top"><a id="acf82f9b2937375c7b1cf3dccb3df3312" name="acf82f9b2937375c7b1cf3dccb3df3312"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>isEmpty</b> () const</td></tr>
<tr class="memdesc:acf82f9b2937375c7b1cf3dccb3df3312"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>true</code> if components are <code>false</code>, <code>false</code> otherwise. <br /></td></tr>
<tr class="separator:acf82f9b2937375c7b1cf3dccb3df3312"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31f380fde21e6686d149a1009f378a24"><td class="memItemLeft" align="right" valign="top"><a id="a31f380fde21e6686d149a1009f378a24" name="a31f380fde21e6686d149a1009f378a24"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>isMix</b> () const</td></tr>
<tr class="memdesc:a31f380fde21e6686d149a1009f378a24"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>!isFull() &amp;&amp; !isEmpty()</code>. <br /></td></tr>
<tr class="separator:a31f380fde21e6686d149a1009f378a24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8cc7782de081ce702a9be163b4cb8f84"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVc_1_1SimdMaskArray.html#a8cc7782de081ce702a9be163b4cb8f84">toInt</a> () const</td></tr>
<tr class="memdesc:a8cc7782de081ce702a9be163b4cb8f84"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert the boolean components of the mask into bits of an integer.  <a href="classVc_1_1SimdMaskArray.html#a8cc7782de081ce702a9be163b4cb8f84">More...</a><br /></td></tr>
<tr class="separator:a8cc7782de081ce702a9be163b4cb8f84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9490a1dfe9ab280829a12edea2a858b"><td class="memItemLeft" align="right" valign="top">reference&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVc_1_1SimdMaskArray.html#ad9490a1dfe9ab280829a12edea2a858b">operator[]</a> (size_t index) noexcept</td></tr>
<tr class="memdesc:ad9490a1dfe9ab280829a12edea2a858b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a smart reference to the boolean element at index <code>index</code>.  <a href="classVc_1_1SimdMaskArray.html#ad9490a1dfe9ab280829a12edea2a858b">More...</a><br /></td></tr>
<tr class="separator:ad9490a1dfe9ab280829a12edea2a858b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7941a8bfa6845a198bda7038a39e18f0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classVc_1_1SimdMaskArray.html#a1361e8e9cce10205928db7c5d49c76dc">value_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVc_1_1SimdMaskArray.html#a7941a8bfa6845a198bda7038a39e18f0">operator[]</a> (size_t index) const noexcept</td></tr>
<tr class="memdesc:a7941a8bfa6845a198bda7038a39e18f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a copy of the boolean element at index <code>index</code>.  <a href="classVc_1_1SimdMaskArray.html#a7941a8bfa6845a198bda7038a39e18f0">More...</a><br /></td></tr>
<tr class="separator:a7941a8bfa6845a198bda7038a39e18f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e2c15c517007b91c37b2aa68bf2484a"><td class="memItemLeft" align="right" valign="top"><a id="a0e2c15c517007b91c37b2aa68bf2484a" name="a0e2c15c517007b91c37b2aa68bf2484a"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>count</b> () const</td></tr>
<tr class="memdesc:a0e2c15c517007b91c37b2aa68bf2484a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns how many components of the mask are <code>true</code>. <br /></td></tr>
<tr class="separator:a0e2c15c517007b91c37b2aa68bf2484a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad24cd7d179a4f1b5d9435ad8e913dc34"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVc_1_1SimdMaskArray.html#ad24cd7d179a4f1b5d9435ad8e913dc34">firstOne</a> () const</td></tr>
<tr class="memdesc:ad24cd7d179a4f1b5d9435ad8e913dc34"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the index of the first one in the mask.  <a href="classVc_1_1SimdMaskArray.html#ad24cd7d179a4f1b5d9435ad8e913dc34">More...</a><br /></td></tr>
<tr class="separator:ad24cd7d179a4f1b5d9435ad8e913dc34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd618a9214496c5c87c7636bdaf5e44f"><td class="memItemLeft" align="right" valign="top"><a id="abd618a9214496c5c87c7636bdaf5e44f" name="abd618a9214496c5c87c7636bdaf5e44f"></a>
<a class="el" href="classVc_1_1Mask.html">fixed_size_simd_mask</a>&lt; T, N &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>shifted</b> (int amount) const</td></tr>
<tr class="memdesc:abd618a9214496c5c87c7636bdaf5e44f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a mask with components shifted by <code>amount</code> places. <br /></td></tr>
<tr class="separator:abd618a9214496c5c87c7636bdaf5e44f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">new/delete overloads for correct alignment</div></td></tr>
<tr class="memitem:a160dcabc54bbecfc69484678cafadb81"><td class="memItemLeft" align="right" valign="top"><a id="a160dcabc54bbecfc69484678cafadb81" name="a160dcabc54bbecfc69484678cafadb81"></a>
void *&#160;</td><td class="memItemRight" valign="bottom"><b>operator new</b> (size_t <a class="el" href="classVc_1_1SimdMaskArray.html#a5e99fb015bfbc024a4b785135b34dee7">size</a>)</td></tr>
<tr class="memdesc:a160dcabc54bbecfc69484678cafadb81"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocates correctly aligned memory. <br /></td></tr>
<tr class="separator:a160dcabc54bbecfc69484678cafadb81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac15c9ad7f49147e20d631483c08a35be"><td class="memItemLeft" align="right" valign="top"><a id="ac15c9ad7f49147e20d631483c08a35be" name="ac15c9ad7f49147e20d631483c08a35be"></a>
void *&#160;</td><td class="memItemRight" valign="bottom"><b>operator new</b> (size_t, void *p)</td></tr>
<tr class="memdesc:ac15c9ad7f49147e20d631483c08a35be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>p</code>. <br /></td></tr>
<tr class="separator:ac15c9ad7f49147e20d631483c08a35be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2243bb4c2126b7b2b393e06090fbe59"><td class="memItemLeft" align="right" valign="top"><a id="af2243bb4c2126b7b2b393e06090fbe59" name="af2243bb4c2126b7b2b393e06090fbe59"></a>
void *&#160;</td><td class="memItemRight" valign="bottom"><b>operator new[]</b> (size_t <a class="el" href="classVc_1_1SimdMaskArray.html#a5e99fb015bfbc024a4b785135b34dee7">size</a>)</td></tr>
<tr class="memdesc:af2243bb4c2126b7b2b393e06090fbe59"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocates correctly aligned memory. <br /></td></tr>
<tr class="separator:af2243bb4c2126b7b2b393e06090fbe59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7029f8f4c92db165d922eb024b5a21ac"><td class="memItemLeft" align="right" valign="top"><a id="a7029f8f4c92db165d922eb024b5a21ac" name="a7029f8f4c92db165d922eb024b5a21ac"></a>
void *&#160;</td><td class="memItemRight" valign="bottom"><b>operator new[]</b> (size_t, void *p)</td></tr>
<tr class="memdesc:a7029f8f4c92db165d922eb024b5a21ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>p</code>. <br /></td></tr>
<tr class="separator:a7029f8f4c92db165d922eb024b5a21ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22999735d5b1e1cb645614d22f108611"><td class="memItemLeft" align="right" valign="top"><a id="a22999735d5b1e1cb645614d22f108611" name="a22999735d5b1e1cb645614d22f108611"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>operator delete</b> (void *ptr, size_t)</td></tr>
<tr class="memdesc:a22999735d5b1e1cb645614d22f108611"><td class="mdescLeft">&#160;</td><td class="mdescRight">Frees aligned memory. <br /></td></tr>
<tr class="separator:a22999735d5b1e1cb645614d22f108611"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41d83e8020f1d841b254be6ebeda92d2"><td class="memItemLeft" align="right" valign="top"><a id="a41d83e8020f1d841b254be6ebeda92d2" name="a41d83e8020f1d841b254be6ebeda92d2"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>operator delete</b> (void *, void *)</td></tr>
<tr class="memdesc:a41d83e8020f1d841b254be6ebeda92d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Does nothing. <br /></td></tr>
<tr class="separator:a41d83e8020f1d841b254be6ebeda92d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abefd12c9bd2fa9cd4a27cdabf64b03f8"><td class="memItemLeft" align="right" valign="top"><a id="abefd12c9bd2fa9cd4a27cdabf64b03f8" name="abefd12c9bd2fa9cd4a27cdabf64b03f8"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>operator delete[]</b> (void *ptr, size_t)</td></tr>
<tr class="memdesc:abefd12c9bd2fa9cd4a27cdabf64b03f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Frees aligned memory. <br /></td></tr>
<tr class="separator:abefd12c9bd2fa9cd4a27cdabf64b03f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afea8decef8f286c8d73c89a1a81d4555"><td class="memItemLeft" align="right" valign="top"><a id="afea8decef8f286c8d73c89a1a81d4555" name="afea8decef8f286c8d73c89a1a81d4555"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>operator delete[]</b> (void *, void *)</td></tr>
<tr class="memdesc:afea8decef8f286c8d73c89a1a81d4555"><td class="mdescLeft">&#160;</td><td class="mdescRight">Does nothing. <br /></td></tr>
<tr class="separator:afea8decef8f286c8d73c89a1a81d4555"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Loads &amp; Stores</div></td></tr>
<tr class="memitem:a5b4dace4dd70d203e3304e8dbe6c1d2e"><td class="memTemplParams" colspan="2">template&lt;typename Flags  = DefaultLoadTag&gt; </td></tr>
<tr class="memitem:a5b4dace4dd70d203e3304e8dbe6c1d2e"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classVc_1_1SimdMaskArray.html#a5b4dace4dd70d203e3304e8dbe6c1d2e">SimdMaskArray</a> (const bool *mem, Flags f=Flags())</td></tr>
<tr class="memdesc:a5b4dace4dd70d203e3304e8dbe6c1d2e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load N boolean values from the consecutive addresses starting at <code>mem</code>.  <a href="classVc_1_1SimdMaskArray.html#a5b4dace4dd70d203e3304e8dbe6c1d2e">More...</a><br /></td></tr>
<tr class="separator:a5b4dace4dd70d203e3304e8dbe6c1d2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a587a49eeafeaca6d87eddd82401a9770"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVc_1_1SimdMaskArray.html#a587a49eeafeaca6d87eddd82401a9770">load</a> (const bool *mem)</td></tr>
<tr class="memdesc:a587a49eeafeaca6d87eddd82401a9770"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load N boolean values from the consecutive addresses starting at <code>mem</code>.  <a href="classVc_1_1SimdMaskArray.html#a587a49eeafeaca6d87eddd82401a9770">More...</a><br /></td></tr>
<tr class="separator:a587a49eeafeaca6d87eddd82401a9770"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abaa2275c0ae29230ea9131bd69a0b180"><td class="memTemplParams" colspan="2">template&lt;typename Flags &gt; </td></tr>
<tr class="memitem:abaa2275c0ae29230ea9131bd69a0b180"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classVc_1_1SimdMaskArray.html#abaa2275c0ae29230ea9131bd69a0b180">load</a> (const bool *mem, Flags f)</td></tr>
<tr class="memdesc:abaa2275c0ae29230ea9131bd69a0b180"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load N boolean values from the consecutive addresses starting at <code>mem</code>.  <a href="classVc_1_1SimdMaskArray.html#abaa2275c0ae29230ea9131bd69a0b180">More...</a><br /></td></tr>
<tr class="separator:abaa2275c0ae29230ea9131bd69a0b180"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05f98034a4ff730c8398fe580d8c89a9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVc_1_1SimdMaskArray.html#a05f98034a4ff730c8398fe580d8c89a9">store</a> (bool *mem) const</td></tr>
<tr class="memdesc:a05f98034a4ff730c8398fe580d8c89a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Store N boolean values to the consecutive addresses starting at <code>mem</code>.  <a href="classVc_1_1SimdMaskArray.html#a05f98034a4ff730c8398fe580d8c89a9">More...</a><br /></td></tr>
<tr class="separator:a05f98034a4ff730c8398fe580d8c89a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab98867a1176923e0f9faf8005fea54f"><td class="memTemplParams" colspan="2">template&lt;typename Flags &gt; </td></tr>
<tr class="memitem:aab98867a1176923e0f9faf8005fea54f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classVc_1_1SimdMaskArray.html#aab98867a1176923e0f9faf8005fea54f">store</a> (bool *mem, Flags f) const</td></tr>
<tr class="memdesc:aab98867a1176923e0f9faf8005fea54f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Store N boolean values to the consecutive addresses starting at <code>mem</code>.  <a href="classVc_1_1SimdMaskArray.html#aab98867a1176923e0f9faf8005fea54f">More...</a><br /></td></tr>
<tr class="separator:aab98867a1176923e0f9faf8005fea54f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-methods" name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a5e99fb015bfbc024a4b785135b34dee7"><td class="memItemLeft" align="right" valign="top">static constexpr std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVc_1_1SimdMaskArray.html#a5e99fb015bfbc024a4b785135b34dee7">size</a> ()</td></tr>
<tr class="memdesc:a5e99fb015bfbc024a4b785135b34dee7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of boolean components ( \(\mathcal{W}_\mathtt{T}\)) in a mask of this type.  <a href="classVc_1_1SimdMaskArray.html#a5e99fb015bfbc024a4b785135b34dee7">More...</a><br /></td></tr>
<tr class="separator:a5e99fb015bfbc024a4b785135b34dee7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24c1d6b5037f796aba17a16f9be6070f"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classVc_1_1Mask.html">fixed_size_simd_mask</a>&lt; T, N &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVc_1_1SimdMaskArray.html#a24c1d6b5037f796aba17a16f9be6070f">Zero</a> ()</td></tr>
<tr class="memdesc:a24c1d6b5037f796aba17a16f9be6070f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new mask object initialized to zero/<code>false</code>.  <a href="classVc_1_1SimdMaskArray.html#a24c1d6b5037f796aba17a16f9be6070f">More...</a><br /></td></tr>
<tr class="separator:a24c1d6b5037f796aba17a16f9be6070f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a481cae03fc57c4face77727932a3d676"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classVc_1_1Mask.html">fixed_size_simd_mask</a>&lt; T, N &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVc_1_1SimdMaskArray.html#a481cae03fc57c4face77727932a3d676">One</a> ()</td></tr>
<tr class="memdesc:a481cae03fc57c4face77727932a3d676"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a mask object initialized to one/<code>true</code>.  <a href="classVc_1_1SimdMaskArray.html#a481cae03fc57c4face77727932a3d676">More...</a><br /></td></tr>
<tr class="separator:a481cae03fc57c4face77727932a3d676"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3aa157b9dd8e7830ae61a67263b52df"><td class="memTemplParams" colspan="2"><a id="aa3aa157b9dd8e7830ae61a67263b52df" name="aa3aa157b9dd8e7830ae61a67263b52df"></a>
template&lt;typename G &gt; </td></tr>
<tr class="memitem:aa3aa157b9dd8e7830ae61a67263b52df"><td class="memTemplItemLeft" align="right" valign="top">static <a class="el" href="classVc_1_1Mask.html">fixed_size_simd_mask</a>&lt; T, N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>generate</b> (const G &amp;gen)</td></tr>
<tr class="memdesc:aa3aa157b9dd8e7830ae61a67263b52df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate a mask object from booleans returned from the function <code>gen</code>. <br /></td></tr>
<tr class="separator:aa3aa157b9dd8e7830ae61a67263b52df"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-attribs" name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:gad550c4cd366024e9b37c4a7c7c9b96ff"><td class="memItemLeft" align="right" valign="top">static constexpr std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__SimdArray.html#gad550c4cd366024e9b37c4a7c7c9b96ff">Size</a> = <a class="el" href="classVc_1_1SimdMaskArray.html#a5e99fb015bfbc024a4b785135b34dee7">size</a>()</td></tr>
<tr class="memdesc:gad550c4cd366024e9b37c4a7c7c9b96ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of boolean components ( \(\mathcal{W}_\mathtt{T}\)) in a mask of this type.  <a href="group__SimdArray.html#gad550c4cd366024e9b37c4a7c7c9b96ff">More...</a><br /></td></tr>
<tr class="separator:gad550c4cd366024e9b37c4a7c7c9b96ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaac286912729d28478c8c9a1ac97a92ac"><td class="memItemLeft" align="right" valign="top">static constexpr std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__SimdArray.html#gaac286912729d28478c8c9a1ac97a92ac">MemoryAlignment</a></td></tr>
<tr class="memdesc:gaac286912729d28478c8c9a1ac97a92ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specifies the alignment requirement for aligned load and store calls for objects of this mask type.  <a href="group__SimdArray.html#gaac286912729d28478c8c9a1ac97a92ac">More...</a><br /></td></tr>
<tr class="separator:gaac286912729d28478c8c9a1ac97a92ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a1361e8e9cce10205928db7c5d49c76dc" name="a1361e8e9cce10205928db7c5d49c76dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1361e8e9cce10205928db7c5d49c76dc">&#9670;&nbsp;</a></span>value_type</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classVc_1_1SimdMaskArray.html#a1361e8e9cce10205928db7c5d49c76dc">value_type</a> =  typename <a class="el" href="classVc_1_1Mask.html#af8d79876e53834654a2c408d3a3bca6a">storage_type0::EntryType</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The <code>EntryType</code> of masks is always <code>bool</code>, independent of <code>T</code>. </p>

<p class="definition">Definition at line <a class="el" href="simdmaskarray_8h_source.html#l00358">358</a> of file <a class="el" href="simdmaskarray_8h_source.html">simdmaskarray.h</a>.</p>

</div>
</div>
<a id="a197e6d613393324683e71a9bbc4b1d36" name="a197e6d613393324683e71a9bbc4b1d36"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a197e6d613393324683e71a9bbc4b1d36">&#9670;&nbsp;</a></span>MaskType</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classVc_1_1SimdMaskArray.html#a197e6d613393324683e71a9bbc4b1d36">MaskType</a> =  <a class="el" href="classVc_1_1SimdMaskArray.html">mask_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct a zero-initialized vector object. </p>
<p >This constructor follows the behavior of the underlying <code>bool</code> type in that the expression <code>bool()</code> zero-initializes the object (to <code>false</code>). On the other hand the variable <code>x</code> in <code>bool x;</code> is uninitialized. Since, for class types, both expressions call the default constructor <code><a class="el" href="classVc_1_1Mask.html" title="The main SIMD mask class.">Mask</a>&lt;T&gt; x</code> must zero-initialize <code>x</code> as well. </p>

<p class="definition">Definition at line <a class="el" href="simdmaskarray_8h_source.html#l00360">360</a> of file <a class="el" href="simdmaskarray_8h_source.html">simdmaskarray.h</a>.</p>

</div>
</div>
<a id="a54e5ed8e98d92aac3ac40647db1c17bf" name="a54e5ed8e98d92aac3ac40647db1c17bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a54e5ed8e98d92aac3ac40647db1c17bf">&#9670;&nbsp;</a></span>VectorEntryType</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classVc_1_1SimdMaskArray.html#a54e5ed8e98d92aac3ac40647db1c17bf">VectorEntryType</a> =  vectorentry_type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The <code>VectorEntryType</code>, in contrast to <code>EntryType</code>, reveals information about the SIMD implementation. </p>
<p >This type is useful for the <code>sizeof</code> operator in generic functions. </p>

<p class="definition">Definition at line <a class="el" href="simdmaskarray_8h_source.html#l00362">362</a> of file <a class="el" href="simdmaskarray_8h_source.html">simdmaskarray.h</a>.</p>

</div>
</div>
<a id="ae01209df02a8750be9c3aca4728e056d" name="ae01209df02a8750be9c3aca4728e056d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae01209df02a8750be9c3aca4728e056d">&#9670;&nbsp;</a></span>EntryType</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classVc_1_1SimdMaskArray.html#ae01209df02a8750be9c3aca4728e056d">EntryType</a> =  <a class="el" href="classVc_1_1SimdMaskArray.html#a1361e8e9cce10205928db7c5d49c76dc">value_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The <code>EntryType</code> of masks is always <code>bool</code>, independent of <code>T</code>. </p>

<p class="definition">Definition at line <a class="el" href="simdmaskarray_8h_source.html#l00364">364</a> of file <a class="el" href="simdmaskarray_8h_source.html">simdmaskarray.h</a>.</p>

</div>
</div>
<a id="a841b1b3a66f9457f3161e9b171af29f4" name="a841b1b3a66f9457f3161e9b171af29f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a841b1b3a66f9457f3161e9b171af29f4">&#9670;&nbsp;</a></span>EntryReference</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classVc_1_1SimdMaskArray.html#a841b1b3a66f9457f3161e9b171af29f4">EntryReference</a> =  Vc::Detail::ElementReference&lt;<a class="el" href="classVc_1_1SimdMaskArray.html">SimdMaskArray</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The reference wrapper type used for accessing individual mask components. </p>

<p class="definition">Definition at line <a class="el" href="simdmaskarray_8h_source.html#l00366">366</a> of file <a class="el" href="simdmaskarray_8h_source.html">simdmaskarray.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="ac3726a8e8149927942c1a1dcee279597" name="ac3726a8e8149927942c1a1dcee279597"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac3726a8e8149927942c1a1dcee279597">&#9670;&nbsp;</a></span>SimdMaskArray() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVc_1_1SimdMaskArray.html">SimdMaskArray</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct a zero-initialized vector object. </p>
<p >This constructor follows the behavior of the underlying <code>bool</code> type in that the expression <code>bool()</code> zero-initializes the object (to <code>false</code>). On the other hand the variable <code>x</code> in <code>bool x;</code> is uninitialized. Since, for class types, both expressions call the default constructor <code><a class="el" href="classVc_1_1Mask.html" title="The main SIMD mask class.">Mask</a>&lt;T&gt; x</code> must zero-initialize <code>x</code> as well. </p>

</div>
</div>
<a id="a0558e628a2e7e2511b250e724a5a82bc" name="a0558e628a2e7e2511b250e724a5a82bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0558e628a2e7e2511b250e724a5a82bc">&#9670;&nbsp;</a></span>SimdMaskArray() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVc_1_1SimdMaskArray.html">SimdMaskArray</a> </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>b</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Broadcast constructor. </p>
<p >Set all components of the new mask object to <code>b</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">b</td><td>Determines the initial state of the mask. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="simdmaskarray_8h_source.html#l00435">435</a> of file <a class="el" href="simdmaskarray_8h_source.html">simdmaskarray.h</a>.</p>

</div>
</div>
<a id="a5b4dace4dd70d203e3304e8dbe6c1d2e" name="a5b4dace4dd70d203e3304e8dbe6c1d2e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b4dace4dd70d203e3304e8dbe6c1d2e">&#9670;&nbsp;</a></span>SimdMaskArray() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVc_1_1SimdMaskArray.html">SimdMaskArray</a> </td>
          <td>(</td>
          <td class="paramtype">const bool *&#160;</td>
          <td class="paramname"><em>mem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Flags&#160;</td>
          <td class="paramname"><em>f</em> = <code>Flags()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Load N boolean values from the consecutive addresses starting at <code>mem</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mem</td><td>A pointer to an array of booleans. </td></tr>
    <tr><td class="paramname">f</td><td>A combination of flags to modify specific behavior of the load. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="simdmaskarray_8h_source.html#l00458">458</a> of file <a class="el" href="simdmaskarray_8h_source.html">simdmaskarray.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a5e99fb015bfbc024a4b785135b34dee7" name="a5e99fb015bfbc024a4b785135b34dee7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e99fb015bfbc024a4b785135b34dee7">&#9670;&nbsp;</a></span>size()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr std::size_t size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of boolean components ( \(\mathcal{W}_\mathtt{T}\)) in a mask of this type. </p>
<p >The size of the mask. I.e. the number of boolean entries in the mask. Do not make any assumptions about the size of masks.</p>
<p >In addition, you can easily use if clauses that compare sizes. The compiler can statically evaluate and fully optimize dead code away (very much like #ifdef, but with syntax checking).</p>
<dl class="section return"><dt>Returns</dt><dd>The number of components (i.e. \(\mathcal{W}_\mathtt{T}\)) objects of this mask type store and manipulate. </dd></dl>

<p class="definition">Definition at line <a class="el" href="simdmaskarray_8h_source.html#l00344">344</a> of file <a class="el" href="simdmaskarray_8h_source.html">simdmaskarray.h</a>.</p>

</div>
</div>
<a id="a24c1d6b5037f796aba17a16f9be6070f" name="a24c1d6b5037f796aba17a16f9be6070f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24c1d6b5037f796aba17a16f9be6070f">&#9670;&nbsp;</a></span>Zero()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classVc_1_1Mask.html">fixed_size_simd_mask</a>&lt; T, N &gt; Zero </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new mask object initialized to zero/<code>false</code>. </p>
<dl class="section return"><dt>Returns</dt><dd>A mask object with zero-initialized components. </dd></dl>

<p class="definition">Definition at line <a class="el" href="simdmaskarray_8h_source.html#l00438">438</a> of file <a class="el" href="simdmaskarray_8h_source.html">simdmaskarray.h</a>.</p>

</div>
</div>
<a id="a481cae03fc57c4face77727932a3d676" name="a481cae03fc57c4face77727932a3d676"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a481cae03fc57c4face77727932a3d676">&#9670;&nbsp;</a></span>One()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classVc_1_1Mask.html">fixed_size_simd_mask</a>&lt; T, N &gt; One </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a mask object initialized to one/<code>true</code>. </p>
<dl class="section return"><dt>Returns</dt><dd>A mask object with components initialized to <code>true</code>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="simdmaskarray_8h_source.html#l00443">443</a> of file <a class="el" href="simdmaskarray_8h_source.html">simdmaskarray.h</a>.</p>

</div>
</div>
<a id="a587a49eeafeaca6d87eddd82401a9770" name="a587a49eeafeaca6d87eddd82401a9770"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a587a49eeafeaca6d87eddd82401a9770">&#9670;&nbsp;</a></span>load() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void load </td>
          <td>(</td>
          <td class="paramtype">const bool *&#160;</td>
          <td class="paramname"><em>mem</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Load N boolean values from the consecutive addresses starting at <code>mem</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mem</td><td>A pointer to an array of booleans. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="simdmaskarray_8h_source.html#l00468">468</a> of file <a class="el" href="simdmaskarray_8h_source.html">simdmaskarray.h</a>.</p>

</div>
</div>
<a id="abaa2275c0ae29230ea9131bd69a0b180" name="abaa2275c0ae29230ea9131bd69a0b180"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abaa2275c0ae29230ea9131bd69a0b180">&#9670;&nbsp;</a></span>load() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void load </td>
          <td>(</td>
          <td class="paramtype">const bool *&#160;</td>
          <td class="paramname"><em>mem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Flags&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Load N boolean values from the consecutive addresses starting at <code>mem</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mem</td><td>A pointer to an array of booleans. </td></tr>
    <tr><td class="paramname">f</td><td>A combination of flags to modify specific behavior of the load. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="simdmaskarray_8h_source.html#l00480">480</a> of file <a class="el" href="simdmaskarray_8h_source.html">simdmaskarray.h</a>.</p>

</div>
</div>
<a id="a05f98034a4ff730c8398fe580d8c89a9" name="a05f98034a4ff730c8398fe580d8c89a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05f98034a4ff730c8398fe580d8c89a9">&#9670;&nbsp;</a></span>store() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void store </td>
          <td>(</td>
          <td class="paramtype">bool *&#160;</td>
          <td class="paramname"><em>mem</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Store N boolean values to the consecutive addresses starting at <code>mem</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mem</td><td>A pointer to an array of booleans. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="simdmaskarray_8h_source.html#l00491">491</a> of file <a class="el" href="simdmaskarray_8h_source.html">simdmaskarray.h</a>.</p>

</div>
</div>
<a id="aab98867a1176923e0f9faf8005fea54f" name="aab98867a1176923e0f9faf8005fea54f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab98867a1176923e0f9faf8005fea54f">&#9670;&nbsp;</a></span>store() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void store </td>
          <td>(</td>
          <td class="paramtype">bool *&#160;</td>
          <td class="paramname"><em>mem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Flags&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Store N boolean values to the consecutive addresses starting at <code>mem</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mem</td><td>A pointer to an array of booleans. </td></tr>
    <tr><td class="paramname">f</td><td>A combination of flags to modify specific behavior of the load. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="simdmaskarray_8h_source.html#l00503">503</a> of file <a class="el" href="simdmaskarray_8h_source.html">simdmaskarray.h</a>.</p>

</div>
</div>
<a id="adc2d88f2435a2c3c341730f6a1621f2c" name="adc2d88f2435a2c3c341730f6a1621f2c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc2d88f2435a2c3c341730f6a1621f2c">&#9670;&nbsp;</a></span>operator==()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classVc_1_1SimdMaskArray.html">SimdMaskArray</a>&lt; T, N, V, Wt &gt; &amp;&#160;</td>
          <td class="paramname"><em>mask</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns whether the two masks are equal in all components. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mask</td><td>The other mask to compare against. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A scalar boolean value that says whether all components of the two masks are equal.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>If you expected a behavior similar to the compare operator of <a class="el" href="classVc_1_1Vector.html" title="The main vector class for expressing data parallelism.">Vc::Vector</a>, consider that the bitwise operators already implement such functionality. There is little use, typically, in having <code>a == b</code> return the same as <code>a ^ b</code>. In general, it is more useful to query <code>all_of(a ^ b)</code> which is the same as this equality operator. </dd></dl>

<p class="definition">Definition at line <a class="el" href="simdmaskarray_8h_source.html#l00511">511</a> of file <a class="el" href="simdmaskarray_8h_source.html">simdmaskarray.h</a>.</p>

</div>
</div>
<a id="a55081def08b7e959e40961186be9b63c" name="a55081def08b7e959e40961186be9b63c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a55081def08b7e959e40961186be9b63c">&#9670;&nbsp;</a></span>operator!=()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classVc_1_1SimdMaskArray.html#aab3980bf7455cc37b683bee2bf88e93f">operator!</a>= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classVc_1_1SimdMaskArray.html">SimdMaskArray</a>&lt; T, N, V, Wt &gt; &amp;&#160;</td>
          <td class="paramname"><em>mask</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns whether the two masks are different in at least one component. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mask</td><td>The other mask to compare against. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A scalar boolean value that says whether at least one component of the two masks is different.</dd></dl>
<dl class="section note"><dt>Note</dt><dd><code>(a == b) == !(a != b)</code> holds </dd></dl>
<dl class="section see"><dt>See also</dt><dd>Mask::operator==(const Mask &amp;) </dd></dl>

<p class="definition">Definition at line <a class="el" href="simdmaskarray_8h_source.html#l00516">516</a> of file <a class="el" href="simdmaskarray_8h_source.html">simdmaskarray.h</a>.</p>

</div>
</div>
<a id="a8cc7782de081ce702a9be163b4cb8f84" name="a8cc7782de081ce702a9be163b4cb8f84"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8cc7782de081ce702a9be163b4cb8f84">&#9670;&nbsp;</a></span>toInt()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int toInt </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert the boolean components of the mask into bits of an integer. </p>
<dl class="section return"><dt>Returns</dt><dd>An <code>int</code> where each bit corresponds to the boolean value in the mask.</dd></dl>
<p>For example, the mask <code>[true, false, false, true]</code> results in a <code>9</code> (in binary: <code>1001</code>). </p>

<p class="definition">Definition at line <a class="el" href="simdmaskarray_8h_source.html#l00591">591</a> of file <a class="el" href="simdmaskarray_8h_source.html">simdmaskarray.h</a>.</p>

</div>
</div>
<a id="ad9490a1dfe9ab280829a12edea2a858b" name="ad9490a1dfe9ab280829a12edea2a858b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad9490a1dfe9ab280829a12edea2a858b">&#9670;&nbsp;</a></span>operator[]() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">reference operator[] </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a smart reference to the boolean element at index <code>index</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The element index to be accessed.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A temporary smart reference object which acts as much as an lvalue reference as possible. </dd></dl>

<p class="definition">Definition at line <a class="el" href="simdmaskarray_8h_source.html#l00627">627</a> of file <a class="el" href="simdmaskarray_8h_source.html">simdmaskarray.h</a>.</p>

</div>
</div>
<a id="a7941a8bfa6845a198bda7038a39e18f0" name="a7941a8bfa6845a198bda7038a39e18f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7941a8bfa6845a198bda7038a39e18f0">&#9670;&nbsp;</a></span>operator[]() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVc_1_1SimdMaskArray.html#a1361e8e9cce10205928db7c5d49c76dc">value_type</a> operator[] </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a copy of the boolean element at index <code>index</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The element index to be accessed.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A temporary boolean object with the value of the element at index <code>index</code>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="simdmaskarray_8h_source.html#l00639">639</a> of file <a class="el" href="simdmaskarray_8h_source.html">simdmaskarray.h</a>.</p>

</div>
</div>
<a id="ad24cd7d179a4f1b5d9435ad8e913dc34" name="ad24cd7d179a4f1b5d9435ad8e913dc34"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad24cd7d179a4f1b5d9435ad8e913dc34">&#9670;&nbsp;</a></span>firstOne()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int firstOne </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the index of the first one in the mask. </p>
<dl class="section return"><dt>Returns</dt><dd>the index of the first component that is <code>true</code>.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>The return value is undefined if the mask is empty.</dd></dl>
<p>Thus, unless <code>none_of(mask)</code>, <code>mask[mask.firstOne()] == true</code> holds and <code>mask[i] == false</code> for all <code>i &lt; mask.firstOne()</code>. </p>

<p class="definition">Definition at line <a class="el" href="simdmaskarray_8h_source.html#l00648">648</a> of file <a class="el" href="simdmaskarray_8h_source.html">simdmaskarray.h</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>/home/axel/build/Vc/src/Vc/<a class="el" href="fwddecl_8h_source.html">fwddecl.h</a></li>
<li>/home/axel/build/Vc/src/Vc/common/<a class="el" href="simdmaskarray_8h_source.html">simdmaskarray.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespaceVc.html">Vc</a></li><li class="navelem"><a class="el" href="classVc_1_1SimdMaskArray.html">SimdMaskArray</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.4 </li>
  </ul>
</div>
</body>
</html>
