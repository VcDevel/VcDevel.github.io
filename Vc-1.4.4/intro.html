<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.4"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Vc: Introduction</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
  $(document).ready(function() { init_search(); });
/* @license-end */
</script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="logo_small.png"/></td>
  <td id="projectalign">
   <div id="projectname">Vc<span id="projectnumber">&#160;1.4.4</span>
   </div>
   <div id="projectbrief">SIMD Vector Classes for C++</div>
  </td>
    <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.svg"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.4 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('intro.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">Introduction </div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p >Recent generations of CPUs, and GPUs in particular, require data-parallel codes for full efficiency. Data parallelism requires that the same sequence of operations is applied to different input data. CPUs and GPUs can thus reduce the necessary hardware for instruction decoding and scheduling in favor of more arithmetic and logic units, which execute the same instructions synchronously. On CPU architectures this is implemented via SIMD registers and instructions. A single SIMD register can store N values and a single SIMD instruction can execute N operations on those values. On GPU architectures N threads run in perfect sync, fed by a single instruction decoder/scheduler. Each thread has local memory and a given index to calculate the offsets in memory for loads and stores.</p>
<p >Current C++ compilers can do automatic transformation of scalar codes to SIMD instructions (auto-vectorization). However, the compiler must reconstruct an intrinsic property of the algorithm that was lost when the developer wrote a purely scalar implementation in C++. Consequently, C++ compilers cannot vectorize any given code to its most efficient data-parallel variant. Especially larger data-parallel loops, spanning over multiple functions or even translation units, will often not be transformed into efficient SIMD code.</p>
<p >The Vc library provides the missing link. Its types enable explicitly stating data-parallel operations on multiple values. The parallelism is therefore added via the type system. Competing approaches state the parallelism via new control structures and consequently new semantics inside the body of these control structures.</p>
<p >If you are new to vectorization please read this following part and make sure you understand it:</p><ul>
<li>The term <em>vector</em> used for data-parallel programming is not about the vectors you studied in math classes.</li>
<li>Do not confuse <em>vector</em> with containers that also go by the same name. SIMD vectors actually do implement some aspect of a container, but they are closer to a fixed-sized <code>std::array</code> than to a dynamically resizable <code>std::vector</code>.</li>
<li>The <em>vector</em> type in Vc is defined by the target hardware as a group of values with a fixed number of entries ( \(\mathcal{W}_\mathtt{T}\)). Typically one <a class="el" href="classVc_1_1Vector.html" title="The main vector class for expressing data parallelism.">Vc::Vector</a> object then fits into a SIMD register on the target system. Such a SIMD register consequently stores \(\mathcal{W}_\mathtt{T}\) scalar values; in contrast to a general purpose register, which stores only one scalar value. This value \(\mathcal{W}_\mathtt{T}\) is thus an unchangeable property of the hardware and not a variable in the Vc API. You can access the \(\mathcal{W}_\mathtt{T}\) value via the static <a class="el" href="classVc_1_1Vector.html#a1b5d7e2e663d7997796fd9f72b8af75a" title="Returns the number of scalar components ( ) in a vector of this type.">Vc::Vector::size()</a> function. Since this function is a constant expression you can also use it for template arguments.</li>
<li>Note that some hardware may use different vector register widths for different data types. For example, AVX has instructions for 256-bit floating point registers, but only 128-bit integer instructions, which is why the integral <a class="el" href="classVc_1_1Vector.html" title="The main vector class for expressing data parallelism.">Vc::Vector</a> types use the SSE implementation for AVX target systems.</li>
</ul>
<dl class="section user"><dt>Example 1:</dt><dd></dd></dl>
<p>You can modify a function to use vector types and thus implement a horizontal vectorization. The original scalar function could look like this (If you are confused about the adjective "scalar" in this context, note that the function mathematically does a vector to vector transformation. However, the computer computes it with <em>scalar</em> instructions, i.e. one value per operand.): </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> normalize(<span class="keywordtype">float</span> &amp;x, <span class="keywordtype">float</span> &amp;y, <span class="keywordtype">float</span> &amp;z)</div>
<div class="line">{</div>
<div class="line">  <span class="keyword">const</span> <span class="keywordtype">float</span> d = <a class="code hl_function" href="group__SimdArray.html#ga7a6c5f5edc8022f95100272604ca7674">std::sqrt</a>(x * x + y * y + z * z);</div>
<div class="line">  x /= d;</div>
<div class="line">  y /= d;</div>
<div class="line">  z /= d;</div>
<div class="line">}</div>
<div class="ttc" id="agroup__SimdArray_html_ga7a6c5f5edc8022f95100272604ca7674"><div class="ttname"><a href="group__SimdArray.html#ga7a6c5f5edc8022f95100272604ca7674">Vc::sqrt</a></div><div class="ttdeci">fixed_size_simd&lt; T, N &gt; sqrt(const SimdArray&lt; T, N, V, M &gt; &amp;x)</div><div class="ttdoc">Applies the std:: sqrt function component-wise and concurrently.</div><div class="ttdef"><b>Definition:</b> <a href="simdarray_8h_source.html#l01852">simdarray.h:1852</a></div></div>
</div><!-- fragment --><p> To vectorize the <code>normalize</code> function with Vc, the types must be substituted by their Vc counterparts and math functions must use the Vc implementation (which is, per default, also imported into <code>std</code> namespace): </p><div class="fragment"><div class="line"><span class="keyword">using </span><a class="code hl_class" href="classVc_1_1Vector.html">Vc::float_v</a>;</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> normalize(<a class="code hl_typedef" href="group__Vectors.html#ga5cf7c5a0dadbbbbcb9b69c5e42ee0528">float_v</a> &amp;x, <a class="code hl_typedef" href="group__Vectors.html#ga5cf7c5a0dadbbbbcb9b69c5e42ee0528">float_v</a> &amp;y, <a class="code hl_typedef" href="group__Vectors.html#ga5cf7c5a0dadbbbbcb9b69c5e42ee0528">float_v</a> &amp;z)</div>
<div class="line">{</div>
<div class="line">  <span class="keyword">const</span> <a class="code hl_typedef" href="group__Vectors.html#ga5cf7c5a0dadbbbbcb9b69c5e42ee0528">float_v</a> d = <a class="code hl_function" href="group__SimdArray.html#ga7a6c5f5edc8022f95100272604ca7674">Vc::sqrt</a>(x * x + y * y + z * z);</div>
<div class="line">  x /= d;</div>
<div class="line">  y /= d;</div>
<div class="line">  z /= d;</div>
<div class="line">}</div>
<div class="ttc" id="aclassVc_1_1Vector_html"><div class="ttname"><a href="classVc_1_1Vector.html">Vc::Vector</a></div><div class="ttdoc">The main vector class for expressing data parallelism.</div><div class="ttdef"><b>Definition:</b> <a href="common_2vector_8h_source.html#l00125">vector.h:126</a></div></div>
<div class="ttc" id="agroup__Vectors_html_ga5cf7c5a0dadbbbbcb9b69c5e42ee0528"><div class="ttname"><a href="group__Vectors.html#ga5cf7c5a0dadbbbbcb9b69c5e42ee0528">Vc::float_v</a></div><div class="ttdeci">Vector&lt; float &gt; float_v</div><div class="ttdoc">vector of single precision</div><div class="ttdef"><b>Definition:</b> <a href="vector_8h_source.html#l00054">vector.h:54</a></div></div>
</div><!-- fragment --><p> The latter function is able to normalize four 3D vectors when compiled for SSE in the same time the former function normalizes one 3D vector.</p>
<p >For completeness, note that you can optimize the division in the normalize function further: </p><div class="fragment"><div class="line"><span class="keyword">const</span> <a class="code hl_typedef" href="group__Vectors.html#ga5cf7c5a0dadbbbbcb9b69c5e42ee0528">float_v</a> d_inv = <a class="code hl_variable" href="group__Utilities.html#ga7dc0e380f66c4c791b7bf95df154b3c6">float_v::One</a>() / <a class="code hl_function" href="group__SimdArray.html#ga7a6c5f5edc8022f95100272604ca7674">Vc::sqrt</a>(x * x + y * y + z * z);</div>
<div class="line"><span class="keyword">const</span> <a class="code hl_typedef" href="group__Vectors.html#ga5cf7c5a0dadbbbbcb9b69c5e42ee0528">float_v</a> d_inv = <a class="code hl_function" href="group__SimdArray.html#gaea57cafc480c6afed73429b1c0f7d8f9">Vc::rsqrt</a>(x * x + y * y + z * z); <span class="comment">// less accurate, but faster</span></div>
<div class="ttc" id="agroup__SimdArray_html_gaea57cafc480c6afed73429b1c0f7d8f9"><div class="ttname"><a href="group__SimdArray.html#gaea57cafc480c6afed73429b1c0f7d8f9">Vc::rsqrt</a></div><div class="ttdeci">fixed_size_simd&lt; T, N &gt; rsqrt(const SimdArray&lt; T, N, V, M &gt; &amp;x)</div><div class="ttdoc">Applies the std:: rsqrt function component-wise and concurrently.</div><div class="ttdef"><b>Definition:</b> <a href="simdarray_8h_source.html#l01844">simdarray.h:1844</a></div></div>
<div class="ttc" id="agroup__Utilities_html_ga7dc0e380f66c4c791b7bf95df154b3c6"><div class="ttname"><a href="group__Utilities.html#ga7dc0e380f66c4c791b7bf95df154b3c6">Vc::One</a></div><div class="ttdeci">constexpr VectorSpecialInitializerOne One</div><div class="ttdoc">The special object Vc::One can be used to construct Vector and Mask objects initialized to one/true.</div><div class="ttdef"><b>Definition:</b> <a href="types_8h_source.html#l00086">types.h:86</a></div></div>
</div><!-- fragment --><p> Then you can multiply <code>x</code>, <code>y</code>, and <code>z</code> with <code>d_inv</code>, which is considerably faster than three divisions.</p>
<p >As you can probably see, the new challenge with Vc is the use of good data-structures which support horizontal vectorization. Depending on your problem at hand this may become the main focus of design (it does not have to be, though).</p>
<h1><a class="anchor" id="intro_alignment"></a>
Alignment</h1>
<h2><a class="anchor" id="intro_alignment_background"></a>
What is Alignment</h2>
<p >If you do not know what alignment is, and why it is important, read on, otherwise skip to <a class="el" href="intro.html#intro_alignment_tools">Tools</a>. Normally the alignment of data is an implementation detail left to the compiler. Until C++11, the language did not even have any (official) means to query or modify alignment.</p>
<p >Most data types require more than one Byte for storage. Thus, even most atomic data types span several locations in memory. E.g. if you have a pointer to <code>float</code>, the address stored in this pointer just determines the first of four Bytes of the <code>float</code>. Naively, one could think that any address (which belongs to the process) can be used to store such a float. While this is true for some architectures, some architectures may terminate the process when a misaligned pointer is dereferenced. The natural alignment for atomic data types typically is the same as their size. Thus the address of a <code>float</code> object should always be a multiple of 4 Bytes.</p>
<p >Alignment becomes more important for SIMD data types.</p><ol type="1">
<li>There are different instructions to load/store aligned and unaligned vectors. The unaligned load/stores recently were greatly improved in x86 CPUs. Still, the rule of thumb says that aligned loads/stores are faster.</li>
<li>Access to an unaligned vector with an instruction that expects an aligned vector crashes the application. Once you write vectorized code you might want to make it a habit to check crashes for unaligned addresses.</li>
<li>Memory allocation on the heap will return addresses aligned to some system specific alignment rule. E.g. Linux 32bit aligns on 8 Bytes, while Linux 64bit aligns on 16 Bytes. Both alignments are not strict enough for AVX vectors. Worse, if you develop on Linux 64bit with SSE you won't notice any problems until you switch to a 32bit build or AVX.</li>
<li>Placement on the stack is determined at compile time and requires the compiler to know the alignment restrictions of the type.</li>
<li>The size of a cache line is just two or four times larger than the SIMD types (if not equal). Thus, if you load several vectors consecutively from memory every fourth, second, or even every load will have to be read from two different cache lines. This is called a cache line split. They lead to degraded performance, which becomes very noticeable for memory intensive code.</li>
</ol>
<h2><a class="anchor" id="intro_alignment_tools"></a>
Tools</h2>
<p >Vc provides several classes and functions to get alignment right. </p><ul>
<li><a class="el" href="group__Vectors.html#gab31cdcfd0e89e57edf426bfbf3ca843b" title="Specifies the most conservative memory alignment necessary for Vector&lt;T&gt; objects with default VectorA...">Vc::VectorAlignment</a> is a compile time constant that equals the largest alignment restriction (in Bytes) for the selected target architecture. </li>
<li><a class="el" href="structVc_1_1AlignedBase.html" title="Helper class to ensure a given alignment.">Vc::AlignedBase</a>, <a class="el" href="group__Utilities.html#gae0b1347db1c228fa9eed28bb263b7ce1" title="Helper type to ensure suitable alignment for any Vc::Vector&lt;T&gt; type (using the default VectorAbi).">Vc::VectorAlignedBase</a>, and <a class="el" href="group__Utilities.html#ga199bb5c0b1cdad984233700da70c7f72" title="Helper class to ensure suitable alignment for arrays of scalar objects for any Vc::Vector&lt;T&gt; type (us...">Vc::MemoryAlignedBase</a> implement the alignment restrictions needed for aligned vector loads and stores. They set the alignment attribute and reimplement the <code>new</code> and <code>delete</code> operators, returning correctly aligned pointers to the heap. </li>
<li><a class="el" href="group__Utilities.html#ga0edd4f5b27c3713aaa0f9950b60e6026" title="Allocates memory on the Heap with alignment and padding suitable for vectorized access.">Vc::malloc</a> and <a class="el" href="group__Utilities.html#ga02df2f4144ab266d7f9e65fa3aef070b" title="Frees memory that was allocated with Vc::malloc.">Vc::free</a> are meant as replacements for <code>malloc</code> and <code>free</code>. They can be used to allocate any type of memory with an abstract alignment restriction: <a class="el" href="group__Utilities.html#gaebce8b3227fdcca97fba94556a1b2461">Vc::MallocAlignment</a>. Note, that (like <code>malloc</code>) the memory is only allocated and not initialized. If you allocate memory for a type that has a constructor, use the placement new syntax to initialize the memory. </li>
<li><a class="el" href="classVc_1_1Allocator.html" title="An allocator that uses global new and supports over-aligned types, as per [C++11 20....">Vc::Allocator</a> is an STL compatible allocator class that behaves as specified in the C++ specification, implementing the optional support for over-aligned types. Therefore, memory addresses returned from this allocator will always be aligned to at least the constraints attached to the type <code>T</code>. STL containers will already default to <a class="el" href="classVc_1_1Allocator.html" title="An allocator that uses global new and supports over-aligned types, as per [C++11 20....">Vc::Allocator</a> for Vc::Vector&lt;T&gt;. For all other composite types you want to use, you can take the <a class="el" href="group__Utilities.html#ga83122cc58f88458ed9d7277e2634368c">Vc_DECLARE_ALLOCATOR</a> convenience macro to set is as default. </li>
<li>Vc::Memory, Vc::Memory&lt;V, Size, 0u&gt;, Vc::Memory&lt;V, 0u, 0u&gt; The three different variants of the memory class can be used like a more convenient C-array. It supports two-dimensional statically sized arrays and one-dimensional statically and dynamically sized arrays. The memory can be accessed easily via aligned vectors, but also via unaligned vectors or gathers/scatters. </li>
</ul>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.4 </li>
  </ul>
</div>
</body>
</html>
