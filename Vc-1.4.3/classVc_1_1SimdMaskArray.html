<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Vc: SimdMaskArray&lt; T, N, V, Wt &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(function() { init_search(); });
/* @license-end */
</script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo_small.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Vc
   &#160;<span id="projectnumber">1.4.3</span>
   </div>
   <div id="projectbrief">SIMD Vector Classes for C++</div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.svg"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('classVc_1_1SimdMaskArray.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="classVc_1_1SimdMaskArray-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">SimdMaskArray&lt; T, N, V, Wt &gt; Class Template Reference<div class="ingroups"><a class="el" href="group__SimdArray.html">SIMD Array</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename T, size_t N, typename V, size_t Wt&gt;<br />
class Vc::SimdMaskArray&lt; T, N, V, Wt &gt;</h3>

<p>Data-parallel mask type with user-defined number of boolean elements. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The value type of the corresponding <a class="el" href="classVc_1_1SimdArray.html" title="Data-parallel arithmetic type with user-defined number of elements.">SimdArray</a>. Depending on the target platform this type determines a different bit representation to work most efficient with <a class="el" href="classVc_1_1SimdArray.html" title="Data-parallel arithmetic type with user-defined number of elements.">SimdArray</a> types instantiated for <code>T</code>.</td></tr>
    <tr><td class="paramname">N</td><td>The number of boolean elements to store and process concurrently. You can choose an arbitrary number, though not every number is a good idea. Generally, a power of two value or the sum of two power of two values might work efficiently, though this depends a lot on the target system.</td></tr>
    <tr><td class="paramname">V</td><td>Don't change the default value unless you really know what you are doing. This type is set to the underlying native <a class="el" href="classVc_1_1Vector.html" title="The main vector class for expressing data parallelism.">Vc::Vector</a> type used in the implementation of the type. Having it as part of the type name guards against some cases of ODR violations (i.e. linking incompatible translation units / libraries).</td></tr>
    <tr><td class="paramname">Wt</td><td>Don't ever change the default value. This parameter is an unfortunate implementation detail shining through. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="simdmaskarray_8h_source.html#l00323">323</a> of file <a class="el" href="simdmaskarray_8h_source.html">simdmaskarray.h</a>.</p>
</div>
<p><code>#include &lt;<a class="el" href="simdmaskarray_8h_source.html">Vc/SimdArray</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a1361e8e9cce10205928db7c5d49c76dc"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVc_1_1SimdMaskArray.html#a1361e8e9cce10205928db7c5d49c76dc">value_type</a> = typename <a class="el" href="classVc_1_1Mask.html#af8d79876e53834654a2c408d3a3bca6a">storage_type0::EntryType</a></td></tr>
<tr class="memdesc:a1361e8e9cce10205928db7c5d49c76dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <code>EntryType</code> of masks is always <code>bool</code>, independent of <code>T</code>.  <a href="classVc_1_1SimdMaskArray.html#a1361e8e9cce10205928db7c5d49c76dc">More...</a><br /></td></tr>
<tr class="separator:a1361e8e9cce10205928db7c5d49c76dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a197e6d613393324683e71a9bbc4b1d36"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVc_1_1SimdMaskArray.html#a197e6d613393324683e71a9bbc4b1d36">MaskType</a> = <a class="el" href="classVc_1_1SimdMaskArray.html">mask_type</a></td></tr>
<tr class="memdesc:a197e6d613393324683e71a9bbc4b1d36"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a zero-initialized vector object.  <a href="classVc_1_1SimdMaskArray.html#a197e6d613393324683e71a9bbc4b1d36">More...</a><br /></td></tr>
<tr class="separator:a197e6d613393324683e71a9bbc4b1d36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54e5ed8e98d92aac3ac40647db1c17bf"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVc_1_1SimdMaskArray.html#a54e5ed8e98d92aac3ac40647db1c17bf">VectorEntryType</a> = vectorentry_type</td></tr>
<tr class="memdesc:a54e5ed8e98d92aac3ac40647db1c17bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <code>VectorEntryType</code>, in contrast to <code>EntryType</code>, reveals information about the SIMD implementation.  <a href="classVc_1_1SimdMaskArray.html#a54e5ed8e98d92aac3ac40647db1c17bf">More...</a><br /></td></tr>
<tr class="separator:a54e5ed8e98d92aac3ac40647db1c17bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae01209df02a8750be9c3aca4728e056d"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVc_1_1SimdMaskArray.html#ae01209df02a8750be9c3aca4728e056d">EntryType</a> = <a class="el" href="classVc_1_1SimdMaskArray.html#a1361e8e9cce10205928db7c5d49c76dc">value_type</a></td></tr>
<tr class="memdesc:ae01209df02a8750be9c3aca4728e056d"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <code>EntryType</code> of masks is always <code>bool</code>, independent of <code>T</code>.  <a href="classVc_1_1SimdMaskArray.html#ae01209df02a8750be9c3aca4728e056d">More...</a><br /></td></tr>
<tr class="separator:ae01209df02a8750be9c3aca4728e056d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a841b1b3a66f9457f3161e9b171af29f4"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVc_1_1SimdMaskArray.html#a841b1b3a66f9457f3161e9b171af29f4">EntryReference</a> = Vc::Detail::ElementReference&lt; <a class="el" href="classVc_1_1SimdMaskArray.html">SimdMaskArray</a> &gt;</td></tr>
<tr class="memdesc:a841b1b3a66f9457f3161e9b171af29f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">The reference wrapper type used for accessing individual mask components.  <a href="classVc_1_1SimdMaskArray.html#a841b1b3a66f9457f3161e9b171af29f4">More...</a><br /></td></tr>
<tr class="separator:a841b1b3a66f9457f3161e9b171af29f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41e2d619436c709fe4d989bd519c75c4"><td class="memItemLeft" align="right" valign="top"><a id="a41e2d619436c709fe4d989bd519c75c4"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVc_1_1SimdMaskArray.html#a41e2d619436c709fe4d989bd519c75c4">Vector</a> = <a class="el" href="classVc_1_1Vector.html">fixed_size_simd</a>&lt; T, N &gt;</td></tr>
<tr class="memdesc:a41e2d619436c709fe4d989bd519c75c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">An alias for the corresponding <a class="el" href="classVc_1_1SimdArray.html" title="Data-parallel arithmetic type with user-defined number of elements.">SimdArray</a> type. <br /></td></tr>
<tr class="separator:a41e2d619436c709fe4d989bd519c75c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ac3726a8e8149927942c1a1dcee279597"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVc_1_1SimdMaskArray.html#ac3726a8e8149927942c1a1dcee279597">SimdMaskArray</a> ()=default</td></tr>
<tr class="memdesc:ac3726a8e8149927942c1a1dcee279597"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a zero-initialized vector object.  <a href="classVc_1_1SimdMaskArray.html#ac3726a8e8149927942c1a1dcee279597">More...</a><br /></td></tr>
<tr class="separator:ac3726a8e8149927942c1a1dcee279597"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7cb2c66758351e600a2b63a6447bdd17"><td class="memItemLeft" align="right" valign="top"><a id="a7cb2c66758351e600a2b63a6447bdd17"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVc_1_1SimdMaskArray.html#a7cb2c66758351e600a2b63a6447bdd17">SimdMaskArray</a> (VectorSpecialInitializerOne one)</td></tr>
<tr class="memdesc:a7cb2c66758351e600a2b63a6447bdd17"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize the new mask object to one (<code>true</code>). <br /></td></tr>
<tr class="separator:a7cb2c66758351e600a2b63a6447bdd17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af532e5e145f96b14e411852b7491cbdb"><td class="memItemLeft" align="right" valign="top"><a id="af532e5e145f96b14e411852b7491cbdb"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVc_1_1SimdMaskArray.html#af532e5e145f96b14e411852b7491cbdb">SimdMaskArray</a> (VectorSpecialInitializerZero zero)</td></tr>
<tr class="memdesc:af532e5e145f96b14e411852b7491cbdb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Zero-initialize the new mask object (<code>false</code>). <br /></td></tr>
<tr class="separator:af532e5e145f96b14e411852b7491cbdb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0558e628a2e7e2511b250e724a5a82bc"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVc_1_1SimdMaskArray.html#a0558e628a2e7e2511b250e724a5a82bc">SimdMaskArray</a> (bool b)</td></tr>
<tr class="memdesc:a0558e628a2e7e2511b250e724a5a82bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Broadcast constructor.  <a href="classVc_1_1SimdMaskArray.html#a0558e628a2e7e2511b250e724a5a82bc">More...</a><br /></td></tr>
<tr class="separator:a0558e628a2e7e2511b250e724a5a82bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc2d88f2435a2c3c341730f6a1621f2c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVc_1_1SimdMaskArray.html#adc2d88f2435a2c3c341730f6a1621f2c">operator==</a> (const <a class="el" href="classVc_1_1SimdMaskArray.html">SimdMaskArray</a> &amp;mask) const</td></tr>
<tr class="memdesc:adc2d88f2435a2c3c341730f6a1621f2c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether the two masks are equal in all components.  <a href="classVc_1_1SimdMaskArray.html#adc2d88f2435a2c3c341730f6a1621f2c">More...</a><br /></td></tr>
<tr class="separator:adc2d88f2435a2c3c341730f6a1621f2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55081def08b7e959e40961186be9b63c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVc_1_1SimdMaskArray.html#a55081def08b7e959e40961186be9b63c">operator!=</a> (const <a class="el" href="classVc_1_1SimdMaskArray.html">SimdMaskArray</a> &amp;mask) const</td></tr>
<tr class="memdesc:a55081def08b7e959e40961186be9b63c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether the two masks are different in at least one component.  <a href="classVc_1_1SimdMaskArray.html#a55081def08b7e959e40961186be9b63c">More...</a><br /></td></tr>
<tr class="separator:a55081def08b7e959e40961186be9b63c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a579d31e98278f1a6d397a85209670da9"><td class="memItemLeft" align="right" valign="top"><a id="a579d31e98278f1a6d397a85209670da9"></a>
<a class="el" href="classVc_1_1Mask.html">fixed_size_simd_mask</a>&lt; T, N &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVc_1_1SimdMaskArray.html#a579d31e98278f1a6d397a85209670da9">operator!</a> () const</td></tr>
<tr class="memdesc:a579d31e98278f1a6d397a85209670da9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a mask with inverted components. <br /></td></tr>
<tr class="separator:a579d31e98278f1a6d397a85209670da9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5719b457b48f6647abb477ac6acf505a"><td class="memItemLeft" align="right" valign="top"><a id="a5719b457b48f6647abb477ac6acf505a"></a>
<a class="el" href="classVc_1_1SimdMaskArray.html">SimdMaskArray</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVc_1_1SimdMaskArray.html#a5719b457b48f6647abb477ac6acf505a">operator&amp;=</a> (const <a class="el" href="classVc_1_1SimdMaskArray.html">SimdMaskArray</a> &amp;rhs)</td></tr>
<tr class="memdesc:a5719b457b48f6647abb477ac6acf505a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Modifies the mask using an <code>AND</code> operation with <code>mask</code>. <br /></td></tr>
<tr class="separator:a5719b457b48f6647abb477ac6acf505a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7085bb8610e51146c27d4f5b55d322e"><td class="memItemLeft" align="right" valign="top"><a id="aa7085bb8610e51146c27d4f5b55d322e"></a>
<a class="el" href="classVc_1_1SimdMaskArray.html">SimdMaskArray</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVc_1_1SimdMaskArray.html#aa7085bb8610e51146c27d4f5b55d322e">operator|=</a> (const <a class="el" href="classVc_1_1SimdMaskArray.html">SimdMaskArray</a> &amp;rhs)</td></tr>
<tr class="memdesc:aa7085bb8610e51146c27d4f5b55d322e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Modifies the mask using an <code>OR</code> operation with <code>mask</code>. <br /></td></tr>
<tr class="separator:aa7085bb8610e51146c27d4f5b55d322e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06bbf0d05099cf4b363e283b35359df2"><td class="memItemLeft" align="right" valign="top"><a id="a06bbf0d05099cf4b363e283b35359df2"></a>
<a class="el" href="classVc_1_1SimdMaskArray.html">SimdMaskArray</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVc_1_1SimdMaskArray.html#a06bbf0d05099cf4b363e283b35359df2">operator^=</a> (const <a class="el" href="classVc_1_1SimdMaskArray.html">SimdMaskArray</a> &amp;rhs)</td></tr>
<tr class="memdesc:a06bbf0d05099cf4b363e283b35359df2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Modifies the mask using an <code>XOR</code> operation with <code>mask</code>. <br /></td></tr>
<tr class="separator:a06bbf0d05099cf4b363e283b35359df2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca1e2f4003f0f9c317294488349b00d9"><td class="memItemLeft" align="right" valign="top"><a id="aca1e2f4003f0f9c317294488349b00d9"></a>
<a class="el" href="classVc_1_1Mask.html">fixed_size_simd_mask</a>&lt; T, N &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVc_1_1SimdMaskArray.html#aca1e2f4003f0f9c317294488349b00d9">operator&amp;</a> (const <a class="el" href="classVc_1_1SimdMaskArray.html">SimdMaskArray</a> &amp;rhs) const</td></tr>
<tr class="memdesc:aca1e2f4003f0f9c317294488349b00d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the component-wise application of a binary <code>AND</code> to <code>mask</code>. <br /></td></tr>
<tr class="separator:aca1e2f4003f0f9c317294488349b00d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7aa3e27139500a9238145432e3bc3e27"><td class="memItemLeft" align="right" valign="top"><a id="a7aa3e27139500a9238145432e3bc3e27"></a>
<a class="el" href="classVc_1_1Mask.html">fixed_size_simd_mask</a>&lt; T, N &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVc_1_1SimdMaskArray.html#a7aa3e27139500a9238145432e3bc3e27">operator|</a> (const <a class="el" href="classVc_1_1SimdMaskArray.html">SimdMaskArray</a> &amp;rhs) const</td></tr>
<tr class="memdesc:a7aa3e27139500a9238145432e3bc3e27"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the component-wise application of a binary <code>OR</code> to <code>mask</code>. <br /></td></tr>
<tr class="separator:a7aa3e27139500a9238145432e3bc3e27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ad40050a5dc73eb039f982574aa698e"><td class="memItemLeft" align="right" valign="top"><a id="a8ad40050a5dc73eb039f982574aa698e"></a>
<a class="el" href="classVc_1_1Mask.html">fixed_size_simd_mask</a>&lt; T, N &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVc_1_1SimdMaskArray.html#a8ad40050a5dc73eb039f982574aa698e">operator^</a> (const <a class="el" href="classVc_1_1SimdMaskArray.html">SimdMaskArray</a> &amp;rhs) const</td></tr>
<tr class="memdesc:a8ad40050a5dc73eb039f982574aa698e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the component-wise application of a binary <code>XOR</code> to <code>mask</code>. <br /></td></tr>
<tr class="separator:a8ad40050a5dc73eb039f982574aa698e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32bc21258488b14c4c6ec33c59aa3ead"><td class="memItemLeft" align="right" valign="top"><a id="a32bc21258488b14c4c6ec33c59aa3ead"></a>
<a class="el" href="classVc_1_1Mask.html">fixed_size_simd_mask</a>&lt; T, N &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVc_1_1SimdMaskArray.html#a32bc21258488b14c4c6ec33c59aa3ead">operator&amp;&amp;</a> (const <a class="el" href="classVc_1_1SimdMaskArray.html">SimdMaskArray</a> &amp;rhs) const</td></tr>
<tr class="memdesc:a32bc21258488b14c4c6ec33c59aa3ead"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the component-wise application of a logical <code>AND</code> to <code>mask</code>. <br /></td></tr>
<tr class="separator:a32bc21258488b14c4c6ec33c59aa3ead"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b400ee37cf21fed0db4ef06c90ee45c"><td class="memItemLeft" align="right" valign="top"><a id="a4b400ee37cf21fed0db4ef06c90ee45c"></a>
<a class="el" href="classVc_1_1Mask.html">fixed_size_simd_mask</a>&lt; T, N &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVc_1_1SimdMaskArray.html#a4b400ee37cf21fed0db4ef06c90ee45c">operator||</a> (const <a class="el" href="classVc_1_1SimdMaskArray.html">SimdMaskArray</a> &amp;rhs) const</td></tr>
<tr class="memdesc:a4b400ee37cf21fed0db4ef06c90ee45c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the component-wise application of a logical <code>OR</code> to <code>mask</code>. <br /></td></tr>
<tr class="separator:a4b400ee37cf21fed0db4ef06c90ee45c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad753310e7ebeac80873cea6766ad1e60"><td class="memItemLeft" align="right" valign="top"><a id="ad753310e7ebeac80873cea6766ad1e60"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVc_1_1SimdMaskArray.html#ad753310e7ebeac80873cea6766ad1e60">isFull</a> () const</td></tr>
<tr class="memdesc:ad753310e7ebeac80873cea6766ad1e60"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a logical <code>AND</code> of all components. <br /></td></tr>
<tr class="separator:ad753310e7ebeac80873cea6766ad1e60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47e00abdf43d5bda786659b43b26ffb3"><td class="memItemLeft" align="right" valign="top"><a id="a47e00abdf43d5bda786659b43b26ffb3"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVc_1_1SimdMaskArray.html#a47e00abdf43d5bda786659b43b26ffb3">isNotEmpty</a> () const</td></tr>
<tr class="memdesc:a47e00abdf43d5bda786659b43b26ffb3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a logical <code>OR</code> of all components. <br /></td></tr>
<tr class="separator:a47e00abdf43d5bda786659b43b26ffb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf82f9b2937375c7b1cf3dccb3df3312"><td class="memItemLeft" align="right" valign="top"><a id="acf82f9b2937375c7b1cf3dccb3df3312"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVc_1_1SimdMaskArray.html#acf82f9b2937375c7b1cf3dccb3df3312">isEmpty</a> () const</td></tr>
<tr class="memdesc:acf82f9b2937375c7b1cf3dccb3df3312"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>true</code> if components are <code>false</code>, <code>false</code> otherwise. <br /></td></tr>
<tr class="separator:acf82f9b2937375c7b1cf3dccb3df3312"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31f380fde21e6686d149a1009f378a24"><td class="memItemLeft" align="right" valign="top"><a id="a31f380fde21e6686d149a1009f378a24"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVc_1_1SimdMaskArray.html#a31f380fde21e6686d149a1009f378a24">isMix</a> () const</td></tr>
<tr class="memdesc:a31f380fde21e6686d149a1009f378a24"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>!isFull() &amp;&amp; !isEmpty()</code>. <br /></td></tr>
<tr class="separator:a31f380fde21e6686d149a1009f378a24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8cc7782de081ce702a9be163b4cb8f84"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVc_1_1SimdMaskArray.html#a8cc7782de081ce702a9be163b4cb8f84">toInt</a> () const</td></tr>
<tr class="memdesc:a8cc7782de081ce702a9be163b4cb8f84"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert the boolean components of the mask into bits of an integer.  <a href="classVc_1_1SimdMaskArray.html#a8cc7782de081ce702a9be163b4cb8f84">More...</a><br /></td></tr>
<tr class="separator:a8cc7782de081ce702a9be163b4cb8f84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9490a1dfe9ab280829a12edea2a858b"><td class="memItemLeft" align="right" valign="top">reference&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVc_1_1SimdMaskArray.html#ad9490a1dfe9ab280829a12edea2a858b">operator[]</a> (size_t index) noexcept</td></tr>
<tr class="memdesc:ad9490a1dfe9ab280829a12edea2a858b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a smart reference to the boolean element at index <code>index</code>.  <a href="classVc_1_1SimdMaskArray.html#ad9490a1dfe9ab280829a12edea2a858b">More...</a><br /></td></tr>
<tr class="separator:ad9490a1dfe9ab280829a12edea2a858b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7941a8bfa6845a198bda7038a39e18f0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classVc_1_1SimdMaskArray.html#a1361e8e9cce10205928db7c5d49c76dc">value_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVc_1_1SimdMaskArray.html#a7941a8bfa6845a198bda7038a39e18f0">operator[]</a> (size_t index) const noexcept</td></tr>
<tr class="memdesc:a7941a8bfa6845a198bda7038a39e18f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a copy of the boolean element at index <code>index</code>.  <a href="classVc_1_1SimdMaskArray.html#a7941a8bfa6845a198bda7038a39e18f0">More...</a><br /></td></tr>
<tr class="separator:a7941a8bfa6845a198bda7038a39e18f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e2c15c517007b91c37b2aa68bf2484a"><td class="memItemLeft" align="right" valign="top"><a id="a0e2c15c517007b91c37b2aa68bf2484a"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVc_1_1SimdMaskArray.html#a0e2c15c517007b91c37b2aa68bf2484a">count</a> () const</td></tr>
<tr class="memdesc:a0e2c15c517007b91c37b2aa68bf2484a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns how many components of the mask are <code>true</code>. <br /></td></tr>
<tr class="separator:a0e2c15c517007b91c37b2aa68bf2484a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad24cd7d179a4f1b5d9435ad8e913dc34"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVc_1_1SimdMaskArray.html#ad24cd7d179a4f1b5d9435ad8e913dc34">firstOne</a> () const</td></tr>
<tr class="memdesc:ad24cd7d179a4f1b5d9435ad8e913dc34"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the index of the first one in the mask.  <a href="classVc_1_1SimdMaskArray.html#ad24cd7d179a4f1b5d9435ad8e913dc34">More...</a><br /></td></tr>
<tr class="separator:ad24cd7d179a4f1b5d9435ad8e913dc34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46197d15abc7bb0439e2c374282badbf"><td class="memItemLeft" align="right" valign="top"><a id="a46197d15abc7bb0439e2c374282badbf"></a>
<a class="el" href="classVc_1_1Mask.html">fixed_size_simd_mask</a>&lt; T, N &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVc_1_1SimdMaskArray.html#a46197d15abc7bb0439e2c374282badbf">shifted</a> (int amount) const</td></tr>
<tr class="memdesc:a46197d15abc7bb0439e2c374282badbf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a mask with components shifted by <code>amount</code> places. <br /></td></tr>
<tr class="separator:a46197d15abc7bb0439e2c374282badbf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">new/delete overloads for correct alignment</div></td></tr>
<tr class="memitem:a205ed048fdf5259c2e8e0cb60ee8f719"><td class="memItemLeft" align="right" valign="top"><a id="a205ed048fdf5259c2e8e0cb60ee8f719"></a>
void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVc_1_1SimdMaskArray.html#a205ed048fdf5259c2e8e0cb60ee8f719">operator new</a> (size_t <a class="el" href="classVc_1_1SimdMaskArray.html#a5e99fb015bfbc024a4b785135b34dee7">size</a>)</td></tr>
<tr class="memdesc:a205ed048fdf5259c2e8e0cb60ee8f719"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocates correctly aligned memory. <br /></td></tr>
<tr class="separator:a205ed048fdf5259c2e8e0cb60ee8f719"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a32ddebc54410cf59dec423c0b0791b"><td class="memItemLeft" align="right" valign="top"><a id="a0a32ddebc54410cf59dec423c0b0791b"></a>
void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVc_1_1SimdMaskArray.html#a0a32ddebc54410cf59dec423c0b0791b">operator new</a> (size_t, void *p)</td></tr>
<tr class="memdesc:a0a32ddebc54410cf59dec423c0b0791b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>p</code>. <br /></td></tr>
<tr class="separator:a0a32ddebc54410cf59dec423c0b0791b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63ce4f64887b9307317aee5baae6b18f"><td class="memItemLeft" align="right" valign="top"><a id="a63ce4f64887b9307317aee5baae6b18f"></a>
void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVc_1_1SimdMaskArray.html#a63ce4f64887b9307317aee5baae6b18f">operator new[]</a> (size_t <a class="el" href="classVc_1_1SimdMaskArray.html#a5e99fb015bfbc024a4b785135b34dee7">size</a>)</td></tr>
<tr class="memdesc:a63ce4f64887b9307317aee5baae6b18f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocates correctly aligned memory. <br /></td></tr>
<tr class="separator:a63ce4f64887b9307317aee5baae6b18f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f5a0f061d65c77264411a2914503659"><td class="memItemLeft" align="right" valign="top"><a id="a7f5a0f061d65c77264411a2914503659"></a>
void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVc_1_1SimdMaskArray.html#a7f5a0f061d65c77264411a2914503659">operator new[]</a> (size_t, void *p)</td></tr>
<tr class="memdesc:a7f5a0f061d65c77264411a2914503659"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>p</code>. <br /></td></tr>
<tr class="separator:a7f5a0f061d65c77264411a2914503659"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22999735d5b1e1cb645614d22f108611"><td class="memItemLeft" align="right" valign="top"><a id="a22999735d5b1e1cb645614d22f108611"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVc_1_1SimdMaskArray.html#a22999735d5b1e1cb645614d22f108611">operator delete</a> (void *ptr, size_t)</td></tr>
<tr class="memdesc:a22999735d5b1e1cb645614d22f108611"><td class="mdescLeft">&#160;</td><td class="mdescRight">Frees aligned memory. <br /></td></tr>
<tr class="separator:a22999735d5b1e1cb645614d22f108611"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41d83e8020f1d841b254be6ebeda92d2"><td class="memItemLeft" align="right" valign="top"><a id="a41d83e8020f1d841b254be6ebeda92d2"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVc_1_1SimdMaskArray.html#a41d83e8020f1d841b254be6ebeda92d2">operator delete</a> (void *, void *)</td></tr>
<tr class="memdesc:a41d83e8020f1d841b254be6ebeda92d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Does nothing. <br /></td></tr>
<tr class="separator:a41d83e8020f1d841b254be6ebeda92d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abefd12c9bd2fa9cd4a27cdabf64b03f8"><td class="memItemLeft" align="right" valign="top"><a id="abefd12c9bd2fa9cd4a27cdabf64b03f8"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVc_1_1SimdMaskArray.html#abefd12c9bd2fa9cd4a27cdabf64b03f8">operator delete[]</a> (void *ptr, size_t)</td></tr>
<tr class="memdesc:abefd12c9bd2fa9cd4a27cdabf64b03f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Frees aligned memory. <br /></td></tr>
<tr class="separator:abefd12c9bd2fa9cd4a27cdabf64b03f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afea8decef8f286c8d73c89a1a81d4555"><td class="memItemLeft" align="right" valign="top"><a id="afea8decef8f286c8d73c89a1a81d4555"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVc_1_1SimdMaskArray.html#afea8decef8f286c8d73c89a1a81d4555">operator delete[]</a> (void *, void *)</td></tr>
<tr class="memdesc:afea8decef8f286c8d73c89a1a81d4555"><td class="mdescLeft">&#160;</td><td class="mdescRight">Does nothing. <br /></td></tr>
<tr class="separator:afea8decef8f286c8d73c89a1a81d4555"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Loads &amp; Stores</div></td></tr>
<tr class="memitem:a5b4dace4dd70d203e3304e8dbe6c1d2e"><td class="memTemplParams" colspan="2">template&lt;typename Flags  = DefaultLoadTag&gt; </td></tr>
<tr class="memitem:a5b4dace4dd70d203e3304e8dbe6c1d2e"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classVc_1_1SimdMaskArray.html#a5b4dace4dd70d203e3304e8dbe6c1d2e">SimdMaskArray</a> (const bool *mem, Flags f=Flags())</td></tr>
<tr class="memdesc:a5b4dace4dd70d203e3304e8dbe6c1d2e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load N boolean values from the consecutive addresses starting at <code>mem</code>.  <a href="classVc_1_1SimdMaskArray.html#a5b4dace4dd70d203e3304e8dbe6c1d2e">More...</a><br /></td></tr>
<tr class="separator:a5b4dace4dd70d203e3304e8dbe6c1d2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a587a49eeafeaca6d87eddd82401a9770"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVc_1_1SimdMaskArray.html#a587a49eeafeaca6d87eddd82401a9770">load</a> (const bool *mem)</td></tr>
<tr class="memdesc:a587a49eeafeaca6d87eddd82401a9770"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load N boolean values from the consecutive addresses starting at <code>mem</code>.  <a href="classVc_1_1SimdMaskArray.html#a587a49eeafeaca6d87eddd82401a9770">More...</a><br /></td></tr>
<tr class="separator:a587a49eeafeaca6d87eddd82401a9770"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abaa2275c0ae29230ea9131bd69a0b180"><td class="memTemplParams" colspan="2">template&lt;typename Flags &gt; </td></tr>
<tr class="memitem:abaa2275c0ae29230ea9131bd69a0b180"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classVc_1_1SimdMaskArray.html#abaa2275c0ae29230ea9131bd69a0b180">load</a> (const bool *mem, Flags f)</td></tr>
<tr class="memdesc:abaa2275c0ae29230ea9131bd69a0b180"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load N boolean values from the consecutive addresses starting at <code>mem</code>.  <a href="classVc_1_1SimdMaskArray.html#abaa2275c0ae29230ea9131bd69a0b180">More...</a><br /></td></tr>
<tr class="separator:abaa2275c0ae29230ea9131bd69a0b180"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05f98034a4ff730c8398fe580d8c89a9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVc_1_1SimdMaskArray.html#a05f98034a4ff730c8398fe580d8c89a9">store</a> (bool *mem) const</td></tr>
<tr class="memdesc:a05f98034a4ff730c8398fe580d8c89a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Store N boolean values to the consecutive addresses starting at <code>mem</code>.  <a href="classVc_1_1SimdMaskArray.html#a05f98034a4ff730c8398fe580d8c89a9">More...</a><br /></td></tr>
<tr class="separator:a05f98034a4ff730c8398fe580d8c89a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab98867a1176923e0f9faf8005fea54f"><td class="memTemplParams" colspan="2">template&lt;typename Flags &gt; </td></tr>
<tr class="memitem:aab98867a1176923e0f9faf8005fea54f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classVc_1_1SimdMaskArray.html#aab98867a1176923e0f9faf8005fea54f">store</a> (bool *mem, Flags f) const</td></tr>
<tr class="memdesc:aab98867a1176923e0f9faf8005fea54f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Store N boolean values to the consecutive addresses starting at <code>mem</code>.  <a href="classVc_1_1SimdMaskArray.html#aab98867a1176923e0f9faf8005fea54f">More...</a><br /></td></tr>
<tr class="separator:aab98867a1176923e0f9faf8005fea54f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a5e99fb015bfbc024a4b785135b34dee7"><td class="memItemLeft" align="right" valign="top">static constexpr std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVc_1_1SimdMaskArray.html#a5e99fb015bfbc024a4b785135b34dee7">size</a> ()</td></tr>
<tr class="memdesc:a5e99fb015bfbc024a4b785135b34dee7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of boolean components ( \(\mathcal{W}_\mathtt{T}\)) in a mask of this type.  <a href="classVc_1_1SimdMaskArray.html#a5e99fb015bfbc024a4b785135b34dee7">More...</a><br /></td></tr>
<tr class="separator:a5e99fb015bfbc024a4b785135b34dee7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4908169c1b29d26245803f67ef9e2e6"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classVc_1_1Mask.html">fixed_size_simd_mask</a>&lt; T, N &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVc_1_1SimdMaskArray.html#ad4908169c1b29d26245803f67ef9e2e6">Zero</a> ()</td></tr>
<tr class="memdesc:ad4908169c1b29d26245803f67ef9e2e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new mask object initialized to zero/<code>false</code>.  <a href="classVc_1_1SimdMaskArray.html#ad4908169c1b29d26245803f67ef9e2e6">More...</a><br /></td></tr>
<tr class="separator:ad4908169c1b29d26245803f67ef9e2e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75a6fa335d6e6f745a751b205b53b7ba"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classVc_1_1Mask.html">fixed_size_simd_mask</a>&lt; T, N &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVc_1_1SimdMaskArray.html#a75a6fa335d6e6f745a751b205b53b7ba">One</a> ()</td></tr>
<tr class="memdesc:a75a6fa335d6e6f745a751b205b53b7ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a mask object initialized to one/<code>true</code>.  <a href="classVc_1_1SimdMaskArray.html#a75a6fa335d6e6f745a751b205b53b7ba">More...</a><br /></td></tr>
<tr class="separator:a75a6fa335d6e6f745a751b205b53b7ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0734a4732b5f6a88a3baaeb39cbda08"><td class="memTemplParams" colspan="2"><a id="aa0734a4732b5f6a88a3baaeb39cbda08"></a>
template&lt;typename G &gt; </td></tr>
<tr class="memitem:aa0734a4732b5f6a88a3baaeb39cbda08"><td class="memTemplItemLeft" align="right" valign="top">static <a class="el" href="classVc_1_1Mask.html">fixed_size_simd_mask</a>&lt; T, N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classVc_1_1SimdMaskArray.html#aa0734a4732b5f6a88a3baaeb39cbda08">generate</a> (const G &amp;gen)</td></tr>
<tr class="memdesc:aa0734a4732b5f6a88a3baaeb39cbda08"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate a mask object from booleans returned from the function <code>gen</code>. <br /></td></tr>
<tr class="separator:aa0734a4732b5f6a88a3baaeb39cbda08"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:gad550c4cd366024e9b37c4a7c7c9b96ff"><td class="memItemLeft" align="right" valign="top">static constexpr std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__SimdArray.html#gad550c4cd366024e9b37c4a7c7c9b96ff">Size</a> = <a class="el" href="classVc_1_1SimdMaskArray.html#a5e99fb015bfbc024a4b785135b34dee7">size</a>()</td></tr>
<tr class="memdesc:gad550c4cd366024e9b37c4a7c7c9b96ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of boolean components ( \(\mathcal{W}_\mathtt{T}\)) in a mask of this type.  <a href="group__SimdArray.html#gad550c4cd366024e9b37c4a7c7c9b96ff">More...</a><br /></td></tr>
<tr class="separator:gad550c4cd366024e9b37c4a7c7c9b96ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaac286912729d28478c8c9a1ac97a92ac"><td class="memItemLeft" align="right" valign="top">static constexpr std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__SimdArray.html#gaac286912729d28478c8c9a1ac97a92ac">MemoryAlignment</a></td></tr>
<tr class="memdesc:gaac286912729d28478c8c9a1ac97a92ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specifies the alignment requirement for aligned load and store calls for objects of this mask type.  <a href="group__SimdArray.html#gaac286912729d28478c8c9a1ac97a92ac">More...</a><br /></td></tr>
<tr class="separator:gaac286912729d28478c8c9a1ac97a92ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a1361e8e9cce10205928db7c5d49c76dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1361e8e9cce10205928db7c5d49c76dc">&#9670;&nbsp;</a></span>value_type</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classVc_1_1SimdMaskArray.html#a1361e8e9cce10205928db7c5d49c76dc">value_type</a> =  typename <a class="el" href="classVc_1_1Mask.html#af8d79876e53834654a2c408d3a3bca6a">storage_type0::EntryType</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The <code>EntryType</code> of masks is always <code>bool</code>, independent of <code>T</code>. </p>

<p class="definition">Definition at line <a class="el" href="simdmaskarray_8h_source.html#l00358">358</a> of file <a class="el" href="simdmaskarray_8h_source.html">simdmaskarray.h</a>.</p>

</div>
</div>
<a id="a197e6d613393324683e71a9bbc4b1d36"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a197e6d613393324683e71a9bbc4b1d36">&#9670;&nbsp;</a></span>MaskType</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classVc_1_1SimdMaskArray.html#a197e6d613393324683e71a9bbc4b1d36">MaskType</a> =  <a class="el" href="classVc_1_1SimdMaskArray.html">mask_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct a zero-initialized vector object. </p>
<p>This constructor follows the behavior of the underlying <code>bool</code> type in that the expression <code>bool()</code> zero-initializes the object (to <code>false</code>). On the other hand the variable <code>x</code> in <code>bool x;</code> is uninitialized. Since, for class types, both expressions call the default constructor <code><a class="el" href="classVc_1_1Mask.html" title="The main SIMD mask class.">Mask</a>&lt;T&gt; x</code> must zero-initialize <code>x</code> as well. </p>

<p class="definition">Definition at line <a class="el" href="simdmaskarray_8h_source.html#l00360">360</a> of file <a class="el" href="simdmaskarray_8h_source.html">simdmaskarray.h</a>.</p>

</div>
</div>
<a id="a54e5ed8e98d92aac3ac40647db1c17bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a54e5ed8e98d92aac3ac40647db1c17bf">&#9670;&nbsp;</a></span>VectorEntryType</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classVc_1_1SimdMaskArray.html#a54e5ed8e98d92aac3ac40647db1c17bf">VectorEntryType</a> =  vectorentry_type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The <code>VectorEntryType</code>, in contrast to <code>EntryType</code>, reveals information about the SIMD implementation. </p>
<p>This type is useful for the <code>sizeof</code> operator in generic functions. </p>

<p class="definition">Definition at line <a class="el" href="simdmaskarray_8h_source.html#l00362">362</a> of file <a class="el" href="simdmaskarray_8h_source.html">simdmaskarray.h</a>.</p>

</div>
</div>
<a id="ae01209df02a8750be9c3aca4728e056d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae01209df02a8750be9c3aca4728e056d">&#9670;&nbsp;</a></span>EntryType</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classVc_1_1SimdMaskArray.html#ae01209df02a8750be9c3aca4728e056d">EntryType</a> =  <a class="el" href="classVc_1_1SimdMaskArray.html#a1361e8e9cce10205928db7c5d49c76dc">value_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The <code>EntryType</code> of masks is always <code>bool</code>, independent of <code>T</code>. </p>

<p class="definition">Definition at line <a class="el" href="simdmaskarray_8h_source.html#l00364">364</a> of file <a class="el" href="simdmaskarray_8h_source.html">simdmaskarray.h</a>.</p>

</div>
</div>
<a id="a841b1b3a66f9457f3161e9b171af29f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a841b1b3a66f9457f3161e9b171af29f4">&#9670;&nbsp;</a></span>EntryReference</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classVc_1_1SimdMaskArray.html#a841b1b3a66f9457f3161e9b171af29f4">EntryReference</a> =  Vc::Detail::ElementReference&lt;<a class="el" href="classVc_1_1SimdMaskArray.html">SimdMaskArray</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The reference wrapper type used for accessing individual mask components. </p>

<p class="definition">Definition at line <a class="el" href="simdmaskarray_8h_source.html#l00366">366</a> of file <a class="el" href="simdmaskarray_8h_source.html">simdmaskarray.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="ac3726a8e8149927942c1a1dcee279597"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac3726a8e8149927942c1a1dcee279597">&#9670;&nbsp;</a></span>SimdMaskArray() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVc_1_1SimdMaskArray.html">SimdMaskArray</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct a zero-initialized vector object. </p>
<p>This constructor follows the behavior of the underlying <code>bool</code> type in that the expression <code>bool()</code> zero-initializes the object (to <code>false</code>). On the other hand the variable <code>x</code> in <code>bool x;</code> is uninitialized. Since, for class types, both expressions call the default constructor <code><a class="el" href="classVc_1_1Mask.html" title="The main SIMD mask class.">Mask</a>&lt;T&gt; x</code> must zero-initialize <code>x</code> as well. </p>

</div>
</div>
<a id="a0558e628a2e7e2511b250e724a5a82bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0558e628a2e7e2511b250e724a5a82bc">&#9670;&nbsp;</a></span>SimdMaskArray() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVc_1_1SimdMaskArray.html">SimdMaskArray</a> </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>b</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Broadcast constructor. </p>
<p>Set all components of the new mask object to <code>b</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">b</td><td>Determines the initial state of the mask. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="simdmaskarray_8h_source.html#l00435">435</a> of file <a class="el" href="simdmaskarray_8h_source.html">simdmaskarray.h</a>.</p>

</div>
</div>
<a id="a5b4dace4dd70d203e3304e8dbe6c1d2e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b4dace4dd70d203e3304e8dbe6c1d2e">&#9670;&nbsp;</a></span>SimdMaskArray() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVc_1_1SimdMaskArray.html">SimdMaskArray</a> </td>
          <td>(</td>
          <td class="paramtype">const bool *&#160;</td>
          <td class="paramname"><em>mem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Flags&#160;</td>
          <td class="paramname"><em>f</em> = <code>Flags()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Load N boolean values from the consecutive addresses starting at <code>mem</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mem</td><td>A pointer to an array of booleans. </td></tr>
    <tr><td class="paramname">f</td><td>A combination of flags to modify specific behavior of the load. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="simdmaskarray_8h_source.html#l00458">458</a> of file <a class="el" href="simdmaskarray_8h_source.html">simdmaskarray.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a5e99fb015bfbc024a4b785135b34dee7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e99fb015bfbc024a4b785135b34dee7">&#9670;&nbsp;</a></span>size()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr std::size_t size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of boolean components ( \(\mathcal{W}_\mathtt{T}\)) in a mask of this type. </p>
<p>The size of the mask. I.e. the number of boolean entries in the mask. Do not make any assumptions about the size of masks.</p>
<p>In addition, you can easily use if clauses that compare sizes. The compiler can statically evaluate and fully optimize dead code away (very much like #ifdef, but with syntax checking).</p>
<dl class="section return"><dt>Returns</dt><dd>The number of components (i.e. \(\mathcal{W}_\mathtt{T}\)) objects of this mask type store and manipulate. </dd></dl>

<p class="definition">Definition at line <a class="el" href="simdmaskarray_8h_source.html#l00344">344</a> of file <a class="el" href="simdmaskarray_8h_source.html">simdmaskarray.h</a>.</p>

</div>
</div>
<a id="ad4908169c1b29d26245803f67ef9e2e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4908169c1b29d26245803f67ef9e2e6">&#9670;&nbsp;</a></span>Zero()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classVc_1_1Mask.html">fixed_size_simd_mask</a>&lt;T, N&gt; Zero </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new mask object initialized to zero/<code>false</code>. </p>
<dl class="section return"><dt>Returns</dt><dd>A mask object with zero-initialized components. </dd></dl>

<p class="definition">Definition at line <a class="el" href="simdmaskarray_8h_source.html#l00438">438</a> of file <a class="el" href="simdmaskarray_8h_source.html">simdmaskarray.h</a>.</p>

</div>
</div>
<a id="a75a6fa335d6e6f745a751b205b53b7ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75a6fa335d6e6f745a751b205b53b7ba">&#9670;&nbsp;</a></span>One()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classVc_1_1Mask.html">fixed_size_simd_mask</a>&lt;T, N&gt; One </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a mask object initialized to one/<code>true</code>. </p>
<dl class="section return"><dt>Returns</dt><dd>A mask object with components initialized to <code>true</code>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="simdmaskarray_8h_source.html#l00443">443</a> of file <a class="el" href="simdmaskarray_8h_source.html">simdmaskarray.h</a>.</p>

</div>
</div>
<a id="a587a49eeafeaca6d87eddd82401a9770"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a587a49eeafeaca6d87eddd82401a9770">&#9670;&nbsp;</a></span>load() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void load </td>
          <td>(</td>
          <td class="paramtype">const bool *&#160;</td>
          <td class="paramname"><em>mem</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Load N boolean values from the consecutive addresses starting at <code>mem</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mem</td><td>A pointer to an array of booleans. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="simdmaskarray_8h_source.html#l00468">468</a> of file <a class="el" href="simdmaskarray_8h_source.html">simdmaskarray.h</a>.</p>

</div>
</div>
<a id="abaa2275c0ae29230ea9131bd69a0b180"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abaa2275c0ae29230ea9131bd69a0b180">&#9670;&nbsp;</a></span>load() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void load </td>
          <td>(</td>
          <td class="paramtype">const bool *&#160;</td>
          <td class="paramname"><em>mem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Flags&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Load N boolean values from the consecutive addresses starting at <code>mem</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mem</td><td>A pointer to an array of booleans. </td></tr>
    <tr><td class="paramname">f</td><td>A combination of flags to modify specific behavior of the load. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="simdmaskarray_8h_source.html#l00480">480</a> of file <a class="el" href="simdmaskarray_8h_source.html">simdmaskarray.h</a>.</p>

</div>
</div>
<a id="a05f98034a4ff730c8398fe580d8c89a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05f98034a4ff730c8398fe580d8c89a9">&#9670;&nbsp;</a></span>store() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void store </td>
          <td>(</td>
          <td class="paramtype">bool *&#160;</td>
          <td class="paramname"><em>mem</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Store N boolean values to the consecutive addresses starting at <code>mem</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mem</td><td>A pointer to an array of booleans. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="simdmaskarray_8h_source.html#l00491">491</a> of file <a class="el" href="simdmaskarray_8h_source.html">simdmaskarray.h</a>.</p>

</div>
</div>
<a id="aab98867a1176923e0f9faf8005fea54f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab98867a1176923e0f9faf8005fea54f">&#9670;&nbsp;</a></span>store() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void store </td>
          <td>(</td>
          <td class="paramtype">bool *&#160;</td>
          <td class="paramname"><em>mem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Flags&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Store N boolean values to the consecutive addresses starting at <code>mem</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mem</td><td>A pointer to an array of booleans. </td></tr>
    <tr><td class="paramname">f</td><td>A combination of flags to modify specific behavior of the load. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="simdmaskarray_8h_source.html#l00503">503</a> of file <a class="el" href="simdmaskarray_8h_source.html">simdmaskarray.h</a>.</p>

</div>
</div>
<a id="adc2d88f2435a2c3c341730f6a1621f2c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc2d88f2435a2c3c341730f6a1621f2c">&#9670;&nbsp;</a></span>operator==()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classVc_1_1SimdMaskArray.html">SimdMaskArray</a>&lt; T, N, V, Wt &gt; &amp;&#160;</td>
          <td class="paramname"><em>mask</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns whether the two masks are equal in all components. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mask</td><td>The other mask to compare against. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A scalar boolean value that says whether all components of the two masks are equal.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>If you expected a behavior similar to the compare operator of <a class="el" href="classVc_1_1Vector.html" title="The main vector class for expressing data parallelism.">Vc::Vector</a>, consider that the bitwise operators already implement such functionality. There is little use, typically, in having <code>a == b</code> return the same as <code>a ^ b</code>. In general, it is more useful to query <code>all_of(a ^ b)</code> which is the same as this equality operator. </dd></dl>

<p class="definition">Definition at line <a class="el" href="simdmaskarray_8h_source.html#l00511">511</a> of file <a class="el" href="simdmaskarray_8h_source.html">simdmaskarray.h</a>.</p>

</div>
</div>
<a id="a55081def08b7e959e40961186be9b63c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a55081def08b7e959e40961186be9b63c">&#9670;&nbsp;</a></span>operator!=()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classVc_1_1SimdMaskArray.html#a579d31e98278f1a6d397a85209670da9">operator!</a>= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classVc_1_1SimdMaskArray.html">SimdMaskArray</a>&lt; T, N, V, Wt &gt; &amp;&#160;</td>
          <td class="paramname"><em>mask</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns whether the two masks are different in at least one component. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mask</td><td>The other mask to compare against. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A scalar boolean value that says whether at least one component of the two masks is different.</dd></dl>
<dl class="section note"><dt>Note</dt><dd><code>(a == b) == !(a != b)</code> holds </dd></dl>
<dl class="section see"><dt>See also</dt><dd>Mask::operator==(const Mask &amp;) </dd></dl>

<p class="definition">Definition at line <a class="el" href="simdmaskarray_8h_source.html#l00516">516</a> of file <a class="el" href="simdmaskarray_8h_source.html">simdmaskarray.h</a>.</p>

</div>
</div>
<a id="a8cc7782de081ce702a9be163b4cb8f84"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8cc7782de081ce702a9be163b4cb8f84">&#9670;&nbsp;</a></span>toInt()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int toInt </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert the boolean components of the mask into bits of an integer. </p>
<dl class="section return"><dt>Returns</dt><dd>An <code>int</code> where each bit corresponds to the boolean value in the mask.</dd></dl>
<p>For example, the mask <code>[true, false, false, true]</code> results in a <code>9</code> (in binary: <code>1001</code>). </p>

<p class="definition">Definition at line <a class="el" href="simdmaskarray_8h_source.html#l00591">591</a> of file <a class="el" href="simdmaskarray_8h_source.html">simdmaskarray.h</a>.</p>

</div>
</div>
<a id="ad9490a1dfe9ab280829a12edea2a858b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad9490a1dfe9ab280829a12edea2a858b">&#9670;&nbsp;</a></span>operator[]() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">reference operator[] </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a smart reference to the boolean element at index <code>index</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The element index to be accessed.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A temporary smart reference object which acts as much as an lvalue reference as possible. </dd></dl>

<p class="definition">Definition at line <a class="el" href="simdmaskarray_8h_source.html#l00627">627</a> of file <a class="el" href="simdmaskarray_8h_source.html">simdmaskarray.h</a>.</p>

</div>
</div>
<a id="a7941a8bfa6845a198bda7038a39e18f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7941a8bfa6845a198bda7038a39e18f0">&#9670;&nbsp;</a></span>operator[]() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVc_1_1SimdMaskArray.html#a1361e8e9cce10205928db7c5d49c76dc">value_type</a> operator[] </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a copy of the boolean element at index <code>index</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The element index to be accessed.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A temporary boolean object with the value of the element at index <code>index</code>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="simdmaskarray_8h_source.html#l00639">639</a> of file <a class="el" href="simdmaskarray_8h_source.html">simdmaskarray.h</a>.</p>

</div>
</div>
<a id="ad24cd7d179a4f1b5d9435ad8e913dc34"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad24cd7d179a4f1b5d9435ad8e913dc34">&#9670;&nbsp;</a></span>firstOne()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int firstOne </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the index of the first one in the mask. </p>
<dl class="section return"><dt>Returns</dt><dd>the index of the first component that is <code>true</code>.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>The return value is undefined if the mask is empty.</dd></dl>
<p>Thus, unless <code>none_of(mask)</code>, <code>mask[mask.firstOne()] == true</code> holds and <code>mask[i] == false</code> for all <code>i &lt; mask.firstOne()</code>. </p>

<p class="definition">Definition at line <a class="el" href="simdmaskarray_8h_source.html#l00648">648</a> of file <a class="el" href="simdmaskarray_8h_source.html">simdmaskarray.h</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>/home/axel/build/Vc/src/Vc/<a class="el" href="fwddecl_8h_source.html">fwddecl.h</a></li>
<li>/home/axel/build/Vc/src/Vc/common/<a class="el" href="simdmaskarray_8h_source.html">simdmaskarray.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespaceVc.html">Vc</a></li><li class="navelem"><a class="el" href="classVc_1_1SimdMaskArray.html">SimdMaskArray</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1 </li>
  </ul>
</div>
</body>
</html>
