<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Vc: Mask&lt; T, Abi &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(function() { init_search(); });
/* @license-end */
</script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo_small.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Vc
   &#160;<span id="projectnumber">1.4.3</span>
   </div>
   <div id="projectbrief">SIMD Vector Classes for C++</div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.svg"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('classVc_1_1Mask.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="classVc_1_1Mask-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">Mask&lt; T, Abi &gt; Class Template Reference<div class="ingroups"><a class="el" href="group__Masks.html">Masks</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename T, typename Abi = VectorAbi::Best&lt;T&gt;&gt;<br />
class Vc::Mask&lt; T, Abi &gt;</h3>

<p>The main SIMD mask class. </p>

<p class="definition">Definition at line <a class="el" href="mask_8h_source.html#l00041">41</a> of file <a class="el" href="mask_8h_source.html">mask.h</a>.</p>
</div>
<p><code>#include &lt;<a class="el" href="mask_8h_source.html">Vc/vector.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:abe9aa1f35fa46be781ae9e81d374a72b"><td class="memItemLeft" align="right" valign="top"><a id="abe9aa1f35fa46be781ae9e81d374a72b"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVc_1_1Mask.html#abe9aa1f35fa46be781ae9e81d374a72b">abi</a> = Abi</td></tr>
<tr class="memdesc:abe9aa1f35fa46be781ae9e81d374a72b"><td class="mdescLeft">&#160;</td><td class="mdescRight">The ABI tag type of the current template instantiation. <br /></td></tr>
<tr class="separator:abe9aa1f35fa46be781ae9e81d374a72b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8d79876e53834654a2c408d3a3bca6a"><td class="memItemLeft" align="right" valign="top"><a id="af8d79876e53834654a2c408d3a3bca6a"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVc_1_1Mask.html#af8d79876e53834654a2c408d3a3bca6a">EntryType</a> = bool</td></tr>
<tr class="memdesc:af8d79876e53834654a2c408d3a3bca6a"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <code>EntryType</code> of masks is always <code>bool</code>, independent of <code>T</code>. <br /></td></tr>
<tr class="separator:af8d79876e53834654a2c408d3a3bca6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af58a233cf0cdf62369686dd5798bd589"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVc_1_1Mask.html#af58a233cf0cdf62369686dd5798bd589">value_type</a> = <a class="el" href="classVc_1_1Mask.html#af8d79876e53834654a2c408d3a3bca6a">EntryType</a></td></tr>
<tr class="memdesc:af58a233cf0cdf62369686dd5798bd589"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <code>EntryType</code> of masks is always <code>bool</code>, independent of <code>T</code>.  <a href="classVc_1_1Mask.html#af58a233cf0cdf62369686dd5798bd589">More...</a><br /></td></tr>
<tr class="separator:af58a233cf0cdf62369686dd5798bd589"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70a0859ec263806a8067448f6b70b708"><td class="memItemLeft" align="right" valign="top"><a id="a70a0859ec263806a8067448f6b70b708"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVc_1_1Mask.html#a70a0859ec263806a8067448f6b70b708">EntryReference</a> = typename VectorTraits&lt; T, Abi &gt;::<a class="el" href="classVc_1_1Mask.html#a70a0859ec263806a8067448f6b70b708">EntryReference</a></td></tr>
<tr class="memdesc:a70a0859ec263806a8067448f6b70b708"><td class="mdescLeft">&#160;</td><td class="mdescRight">The reference wrapper type used for accessing individual mask components. <br /></td></tr>
<tr class="separator:a70a0859ec263806a8067448f6b70b708"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83c8f8c1ebbda813702f777d870356ce"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVc_1_1Mask.html#a83c8f8c1ebbda813702f777d870356ce">value_reference</a> = <a class="el" href="classVc_1_1Mask.html#a70a0859ec263806a8067448f6b70b708">EntryReference</a></td></tr>
<tr class="memdesc:a83c8f8c1ebbda813702f777d870356ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">The reference wrapper type used for accessing individual mask components.  <a href="classVc_1_1Mask.html#a83c8f8c1ebbda813702f777d870356ce">More...</a><br /></td></tr>
<tr class="separator:a83c8f8c1ebbda813702f777d870356ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c3595d34ff3a3ad8ddf57a9225cd32b"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVc_1_1Mask.html#a2c3595d34ff3a3ad8ddf57a9225cd32b">VectorEntryType</a> = typename VectorTraits&lt; T, Abi &gt;::<a class="el" href="classVc_1_1Mask.html#a2c3595d34ff3a3ad8ddf57a9225cd32b">VectorEntryType</a></td></tr>
<tr class="memdesc:a2c3595d34ff3a3ad8ddf57a9225cd32b"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <code>VectorEntryType</code>, in contrast to <code>EntryType</code>, reveals information about the SIMD implementation.  <a href="classVc_1_1Mask.html#a2c3595d34ff3a3ad8ddf57a9225cd32b">More...</a><br /></td></tr>
<tr class="separator:a2c3595d34ff3a3ad8ddf57a9225cd32b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a0e2c15c517007b91c37b2aa68bf2484a"><td class="memItemLeft" align="right" valign="top"><a id="a0e2c15c517007b91c37b2aa68bf2484a"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVc_1_1Mask.html#a0e2c15c517007b91c37b2aa68bf2484a">count</a> () const</td></tr>
<tr class="memdesc:a0e2c15c517007b91c37b2aa68bf2484a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns how many components of the mask are <code>true</code>. <br /></td></tr>
<tr class="separator:a0e2c15c517007b91c37b2aa68bf2484a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad24cd7d179a4f1b5d9435ad8e913dc34"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVc_1_1Mask.html#ad24cd7d179a4f1b5d9435ad8e913dc34">firstOne</a> () const</td></tr>
<tr class="memdesc:ad24cd7d179a4f1b5d9435ad8e913dc34"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the index of the first one in the mask.  <a href="classVc_1_1Mask.html#ad24cd7d179a4f1b5d9435ad8e913dc34">More...</a><br /></td></tr>
<tr class="separator:ad24cd7d179a4f1b5d9435ad8e913dc34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8cc7782de081ce702a9be163b4cb8f84"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVc_1_1Mask.html#a8cc7782de081ce702a9be163b4cb8f84">toInt</a> () const</td></tr>
<tr class="memdesc:a8cc7782de081ce702a9be163b4cb8f84"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert the boolean components of the mask into bits of an integer.  <a href="classVc_1_1Mask.html#a8cc7782de081ce702a9be163b4cb8f84">More...</a><br /></td></tr>
<tr class="separator:a8cc7782de081ce702a9be163b4cb8f84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb2a875f83b99899e9d9dddcfcd801fd"><td class="memItemLeft" align="right" valign="top"><a id="adb2a875f83b99899e9d9dddcfcd801fd"></a>
<a class="el" href="classVc_1_1Mask.html">Mask</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVc_1_1Mask.html#adb2a875f83b99899e9d9dddcfcd801fd">shifted</a> (int amount) const</td></tr>
<tr class="memdesc:adb2a875f83b99899e9d9dddcfcd801fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a mask with components shifted by <code>amount</code> places. <br /></td></tr>
<tr class="separator:adb2a875f83b99899e9d9dddcfcd801fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Compile-Time Constant Initialization</div></td></tr>
<tr class="memitem:ae48184c82f0406652dfe7d677d004470"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVc_1_1Mask.html#ae48184c82f0406652dfe7d677d004470">Mask</a> ()=default</td></tr>
<tr class="memdesc:ae48184c82f0406652dfe7d677d004470"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a zero-initialized vector object.  <a href="classVc_1_1Mask.html#ae48184c82f0406652dfe7d677d004470">More...</a><br /></td></tr>
<tr class="separator:ae48184c82f0406652dfe7d677d004470"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05753623c69bb6eb3274d1daa8ede253"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVc_1_1Mask.html#a05753623c69bb6eb3274d1daa8ede253">Mask</a> (VectorSpecialInitializerZero)</td></tr>
<tr class="memdesc:a05753623c69bb6eb3274d1daa8ede253"><td class="mdescLeft">&#160;</td><td class="mdescRight">Zero-initialize the new mask object (<code>false</code>).  <a href="classVc_1_1Mask.html#a05753623c69bb6eb3274d1daa8ede253">More...</a><br /></td></tr>
<tr class="separator:a05753623c69bb6eb3274d1daa8ede253"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2a33ac7668b69f369c4ccec9e3fe7cb"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVc_1_1Mask.html#ab2a33ac7668b69f369c4ccec9e3fe7cb">Mask</a> (VectorSpecialInitializerOne)</td></tr>
<tr class="memdesc:ab2a33ac7668b69f369c4ccec9e3fe7cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize the new mask object to one (<code>true</code>).  <a href="classVc_1_1Mask.html#ab2a33ac7668b69f369c4ccec9e3fe7cb">More...</a><br /></td></tr>
<tr class="separator:ab2a33ac7668b69f369c4ccec9e3fe7cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Conversion/Broadcast Constructors</div></td></tr>
<tr class="memitem:af6744e24b21a80acc6213e2d5eeaeb41"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVc_1_1Mask.html#af6744e24b21a80acc6213e2d5eeaeb41">Mask</a> (bool b)</td></tr>
<tr class="memdesc:af6744e24b21a80acc6213e2d5eeaeb41"><td class="mdescLeft">&#160;</td><td class="mdescRight">Broadcast constructor.  <a href="classVc_1_1Mask.html#af6744e24b21a80acc6213e2d5eeaeb41">More...</a><br /></td></tr>
<tr class="separator:af6744e24b21a80acc6213e2d5eeaeb41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66bcfc021f5a8110db958a6f72a753d4"><td class="memTemplParams" colspan="2">template&lt;typename U &gt; </td></tr>
<tr class="memitem:a66bcfc021f5a8110db958a6f72a753d4"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classVc_1_1Mask.html#a66bcfc021f5a8110db958a6f72a753d4">Mask</a> (U &amp;&amp;otherMask, Common::enable_if_mask_converts_implicitly&lt; <a class="el" href="classVc_1_1Mask.html">Mask</a>, T, U &gt;=nullarg)</td></tr>
<tr class="memdesc:a66bcfc021f5a8110db958a6f72a753d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implicit conversion from a compatible (equal \(\mathcal{W}_\mathtt{T}\) on every platform) mask object.  <a href="classVc_1_1Mask.html#a66bcfc021f5a8110db958a6f72a753d4">More...</a><br /></td></tr>
<tr class="separator:a66bcfc021f5a8110db958a6f72a753d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfd34f3d36cba040796da7139fa47a96"><td class="memTemplParams" colspan="2">template&lt;typename U &gt; </td></tr>
<tr class="memitem:abfd34f3d36cba040796da7139fa47a96"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classVc_1_1Mask.html#abfd34f3d36cba040796da7139fa47a96">Mask</a> (U &amp;&amp;otherMask, Common::enable_if_mask_converts_explicitly&lt; T, U &gt;=nullarg) 1</td></tr>
<tr class="memdesc:abfd34f3d36cba040796da7139fa47a96"><td class="mdescLeft">&#160;</td><td class="mdescRight">Explicit conversion (static_cast) from a mask object that potentially has a different \(\mathcal{W}_\mathtt{T}\).  <a href="classVc_1_1Mask.html#abfd34f3d36cba040796da7139fa47a96">More...</a><br /></td></tr>
<tr class="separator:abfd34f3d36cba040796da7139fa47a96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Loads &amp; Stores</div></td></tr>
<tr class="memitem:a51f078ac5cebddf00ee5e1ed8ae31506"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVc_1_1Mask.html#a51f078ac5cebddf00ee5e1ed8ae31506">Mask</a> (const bool *mem)</td></tr>
<tr class="memdesc:a51f078ac5cebddf00ee5e1ed8ae31506"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load constructor from an array of <code>bool</code>.  <a href="classVc_1_1Mask.html#a51f078ac5cebddf00ee5e1ed8ae31506">More...</a><br /></td></tr>
<tr class="separator:a51f078ac5cebddf00ee5e1ed8ae31506"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7eadaf3069893c0130db3dd6e315845"><td class="memTemplParams" colspan="2">template&lt;typename Flags &gt; </td></tr>
<tr class="memitem:ae7eadaf3069893c0130db3dd6e315845"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classVc_1_1Mask.html#ae7eadaf3069893c0130db3dd6e315845">Mask</a> (const bool *mem, Flags flags)</td></tr>
<tr class="memdesc:ae7eadaf3069893c0130db3dd6e315845"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overload of the above with a load/store flag argument.  <a href="classVc_1_1Mask.html#ae7eadaf3069893c0130db3dd6e315845">More...</a><br /></td></tr>
<tr class="separator:ae7eadaf3069893c0130db3dd6e315845"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a587a49eeafeaca6d87eddd82401a9770"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVc_1_1Mask.html#a587a49eeafeaca6d87eddd82401a9770">load</a> (const bool *mem)</td></tr>
<tr class="memdesc:a587a49eeafeaca6d87eddd82401a9770"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load the components of the mask from an array of <code>bool</code>.  <a href="classVc_1_1Mask.html#a587a49eeafeaca6d87eddd82401a9770">More...</a><br /></td></tr>
<tr class="separator:a587a49eeafeaca6d87eddd82401a9770"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38343ac76b1d41622098b7cfb7b2c581"><td class="memTemplParams" colspan="2">template&lt;typename Flags &gt; </td></tr>
<tr class="memitem:a38343ac76b1d41622098b7cfb7b2c581"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classVc_1_1Mask.html#a38343ac76b1d41622098b7cfb7b2c581">load</a> (const bool *mem, Flags flags)</td></tr>
<tr class="memdesc:a38343ac76b1d41622098b7cfb7b2c581"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overload of the above with a load/store flag argument.  <a href="classVc_1_1Mask.html#a38343ac76b1d41622098b7cfb7b2c581">More...</a><br /></td></tr>
<tr class="separator:a38343ac76b1d41622098b7cfb7b2c581"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05f98034a4ff730c8398fe580d8c89a9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVc_1_1Mask.html#a05f98034a4ff730c8398fe580d8c89a9">store</a> (bool *mem) const</td></tr>
<tr class="memdesc:a05f98034a4ff730c8398fe580d8c89a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Store the values of the mask to an array of <code>bool</code>.  <a href="classVc_1_1Mask.html#a05f98034a4ff730c8398fe580d8c89a9">More...</a><br /></td></tr>
<tr class="separator:a05f98034a4ff730c8398fe580d8c89a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a142cb73c607b8d20f501f1afd4252d37"><td class="memTemplParams" colspan="2">template&lt;typename Flags &gt; </td></tr>
<tr class="memitem:a142cb73c607b8d20f501f1afd4252d37"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classVc_1_1Mask.html#a142cb73c607b8d20f501f1afd4252d37">store</a> (bool *mem, Flags flags) const</td></tr>
<tr class="memdesc:a142cb73c607b8d20f501f1afd4252d37"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overload of the above with a load/store flag argument.  <a href="classVc_1_1Mask.html#a142cb73c607b8d20f501f1afd4252d37">More...</a><br /></td></tr>
<tr class="separator:a142cb73c607b8d20f501f1afd4252d37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Comparison Operators</div></td></tr>
<tr class="memitem:a80cd71dcc209f00af9919ba3fd45c9d2"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVc_1_1Mask.html#a80cd71dcc209f00af9919ba3fd45c9d2">operator==</a> (const <a class="el" href="classVc_1_1Mask.html">Mask</a> &amp;mask) const</td></tr>
<tr class="memdesc:a80cd71dcc209f00af9919ba3fd45c9d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether the two masks are equal in all components.  <a href="classVc_1_1Mask.html#a80cd71dcc209f00af9919ba3fd45c9d2">More...</a><br /></td></tr>
<tr class="separator:a80cd71dcc209f00af9919ba3fd45c9d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb4b8622204614329978ed0686cc1073"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVc_1_1Mask.html#acb4b8622204614329978ed0686cc1073">operator!=</a> (const <a class="el" href="classVc_1_1Mask.html">Mask</a> &amp;mask) const</td></tr>
<tr class="memdesc:acb4b8622204614329978ed0686cc1073"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether the two masks are different in at least one component.  <a href="classVc_1_1Mask.html#acb4b8622204614329978ed0686cc1073">More...</a><br /></td></tr>
<tr class="separator:acb4b8622204614329978ed0686cc1073"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Logical and Binary Operators</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>Component-wise logical/binary operations on mask objects.</p>
<p>The effect of logical and binary <code>AND</code> and <code>OR</code> is equivalent for mask types (as it is for <code>bool</code>). </p>
</div></td></tr>
<tr class="memitem:a2b3c258428f89d6438d1be4b8714f3c3"><td class="memItemLeft" align="right" valign="top"><a id="a2b3c258428f89d6438d1be4b8714f3c3"></a>
<a class="el" href="classVc_1_1Mask.html">Mask</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVc_1_1Mask.html#a2b3c258428f89d6438d1be4b8714f3c3">operator&amp;&amp;</a> (const <a class="el" href="classVc_1_1Mask.html">Mask</a> &amp;mask) const</td></tr>
<tr class="memdesc:a2b3c258428f89d6438d1be4b8714f3c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the component-wise application of a logical <code>AND</code> to <code>mask</code>. <br /></td></tr>
<tr class="separator:a2b3c258428f89d6438d1be4b8714f3c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a898a4a0ac01f7a81dd70bbcd55f92507"><td class="memItemLeft" align="right" valign="top"><a id="a898a4a0ac01f7a81dd70bbcd55f92507"></a>
<a class="el" href="classVc_1_1Mask.html">Mask</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVc_1_1Mask.html#a898a4a0ac01f7a81dd70bbcd55f92507">operator&amp;</a> (const <a class="el" href="classVc_1_1Mask.html">Mask</a> &amp;mask) const</td></tr>
<tr class="memdesc:a898a4a0ac01f7a81dd70bbcd55f92507"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the component-wise application of a binary <code>AND</code> to <code>mask</code>. <br /></td></tr>
<tr class="separator:a898a4a0ac01f7a81dd70bbcd55f92507"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39e859a35e278b291b53ce0620fea87e"><td class="memItemLeft" align="right" valign="top"><a id="a39e859a35e278b291b53ce0620fea87e"></a>
<a class="el" href="classVc_1_1Mask.html">Mask</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVc_1_1Mask.html#a39e859a35e278b291b53ce0620fea87e">operator||</a> (const <a class="el" href="classVc_1_1Mask.html">Mask</a> &amp;mask) const</td></tr>
<tr class="memdesc:a39e859a35e278b291b53ce0620fea87e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the component-wise application of a logical <code>OR</code> to <code>mask</code>. <br /></td></tr>
<tr class="separator:a39e859a35e278b291b53ce0620fea87e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f6f3ae175d88a0abdd1ccfd4ed5a002"><td class="memItemLeft" align="right" valign="top"><a id="a4f6f3ae175d88a0abdd1ccfd4ed5a002"></a>
<a class="el" href="classVc_1_1Mask.html">Mask</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVc_1_1Mask.html#a4f6f3ae175d88a0abdd1ccfd4ed5a002">operator|</a> (const <a class="el" href="classVc_1_1Mask.html">Mask</a> &amp;mask) const</td></tr>
<tr class="memdesc:a4f6f3ae175d88a0abdd1ccfd4ed5a002"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the component-wise application of a binary <code>OR</code> to <code>mask</code>. <br /></td></tr>
<tr class="separator:a4f6f3ae175d88a0abdd1ccfd4ed5a002"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84e966b0f646e1ba6e76f841446ee433"><td class="memItemLeft" align="right" valign="top"><a id="a84e966b0f646e1ba6e76f841446ee433"></a>
<a class="el" href="classVc_1_1Mask.html">Mask</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVc_1_1Mask.html#a84e966b0f646e1ba6e76f841446ee433">operator^</a> (const <a class="el" href="classVc_1_1Mask.html">Mask</a> &amp;mask) const</td></tr>
<tr class="memdesc:a84e966b0f646e1ba6e76f841446ee433"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the component-wise application of a binary <code>XOR</code> to <code>mask</code>. <br /></td></tr>
<tr class="separator:a84e966b0f646e1ba6e76f841446ee433"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08f21c688f3a3e0e5cc321714e3e974a"><td class="memItemLeft" align="right" valign="top"><a id="a08f21c688f3a3e0e5cc321714e3e974a"></a>
<a class="el" href="classVc_1_1Mask.html">Mask</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVc_1_1Mask.html#a08f21c688f3a3e0e5cc321714e3e974a">operator!</a> () const</td></tr>
<tr class="memdesc:a08f21c688f3a3e0e5cc321714e3e974a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a mask with inverted components. <br /></td></tr>
<tr class="separator:a08f21c688f3a3e0e5cc321714e3e974a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0949879b1fbd5ed8689b13e262a8a6ca"><td class="memItemLeft" align="right" valign="top"><a id="a0949879b1fbd5ed8689b13e262a8a6ca"></a>
<a class="el" href="classVc_1_1Mask.html">Mask</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVc_1_1Mask.html#a0949879b1fbd5ed8689b13e262a8a6ca">operator&amp;=</a> (const <a class="el" href="classVc_1_1Mask.html">Mask</a> &amp;mask)</td></tr>
<tr class="memdesc:a0949879b1fbd5ed8689b13e262a8a6ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Modifies the mask using an <code>AND</code> operation with <code>mask</code>. <br /></td></tr>
<tr class="separator:a0949879b1fbd5ed8689b13e262a8a6ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abadcdc8f19bcc2ca6b043246c9ca720a"><td class="memItemLeft" align="right" valign="top"><a id="abadcdc8f19bcc2ca6b043246c9ca720a"></a>
<a class="el" href="classVc_1_1Mask.html">Mask</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVc_1_1Mask.html#abadcdc8f19bcc2ca6b043246c9ca720a">operator|=</a> (const <a class="el" href="classVc_1_1Mask.html">Mask</a> &amp;mask)</td></tr>
<tr class="memdesc:abadcdc8f19bcc2ca6b043246c9ca720a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Modifies the mask using an <code>OR</code> operation with <code>mask</code>. <br /></td></tr>
<tr class="separator:abadcdc8f19bcc2ca6b043246c9ca720a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae332b76ae88262b62e28ec052ce4f5e3"><td class="memItemLeft" align="right" valign="top"><a id="ae332b76ae88262b62e28ec052ce4f5e3"></a>
<a class="el" href="classVc_1_1Mask.html">Mask</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVc_1_1Mask.html#ae332b76ae88262b62e28ec052ce4f5e3">operator^=</a> (const <a class="el" href="classVc_1_1Mask.html">Mask</a> &amp;mask)</td></tr>
<tr class="memdesc:ae332b76ae88262b62e28ec052ce4f5e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Modifies the mask using an <code>XOR</code> operation with <code>mask</code>. <br /></td></tr>
<tr class="separator:ae332b76ae88262b62e28ec052ce4f5e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Reductions</div></td></tr>
<tr><td colspan="2"><div class="groupText"><dl class="section see"><dt>See also</dt><dd><a class="el" href="group__Utilities.html#ga0e357178e07b595d2e7879ca2b2c62e0" title="Returns whether at least one entry in the mask m is true.">any_of</a>, <a class="el" href="group__Utilities.html#gaccfe8b53188a645a5c78e283defb0d23" title="Returns whether all entries in the mask m are true.">all_of</a>, <a class="el" href="group__Utilities.html#gabe433dbbaa1f39731be6d183269cee3d" title="Returns whether all entries in the mask m are false.">none_of</a>, <a class="el" href="group__Utilities.html#ga0d1f3affaf171f27a677d71501feb7ca" title="Returns whether at least one entry in m is true and at least one entry in m is false.">some_of</a> </dd></dl>
</div></td></tr>
<tr class="memitem:ad753310e7ebeac80873cea6766ad1e60"><td class="memItemLeft" align="right" valign="top"><a id="ad753310e7ebeac80873cea6766ad1e60"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVc_1_1Mask.html#ad753310e7ebeac80873cea6766ad1e60">isFull</a> () const</td></tr>
<tr class="memdesc:ad753310e7ebeac80873cea6766ad1e60"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a logical <code>AND</code> of all components. <br /></td></tr>
<tr class="separator:ad753310e7ebeac80873cea6766ad1e60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47e00abdf43d5bda786659b43b26ffb3"><td class="memItemLeft" align="right" valign="top"><a id="a47e00abdf43d5bda786659b43b26ffb3"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVc_1_1Mask.html#a47e00abdf43d5bda786659b43b26ffb3">isNotEmpty</a> () const</td></tr>
<tr class="memdesc:a47e00abdf43d5bda786659b43b26ffb3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a logical <code>OR</code> of all components. <br /></td></tr>
<tr class="separator:a47e00abdf43d5bda786659b43b26ffb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf82f9b2937375c7b1cf3dccb3df3312"><td class="memItemLeft" align="right" valign="top"><a id="acf82f9b2937375c7b1cf3dccb3df3312"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVc_1_1Mask.html#acf82f9b2937375c7b1cf3dccb3df3312">isEmpty</a> () const</td></tr>
<tr class="memdesc:acf82f9b2937375c7b1cf3dccb3df3312"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>true</code> if components are <code>false</code>, <code>false</code> otherwise. <br /></td></tr>
<tr class="separator:acf82f9b2937375c7b1cf3dccb3df3312"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31f380fde21e6686d149a1009f378a24"><td class="memItemLeft" align="right" valign="top"><a id="a31f380fde21e6686d149a1009f378a24"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVc_1_1Mask.html#a31f380fde21e6686d149a1009f378a24">isMix</a> () const</td></tr>
<tr class="memdesc:a31f380fde21e6686d149a1009f378a24"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>!isFull() &amp;&amp; !isEmpty()</code>. <br /></td></tr>
<tr class="separator:a31f380fde21e6686d149a1009f378a24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr><td colspan="2"><div class="groupHeader">Scalar Subscript Operators</div></td></tr>
<tr class="memitem:ae0f6159e65556d0cdcb735447e8a8b42"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classVc_1_1Mask.html#a70a0859ec263806a8067448f6b70b708">EntryReference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVc_1_1Mask.html#ae0f6159e65556d0cdcb735447e8a8b42">operator[]</a> (size_t index)</td></tr>
<tr class="memdesc:ae0f6159e65556d0cdcb735447e8a8b42"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lvalue-reference-like access to mask entries.  <a href="classVc_1_1Mask.html#ae0f6159e65556d0cdcb735447e8a8b42">More...</a><br /></td></tr>
<tr class="separator:ae0f6159e65556d0cdcb735447e8a8b42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f3da9ad86cc3c301b93627f0a767d26"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classVc_1_1Mask.html#af8d79876e53834654a2c408d3a3bca6a">EntryType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVc_1_1Mask.html#a4f3da9ad86cc3c301b93627f0a767d26">operator[]</a> (size_t index) const</td></tr>
<tr class="memdesc:a4f3da9ad86cc3c301b93627f0a767d26"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read-only access to mask entries.  <a href="classVc_1_1Mask.html#a4f3da9ad86cc3c301b93627f0a767d26">More...</a><br /></td></tr>
<tr class="separator:a4f3da9ad86cc3c301b93627f0a767d26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">new/delete overloads for correct alignment</div></td></tr>
<tr class="memitem:a205ed048fdf5259c2e8e0cb60ee8f719"><td class="memItemLeft" align="right" valign="top"><a id="a205ed048fdf5259c2e8e0cb60ee8f719"></a>
void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVc_1_1Mask.html#a205ed048fdf5259c2e8e0cb60ee8f719">operator new</a> (size_t <a class="el" href="classVc_1_1Mask.html#a1b5d7e2e663d7997796fd9f72b8af75a">size</a>)</td></tr>
<tr class="memdesc:a205ed048fdf5259c2e8e0cb60ee8f719"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocates correctly aligned memory. <br /></td></tr>
<tr class="separator:a205ed048fdf5259c2e8e0cb60ee8f719"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a32ddebc54410cf59dec423c0b0791b"><td class="memItemLeft" align="right" valign="top"><a id="a0a32ddebc54410cf59dec423c0b0791b"></a>
void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVc_1_1Mask.html#a0a32ddebc54410cf59dec423c0b0791b">operator new</a> (size_t, void *p)</td></tr>
<tr class="memdesc:a0a32ddebc54410cf59dec423c0b0791b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>p</code>. <br /></td></tr>
<tr class="separator:a0a32ddebc54410cf59dec423c0b0791b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63ce4f64887b9307317aee5baae6b18f"><td class="memItemLeft" align="right" valign="top"><a id="a63ce4f64887b9307317aee5baae6b18f"></a>
void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVc_1_1Mask.html#a63ce4f64887b9307317aee5baae6b18f">operator new[]</a> (size_t <a class="el" href="classVc_1_1Mask.html#a1b5d7e2e663d7997796fd9f72b8af75a">size</a>)</td></tr>
<tr class="memdesc:a63ce4f64887b9307317aee5baae6b18f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocates correctly aligned memory. <br /></td></tr>
<tr class="separator:a63ce4f64887b9307317aee5baae6b18f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f5a0f061d65c77264411a2914503659"><td class="memItemLeft" align="right" valign="top"><a id="a7f5a0f061d65c77264411a2914503659"></a>
void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVc_1_1Mask.html#a7f5a0f061d65c77264411a2914503659">operator new[]</a> (size_t, void *p)</td></tr>
<tr class="memdesc:a7f5a0f061d65c77264411a2914503659"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>p</code>. <br /></td></tr>
<tr class="separator:a7f5a0f061d65c77264411a2914503659"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22999735d5b1e1cb645614d22f108611"><td class="memItemLeft" align="right" valign="top"><a id="a22999735d5b1e1cb645614d22f108611"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVc_1_1Mask.html#a22999735d5b1e1cb645614d22f108611">operator delete</a> (void *ptr, size_t)</td></tr>
<tr class="memdesc:a22999735d5b1e1cb645614d22f108611"><td class="mdescLeft">&#160;</td><td class="mdescRight">Frees aligned memory. <br /></td></tr>
<tr class="separator:a22999735d5b1e1cb645614d22f108611"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41d83e8020f1d841b254be6ebeda92d2"><td class="memItemLeft" align="right" valign="top"><a id="a41d83e8020f1d841b254be6ebeda92d2"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVc_1_1Mask.html#a41d83e8020f1d841b254be6ebeda92d2">operator delete</a> (void *, void *)</td></tr>
<tr class="memdesc:a41d83e8020f1d841b254be6ebeda92d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Does nothing. <br /></td></tr>
<tr class="separator:a41d83e8020f1d841b254be6ebeda92d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abefd12c9bd2fa9cd4a27cdabf64b03f8"><td class="memItemLeft" align="right" valign="top"><a id="abefd12c9bd2fa9cd4a27cdabf64b03f8"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVc_1_1Mask.html#abefd12c9bd2fa9cd4a27cdabf64b03f8">operator delete[]</a> (void *ptr, size_t)</td></tr>
<tr class="memdesc:abefd12c9bd2fa9cd4a27cdabf64b03f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Frees aligned memory. <br /></td></tr>
<tr class="separator:abefd12c9bd2fa9cd4a27cdabf64b03f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afea8decef8f286c8d73c89a1a81d4555"><td class="memItemLeft" align="right" valign="top"><a id="afea8decef8f286c8d73c89a1a81d4555"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVc_1_1Mask.html#afea8decef8f286c8d73c89a1a81d4555">operator delete[]</a> (void *, void *)</td></tr>
<tr class="memdesc:afea8decef8f286c8d73c89a1a81d4555"><td class="mdescLeft">&#160;</td><td class="mdescRight">Does nothing. <br /></td></tr>
<tr class="separator:afea8decef8f286c8d73c89a1a81d4555"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a1b5d7e2e663d7997796fd9f72b8af75a"><td class="memItemLeft" align="right" valign="top">static constexpr size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVc_1_1Mask.html#a1b5d7e2e663d7997796fd9f72b8af75a">size</a> ()</td></tr>
<tr class="memdesc:a1b5d7e2e663d7997796fd9f72b8af75a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of boolean components ( \(\mathcal{W}_\mathtt{T}\)) in a mask of this type.  <a href="classVc_1_1Mask.html#a1b5d7e2e663d7997796fd9f72b8af75a">More...</a><br /></td></tr>
<tr class="separator:a1b5d7e2e663d7997796fd9f72b8af75a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Generators</div></td></tr>
<tr class="memitem:a2be492a48f12ce0897fe60bf8980ebea"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classVc_1_1Mask.html">Mask</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVc_1_1Mask.html#a2be492a48f12ce0897fe60bf8980ebea">Zero</a> ()</td></tr>
<tr class="memdesc:a2be492a48f12ce0897fe60bf8980ebea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new mask object initialized to zero/<code>false</code>.  <a href="classVc_1_1Mask.html#a2be492a48f12ce0897fe60bf8980ebea">More...</a><br /></td></tr>
<tr class="separator:a2be492a48f12ce0897fe60bf8980ebea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9872d89a68448bcfdde4160df3229fb8"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classVc_1_1Mask.html">Mask</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVc_1_1Mask.html#a9872d89a68448bcfdde4160df3229fb8">One</a> ()</td></tr>
<tr class="memdesc:a9872d89a68448bcfdde4160df3229fb8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a mask object initialized to one/<code>true</code>.  <a href="classVc_1_1Mask.html#a9872d89a68448bcfdde4160df3229fb8">More...</a><br /></td></tr>
<tr class="separator:a9872d89a68448bcfdde4160df3229fb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d73e61b7aabfd8cb0070814f8e1897c"><td class="memTemplParams" colspan="2"><a id="a1d73e61b7aabfd8cb0070814f8e1897c"></a>
template&lt;typename G &gt; </td></tr>
<tr class="memitem:a1d73e61b7aabfd8cb0070814f8e1897c"><td class="memTemplItemLeft" align="right" valign="top">static <a class="el" href="classVc_1_1Mask.html">Mask</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classVc_1_1Mask.html#a1d73e61b7aabfd8cb0070814f8e1897c">generate</a> (G &amp;&amp;gen)</td></tr>
<tr class="memdesc:a1d73e61b7aabfd8cb0070814f8e1897c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate a mask object from booleans returned from the function <code>gen</code>. <br /></td></tr>
<tr class="separator:a1d73e61b7aabfd8cb0070814f8e1897c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:a879ad9933a419e4e04c8a59cc19a34fe"><td class="memItemLeft" align="right" valign="top">static constexpr size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVc_1_1Mask.html#a879ad9933a419e4e04c8a59cc19a34fe">Size</a> = VectorTraits&lt;T, Abi&gt;::<a class="el" href="classVc_1_1Mask.html#a1b5d7e2e663d7997796fd9f72b8af75a">size</a>()</td></tr>
<tr class="memdesc:a879ad9933a419e4e04c8a59cc19a34fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of boolean components ( \(\mathcal{W}_\mathtt{T}\)) in a mask of this type.  <a href="classVc_1_1Mask.html#a879ad9933a419e4e04c8a59cc19a34fe">More...</a><br /></td></tr>
<tr class="separator:a879ad9933a419e4e04c8a59cc19a34fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d80568e435be601eb87ade3966eda21"><td class="memItemLeft" align="right" valign="top"><a id="a9d80568e435be601eb87ade3966eda21"></a>
static constexpr size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVc_1_1Mask.html#a9d80568e435be601eb87ade3966eda21">MemoryAlignment</a> = VectorTraits&lt;T, Abi&gt;::maskMemoryAlignment()</td></tr>
<tr class="memdesc:a9d80568e435be601eb87ade3966eda21"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specifies the alignment requirement for aligned load and store calls for objects of this mask type. <br /></td></tr>
<tr class="separator:a9d80568e435be601eb87ade3966eda21"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Member Typedef Documentation</h2>
<a id="af58a233cf0cdf62369686dd5798bd589"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af58a233cf0cdf62369686dd5798bd589">&#9670;&nbsp;</a></span>value_type</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classVc_1_1Mask.html#af58a233cf0cdf62369686dd5798bd589">value_type</a> =  <a class="el" href="classVc_1_1Mask.html#af8d79876e53834654a2c408d3a3bca6a">EntryType</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The <code>EntryType</code> of masks is always <code>bool</code>, independent of <code>T</code>. </p>

<p class="definition">Definition at line <a class="el" href="mask_8h_source.html#l00076">76</a> of file <a class="el" href="mask_8h_source.html">mask.h</a>.</p>

</div>
</div>
<a id="a83c8f8c1ebbda813702f777d870356ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a83c8f8c1ebbda813702f777d870356ce">&#9670;&nbsp;</a></span>value_reference</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classVc_1_1Mask.html#a83c8f8c1ebbda813702f777d870356ce">value_reference</a> =  <a class="el" href="classVc_1_1Mask.html#a70a0859ec263806a8067448f6b70b708">EntryReference</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The reference wrapper type used for accessing individual mask components. </p>

<p class="definition">Definition at line <a class="el" href="mask_8h_source.html#l00081">81</a> of file <a class="el" href="mask_8h_source.html">mask.h</a>.</p>

</div>
</div>
<a id="a2c3595d34ff3a3ad8ddf57a9225cd32b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c3595d34ff3a3ad8ddf57a9225cd32b">&#9670;&nbsp;</a></span>VectorEntryType</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classVc_1_1Mask.html#a2c3595d34ff3a3ad8ddf57a9225cd32b">VectorEntryType</a> =  typename VectorTraits&lt;T, Abi&gt;::<a class="el" href="classVc_1_1Mask.html#a2c3595d34ff3a3ad8ddf57a9225cd32b">VectorEntryType</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The <code>VectorEntryType</code>, in contrast to <code>EntryType</code>, reveals information about the SIMD implementation. </p>
<p>This type is useful for the <code>sizeof</code> operator in generic functions. </p>

<p class="definition">Definition at line <a class="el" href="mask_8h_source.html#l00088">88</a> of file <a class="el" href="mask_8h_source.html">mask.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="ae48184c82f0406652dfe7d677d004470"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae48184c82f0406652dfe7d677d004470">&#9670;&nbsp;</a></span>Mask() <span class="overload">[1/8]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVc_1_1Mask.html">Mask</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct a zero-initialized vector object. </p>
<p>This constructor follows the behavior of the underlying <code>bool</code> type in that the expression <code>bool()</code> zero-initializes the object (to <code>false</code>). On the other hand the variable <code>x</code> in <code>bool x;</code> is uninitialized. Since, for class types, both expressions call the default constructor <code><a class="el" href="classVc_1_1Mask.html" title="The main SIMD mask class.">Mask</a>&lt;T&gt; x</code> must zero-initialize <code>x</code> as well. </p>

</div>
</div>
<a id="a05753623c69bb6eb3274d1daa8ede253"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05753623c69bb6eb3274d1daa8ede253">&#9670;&nbsp;</a></span>Mask() <span class="overload">[2/8]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVc_1_1Mask.html">Mask</a> </td>
          <td>(</td>
          <td class="paramtype">VectorSpecialInitializerZero&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Zero-initialize the new mask object (<code>false</code>). </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__Utilities.html#gad24df8f04b4b68f7e992aeb8b449cdf2" title="The special object Vc::Zero can be used to construct Vector and Mask objects initialized to zero/fals...">Vc::Zero</a>, <a class="el" href="classVc_1_1Mask.html#a2be492a48f12ce0897fe60bf8980ebea" title="Creates a new mask object initialized to zero/false.">Zero()</a> </dd></dl>

</div>
</div>
<a id="ab2a33ac7668b69f369c4ccec9e3fe7cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab2a33ac7668b69f369c4ccec9e3fe7cb">&#9670;&nbsp;</a></span>Mask() <span class="overload">[3/8]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVc_1_1Mask.html">Mask</a> </td>
          <td>(</td>
          <td class="paramtype">VectorSpecialInitializerOne&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initialize the new mask object to one (<code>true</code>). </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__Utilities.html#ga7dc0e380f66c4c791b7bf95df154b3c6" title="The special object Vc::One can be used to construct Vector and Mask objects initialized to one/true.">Vc::One</a>, <a class="el" href="classVc_1_1Mask.html#a9872d89a68448bcfdde4160df3229fb8" title="Creates a mask object initialized to one/true.">One()</a> </dd></dl>

</div>
</div>
<a id="af6744e24b21a80acc6213e2d5eeaeb41"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af6744e24b21a80acc6213e2d5eeaeb41">&#9670;&nbsp;</a></span>Mask() <span class="overload">[4/8]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVc_1_1Mask.html">Mask</a> </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>b</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Broadcast constructor. </p>
<p>Set all components of the new mask object to <code>b</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">b</td><td>Determines the initial state of the mask. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a66bcfc021f5a8110db958a6f72a753d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a66bcfc021f5a8110db958a6f72a753d4">&#9670;&nbsp;</a></span>Mask() <span class="overload">[5/8]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVc_1_1Mask.html">Mask</a> </td>
          <td>(</td>
          <td class="paramtype">U &amp;&amp;&#160;</td>
          <td class="paramname"><em>otherMask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Common::enable_if_mask_converts_implicitly&lt; <a class="el" href="classVc_1_1Mask.html">Mask</a>&lt; T, Abi &gt;, T, U &gt;&#160;</td>
          <td class="paramname"> = <code>nullarg</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implicit conversion from a compatible (equal \(\mathcal{W}_\mathtt{T}\) on every platform) mask object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">otherMask</td><td>The mask to be converted. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abfd34f3d36cba040796da7139fa47a96"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abfd34f3d36cba040796da7139fa47a96">&#9670;&nbsp;</a></span>Mask() <span class="overload">[6/8]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVc_1_1Mask.html">Mask</a> </td>
          <td>(</td>
          <td class="paramtype">U &amp;&amp;&#160;</td>
          <td class="paramname"><em>otherMask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Common::enable_if_mask_converts_explicitly&lt; T, U &gt;&#160;</td>
          <td class="paramname"> = <code>nullarg</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Explicit conversion (static_cast) from a mask object that potentially has a different \(\mathcal{W}_\mathtt{T}\). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">otherMask</td><td>The mask to be converted. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a51f078ac5cebddf00ee5e1ed8ae31506"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51f078ac5cebddf00ee5e1ed8ae31506">&#9670;&nbsp;</a></span>Mask() <span class="overload">[7/8]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVc_1_1Mask.html">Mask</a> </td>
          <td>(</td>
          <td class="paramtype">const bool *&#160;</td>
          <td class="paramname"><em>mem</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Load constructor from an array of <code>bool</code>. </p>
<p>This constructor implements an explicit conversion from an array of booleans to a mask object. It corresponds to a <a class="el" href="classVc_1_1Vector.html" title="The main vector class for expressing data parallelism.">Vector</a> load constructor.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mem</td><td>A pointer to the start of the array of booleans. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classVc_1_1Mask.html#ae7eadaf3069893c0130db3dd6e315845" title="Overload of the above with a load/store flag argument.">Mask(const bool *, Flags)</a>, <a class="el" href="classVc_1_1Mask.html#a587a49eeafeaca6d87eddd82401a9770" title="Load the components of the mask from an array of bool.">load(const bool *)</a> </dd></dl>

</div>
</div>
<a id="ae7eadaf3069893c0130db3dd6e315845"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae7eadaf3069893c0130db3dd6e315845">&#9670;&nbsp;</a></span>Mask() <span class="overload">[8/8]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVc_1_1Mask.html">Mask</a> </td>
          <td>(</td>
          <td class="paramtype">const bool *&#160;</td>
          <td class="paramname"><em>mem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Flags&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Overload of the above with a load/store flag argument. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mem</td><td>A pointer to the start of the array of booleans. </td></tr>
    <tr><td class="paramname">flags</td><td>Choose a combination of flags such as <a class="el" href="group__Utilities.html#ga9e53bd74b9a47cb8f16bf12018c3670e" title="Use this object for a flags parameter to request aligned loads and stores.">Vc::Aligned</a>, <a class="el" href="group__Utilities.html#gadc83bcfec8f15d1d02fb53baa3f38185" title="Use this object for a flags parameter to request streaming loads and stores.">Vc::Streaming</a>, <a class="el" href="group__Utilities.html#ga91774bc3f3fc00d22deff300919d811c" title="Use this object for a flags parameter to request unaligned loads and stores.">Vc::Unaligned</a>, <a class="el" href="group__Utilities.html#ga3bed7ba639e9ef78c79421c801b43e59" title="Use this object for a flags parameter to request default software prefetches to be emitted.">Vc::PrefetchDefault</a>, ... </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classVc_1_1Mask.html#a38343ac76b1d41622098b7cfb7b2c581" title="Overload of the above with a load/store flag argument.">load(const bool *, Flags)</a> </dd></dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a1b5d7e2e663d7997796fd9f72b8af75a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b5d7e2e663d7997796fd9f72b8af75a">&#9670;&nbsp;</a></span>size()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr size_t size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of boolean components ( \(\mathcal{W}_\mathtt{T}\)) in a mask of this type. </p>
<p>The size of the mask. I.e. the number of boolean entries in the mask. Do not make any assumptions about the size of masks.</p>
<p>In addition, you can easily use if clauses that compare sizes. The compiler can statically evaluate and fully optimize dead code away (very much like #ifdef, but with syntax checking).</p>
<dl class="section return"><dt>Returns</dt><dd>The number of components (i.e. \(\mathcal{W}_\mathtt{T}\)) objects of this mask type store and manipulate. </dd></dl>

<p class="definition">Definition at line <a class="el" href="mask_8h_source.html#l00057">57</a> of file <a class="el" href="mask_8h_source.html">mask.h</a>.</p>

</div>
</div>
<a id="a2be492a48f12ce0897fe60bf8980ebea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2be492a48f12ce0897fe60bf8980ebea">&#9670;&nbsp;</a></span>Zero()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classVc_1_1Mask.html">Mask</a> Zero </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new mask object initialized to zero/<code>false</code>. </p>
<dl class="section return"><dt>Returns</dt><dd>A mask object with zero-initialized components. </dd></dl>

</div>
</div>
<a id="a9872d89a68448bcfdde4160df3229fb8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9872d89a68448bcfdde4160df3229fb8">&#9670;&nbsp;</a></span>One()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classVc_1_1Mask.html">Mask</a> One </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a mask object initialized to one/<code>true</code>. </p>
<dl class="section return"><dt>Returns</dt><dd>A mask object with components initialized to <code>true</code>. </dd></dl>

</div>
</div>
<a id="a587a49eeafeaca6d87eddd82401a9770"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a587a49eeafeaca6d87eddd82401a9770">&#9670;&nbsp;</a></span>load() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void load </td>
          <td>(</td>
          <td class="paramtype">const bool *&#160;</td>
          <td class="paramname"><em>mem</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Load the components of the mask from an array of <code>bool</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mem</td><td>A pointer to the start of the array of booleans. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classVc_1_1Mask.html#a38343ac76b1d41622098b7cfb7b2c581" title="Overload of the above with a load/store flag argument.">load(const bool *, Flags)</a>, <a class="el" href="classVc_1_1Mask.html#a51f078ac5cebddf00ee5e1ed8ae31506" title="Load constructor from an array of bool.">Mask(const bool *)</a> </dd></dl>

</div>
</div>
<a id="a38343ac76b1d41622098b7cfb7b2c581"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a38343ac76b1d41622098b7cfb7b2c581">&#9670;&nbsp;</a></span>load() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void load </td>
          <td>(</td>
          <td class="paramtype">const bool *&#160;</td>
          <td class="paramname"><em>mem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Flags&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Overload of the above with a load/store flag argument. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mem</td><td>A pointer to the start of the array of booleans. </td></tr>
    <tr><td class="paramname">flags</td><td>Choose a combination of flags such as <a class="el" href="group__Utilities.html#ga9e53bd74b9a47cb8f16bf12018c3670e" title="Use this object for a flags parameter to request aligned loads and stores.">Vc::Aligned</a>, <a class="el" href="group__Utilities.html#gadc83bcfec8f15d1d02fb53baa3f38185" title="Use this object for a flags parameter to request streaming loads and stores.">Vc::Streaming</a>, <a class="el" href="group__Utilities.html#ga91774bc3f3fc00d22deff300919d811c" title="Use this object for a flags parameter to request unaligned loads and stores.">Vc::Unaligned</a>, <a class="el" href="group__Utilities.html#ga3bed7ba639e9ef78c79421c801b43e59" title="Use this object for a flags parameter to request default software prefetches to be emitted.">Vc::PrefetchDefault</a>, ... </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classVc_1_1Mask.html#ae7eadaf3069893c0130db3dd6e315845" title="Overload of the above with a load/store flag argument.">Mask(const bool *, Flags)</a> </dd></dl>

</div>
</div>
<a id="a05f98034a4ff730c8398fe580d8c89a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05f98034a4ff730c8398fe580d8c89a9">&#9670;&nbsp;</a></span>store() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void store </td>
          <td>(</td>
          <td class="paramtype">bool *&#160;</td>
          <td class="paramname"><em>mem</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Store the values of the mask to an array of <code>bool</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mem</td><td>A pointer to the start of the array of booleans. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd>store(bool *, Flags) </dd></dl>

</div>
</div>
<a id="a142cb73c607b8d20f501f1afd4252d37"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a142cb73c607b8d20f501f1afd4252d37">&#9670;&nbsp;</a></span>store() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void store </td>
          <td>(</td>
          <td class="paramtype">bool *&#160;</td>
          <td class="paramname"><em>mem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Flags&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Overload of the above with a load/store flag argument. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mem</td><td>A pointer to the start of the array of booleans. </td></tr>
    <tr><td class="paramname">flags</td><td>Choose a combination of flags such as <a class="el" href="group__Utilities.html#ga9e53bd74b9a47cb8f16bf12018c3670e" title="Use this object for a flags parameter to request aligned loads and stores.">Vc::Aligned</a>, <a class="el" href="group__Utilities.html#gadc83bcfec8f15d1d02fb53baa3f38185" title="Use this object for a flags parameter to request streaming loads and stores.">Vc::Streaming</a>, <a class="el" href="group__Utilities.html#ga91774bc3f3fc00d22deff300919d811c" title="Use this object for a flags parameter to request unaligned loads and stores.">Vc::Unaligned</a>, <a class="el" href="group__Utilities.html#ga3bed7ba639e9ef78c79421c801b43e59" title="Use this object for a flags parameter to request default software prefetches to be emitted.">Vc::PrefetchDefault</a>, ... </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a80cd71dcc209f00af9919ba3fd45c9d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a80cd71dcc209f00af9919ba3fd45c9d2">&#9670;&nbsp;</a></span>operator==()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classVc_1_1Mask.html">Mask</a>&lt; T, Abi &gt; &amp;&#160;</td>
          <td class="paramname"><em>mask</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns whether the two masks are equal in all components. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mask</td><td>The other mask to compare against. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A scalar boolean value that says whether all components of the two masks are equal.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>If you expected a behavior similar to the compare operator of <a class="el" href="classVc_1_1Vector.html" title="The main vector class for expressing data parallelism.">Vc::Vector</a>, consider that the bitwise operators already implement such functionality. There is little use, typically, in having <code>a == b</code> return the same as <code>a ^ b</code>. In general, it is more useful to query <code>all_of(a ^ b)</code> which is the same as this equality operator. </dd></dl>

</div>
</div>
<a id="acb4b8622204614329978ed0686cc1073"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb4b8622204614329978ed0686cc1073">&#9670;&nbsp;</a></span>operator!=()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classVc_1_1Mask.html#a08f21c688f3a3e0e5cc321714e3e974a">operator!</a>= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classVc_1_1Mask.html">Mask</a>&lt; T, Abi &gt; &amp;&#160;</td>
          <td class="paramname"><em>mask</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns whether the two masks are different in at least one component. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mask</td><td>The other mask to compare against. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A scalar boolean value that says whether at least one component of the two masks is different.</dd></dl>
<dl class="section note"><dt>Note</dt><dd><code>(a == b) == !(a != b)</code> holds </dd></dl>
<dl class="section see"><dt>See also</dt><dd>Mask::operator==(const Mask &amp;) </dd></dl>

</div>
</div>
<a id="ae0f6159e65556d0cdcb735447e8a8b42"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0f6159e65556d0cdcb735447e8a8b42">&#9670;&nbsp;</a></span>operator[]() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVc_1_1Mask.html#a70a0859ec263806a8067448f6b70b708">EntryReference</a> operator[] </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Lvalue-reference-like access to mask entries. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>Determines the boolean to be accessed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a temporary proxy object referencing the <code>index</code> th entry of the mask.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>This operator does not return an lvalue reference (to <code>bool</code>), but rather a temporary (rvalue) object that mimics an lvalue reference (as much as is possible with C++11/14). </dd></dl>

</div>
</div>
<a id="a4f3da9ad86cc3c301b93627f0a767d26"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f3da9ad86cc3c301b93627f0a767d26">&#9670;&nbsp;</a></span>operator[]() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVc_1_1Mask.html#af8d79876e53834654a2c408d3a3bca6a">EntryType</a> operator[] </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read-only access to mask entries. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>Determines the boolean to be accessed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The <code>index</code> th entry of the mask as a <code>bool</code> (rvalue).</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>This operator does not return an lvalue reference (to <code>const bool</code>), but rather a temporary (rvalue) <code>bool</code>. </dd></dl>

</div>
</div>
<a id="ad24cd7d179a4f1b5d9435ad8e913dc34"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad24cd7d179a4f1b5d9435ad8e913dc34">&#9670;&nbsp;</a></span>firstOne()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int firstOne </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the index of the first one in the mask. </p>
<dl class="section return"><dt>Returns</dt><dd>the index of the first component that is <code>true</code>.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>The return value is undefined if the mask is empty.</dd></dl>
<p>Thus, unless <code>none_of(mask)</code>, <code>mask[mask.firstOne()] == true</code> holds and <code>mask[i] == false</code> for all <code>i &lt; mask.firstOne()</code>. </p>

</div>
</div>
<a id="a8cc7782de081ce702a9be163b4cb8f84"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8cc7782de081ce702a9be163b4cb8f84">&#9670;&nbsp;</a></span>toInt()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int toInt </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert the boolean components of the mask into bits of an integer. </p>
<dl class="section return"><dt>Returns</dt><dd>An <code>int</code> where each bit corresponds to the boolean value in the mask.</dd></dl>
<p>For example, the mask <code>[true, false, false, true]</code> results in a <code>9</code> (in binary: <code>1001</code>). </p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a879ad9933a419e4e04c8a59cc19a34fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a879ad9933a419e4e04c8a59cc19a34fe">&#9670;&nbsp;</a></span>Size</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr size_t Size = VectorTraits&lt;T, Abi&gt;::<a class="el" href="classVc_1_1Mask.html#a1b5d7e2e663d7997796fd9f72b8af75a">size</a>()</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of boolean components ( \(\mathcal{W}_\mathtt{T}\)) in a mask of this type. </p>
<p>The size of the mask. I.e. the number of boolean entries in the mask. Do not make any assumptions about the size of masks.</p>
<p>In addition, you can easily use if clauses that compare sizes. The compiler can statically evaluate and fully optimize dead code away (very much like #ifdef, but with syntax checking).</p>
<dl class="section return"><dt>Returns</dt><dd>The number of components (i.e. \(\mathcal{W}_\mathtt{T}\)) objects of this mask type store and manipulate. </dd></dl>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000014">Deprecated:</a></b></dt><dd>Use <a class="el" href="classVc_1_1Mask.html#a1b5d7e2e663d7997796fd9f72b8af75a" title="Returns the number of boolean components ( ) in a mask of this type.">Vc::Mask::size</a> instead. </dd></dl>

<p class="definition">Definition at line <a class="el" href="mask_8h_source.html#l00060">60</a> of file <a class="el" href="mask_8h_source.html">mask.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="IO_source.html#l00157">Vc::operator&lt;&lt;()</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>/home/axel/build/Vc/src/Vc/<a class="el" href="fwddecl_8h_source.html">fwddecl.h</a></li>
<li>/home/axel/build/Vc/src/Vc/common/<a class="el" href="mask_8h_source.html">mask.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespaceVc.html">Vc</a></li><li class="navelem"><a class="el" href="classVc_1_1Mask.html">Mask</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1 </li>
  </ul>
</div>
</body>
</html>
